import {
  createCredential,
  createStore,
  devtools,
  from as from6,
  fromAbi as fromAbi2,
  getExecuteError,
  getPublicKey as getPublicKey2,
  getSignPayload,
  getSignPayload2,
  p256,
  persist,
  randomPrivateKey as randomPrivateKey2,
  sign as sign2,
  sign2 as sign3,
  subscribeWithSelector,
  toAccount
} from "./chunk-TGV774A3.js";
import {
  createStore as createStore2,
  del,
  get,
  set
} from "./chunk-ANJCMEYS.js";
import {
  anvil,
  arbitrum,
  arbitrumSepolia,
  base,
  baseSepolia,
  berachain,
  berachainBepolia,
  bsc,
  celo,
  gnosis,
  hoodi,
  katana,
  mainnet,
  optimism,
  optimismSepolia,
  polygon,
  sepolia
} from "./chunk-774SXLQ4.js";
import {
  announceProvider
} from "./chunk-EDDRWZDP.js";
import {
  import_index
} from "./chunk-DNZQWNG5.js";
import {
  createClient,
  createTransport,
  encode,
  encodeData,
  encodePacked2 as encodePacked,
  fallback,
  from as from3,
  from2 as from4,
  from3 as from5,
  fromAbi2 as fromAbi,
  fromHex,
  fromHex2,
  fromPublicKey,
  getEip712Domain,
  getPublicKey,
  getSelector,
  getSelector2,
  hashMessage,
  hashTypedData,
  http,
  isEqual,
  keccak256,
  randomPrivateKey,
  recoverAddress,
  sign,
  toHex as toHex2,
  toHex2 as toHex3,
  validate as validate2,
  verifyHash,
  waitForCallsStatus,
  webSocket,
  withCache,
  wrap,
  zeroAddress
} from "./chunk-VURXUZ5V.js";
import {
  BaseError as BaseError2,
  concat,
  from,
  from2,
  fromArray,
  fromNumber,
  fromString,
  fromString2,
  padLeft,
  parse,
  size2 as size,
  slice,
  slice2,
  stringify,
  toBigInt,
  toBigInt2,
  toHex,
  toNumber2 as toNumber,
  validate2 as validate
} from "./chunk-5IUPPIOL.js";
import {
  defineChain
} from "./chunk-LZDXEOLU.js";
import {
  BaseError,
  getAddress
} from "./chunk-RZZ4AH52.js";
import {
  __export
} from "./chunk-ONY6HBPH.js";

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/Chains.js
var Chains_exports = {};
__export(Chains_exports, {
  all: () => all,
  anvil: () => anvil2,
  anvil2: () => anvil22,
  anvil3: () => anvil3,
  arbitrum: () => arbitrum,
  arbitrumSepolia: () => arbitrumSepolia,
  base: () => base,
  baseSepolia: () => baseSepolia,
  berachain: () => berachain,
  berachainBepolia: () => berachainBepolia,
  bsc: () => bsc,
  celo: () => celo,
  gnosis: () => gnosis,
  hoodi: () => hoodi,
  katana: () => katana,
  mainnet: () => mainnet,
  optimism: () => optimism,
  optimismSepolia: () => optimismSepolia,
  polygon: () => polygon,
  sepolia: () => sepolia
});

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/_generated/chains.js
var chains_exports = {};
__export(chains_exports, {
  arbitrum: () => arbitrum,
  arbitrumSepolia: () => arbitrumSepolia,
  base: () => base,
  baseSepolia: () => baseSepolia,
  berachain: () => berachain,
  berachainBepolia: () => berachainBepolia,
  bsc: () => bsc,
  celo: () => celo,
  gnosis: () => gnosis,
  hoodi: () => hoodi,
  katana: () => katana,
  mainnet: () => mainnet,
  optimism: () => optimism,
  optimismSepolia: () => optimismSepolia,
  polygon: () => polygon,
  sepolia: () => sepolia
});

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/Chains.js
var all = [
  base,
  ...Object.values(chains_exports).filter((c) => c && c.id !== base.id)
];
var anvil2 = anvil;
var anvil22 = defineChain({
  ...anvil2,
  id: 31338
});
var anvil3 = defineChain({
  ...anvil2,
  id: 31339
});

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/Dialog.js
var Dialog_exports = {};
__export(Dialog_exports, {
  authSession: () => authSession,
  createThemeController: () => createThemeController,
  defaultSize: () => defaultSize,
  experimental_inline: () => experimental_inline,
  from: () => from9,
  getDialogUrl: () => getDialogUrl,
  getReferrer: () => getReferrer,
  handleBlur: () => handleBlur,
  handleResponse: () => handleResponse,
  hostUrls: () => hostUrls,
  iframe: () => iframe,
  noop: () => noop2,
  popup: () => popup,
  requiresConfirmation: () => requiresConfirmation
});

// node_modules/ox/_esm/core/RpcResponse.js
function parse2(response, options = {}) {
  const { raw = false } = options;
  const response_ = response;
  if (raw)
    return response;
  if (response_.error)
    throw parseError(response_.error);
  return response_.result;
}
function parseError(error46) {
  const error_ = error46;
  if (error_ instanceof Error && !("code" in error_))
    return new InternalError({
      cause: error_,
      data: error_,
      message: error_.message,
      stack: error_.stack
    });
  const { code: code2 } = error_;
  if (code2 === InternalError.code)
    return new InternalError(error_);
  if (code2 === InvalidInputError.code)
    return new InvalidInputError(error_);
  if (code2 === InvalidParamsError.code)
    return new InvalidParamsError(error_);
  if (code2 === InvalidRequestError.code)
    return new InvalidRequestError(error_);
  if (code2 === LimitExceededError.code)
    return new LimitExceededError(error_);
  if (code2 === MethodNotFoundError.code)
    return new MethodNotFoundError(error_);
  if (code2 === MethodNotSupportedError.code)
    return new MethodNotSupportedError(error_);
  if (code2 === ParseError.code)
    return new ParseError(error_);
  if (code2 === ResourceNotFoundError.code)
    return new ResourceNotFoundError(error_);
  if (code2 === ResourceUnavailableError.code)
    return new ResourceUnavailableError(error_);
  if (code2 === TransactionRejectedError.code)
    return new TransactionRejectedError(error_);
  if (code2 === VersionNotSupportedError.code)
    return new VersionNotSupportedError(error_);
  return new InternalError({
    cause: error_ instanceof Error ? error_ : void 0,
    data: error_,
    message: error_.message,
    stack: error_ instanceof Error ? error_.stack : void 0
  });
}
var BaseError3 = class extends Error {
  constructor(errorObject) {
    const { cause, code: code2, message, data, stack } = errorObject;
    super(message, { cause });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.BaseError"
    });
    Object.defineProperty(this, "cause", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "stack", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.cause = cause;
    this.code = code2;
    this.data = data;
    this.stack = stack ?? "";
  }
};
var InvalidInputError = class _InvalidInputError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _InvalidInputError.code,
      data: parameters.data,
      message: parameters.message ?? "Missing or invalid parameters."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32e3
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InvalidInputError"
    });
  }
};
Object.defineProperty(InvalidInputError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32e3
});
var ResourceNotFoundError = class _ResourceNotFoundError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _ResourceNotFoundError.code,
      data: parameters.data,
      message: parameters.message ?? "Requested resource not found."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32001
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.ResourceNotFoundError"
    });
  }
};
Object.defineProperty(ResourceNotFoundError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32001
});
var ResourceUnavailableError = class _ResourceUnavailableError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _ResourceUnavailableError.code,
      data: parameters.data,
      message: parameters.message ?? "Requested resource not available."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32002
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.ResourceUnavailableError"
    });
  }
};
Object.defineProperty(ResourceUnavailableError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32002
});
var TransactionRejectedError = class _TransactionRejectedError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _TransactionRejectedError.code,
      data: parameters.data,
      message: parameters.message ?? "Transaction creation failed."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32003
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.TransactionRejectedError"
    });
  }
};
Object.defineProperty(TransactionRejectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32003
});
var MethodNotSupportedError = class _MethodNotSupportedError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _MethodNotSupportedError.code,
      data: parameters.data,
      message: parameters.message ?? "Method is not implemented."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32004
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.MethodNotSupportedError"
    });
  }
};
Object.defineProperty(MethodNotSupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32004
});
var LimitExceededError = class _LimitExceededError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _LimitExceededError.code,
      data: parameters.data,
      message: parameters.message ?? "Rate limit exceeded."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32005
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.LimitExceededError"
    });
  }
};
Object.defineProperty(LimitExceededError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32005
});
var VersionNotSupportedError = class _VersionNotSupportedError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _VersionNotSupportedError.code,
      data: parameters.data,
      message: parameters.message ?? "JSON-RPC version not supported."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32006
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.VersionNotSupportedError"
    });
  }
};
Object.defineProperty(VersionNotSupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32006
});
var InvalidRequestError = class _InvalidRequestError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _InvalidRequestError.code,
      data: parameters.data,
      message: parameters.message ?? "Input is not a valid JSON-RPC request."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32600
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InvalidRequestError"
    });
  }
};
Object.defineProperty(InvalidRequestError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32600
});
var MethodNotFoundError = class _MethodNotFoundError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _MethodNotFoundError.code,
      data: parameters.data,
      message: parameters.message ?? "Method does not exist."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32601
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.MethodNotFoundError"
    });
  }
};
Object.defineProperty(MethodNotFoundError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32601
});
var InvalidParamsError = class _InvalidParamsError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _InvalidParamsError.code,
      data: parameters.data,
      message: parameters.message ?? "Invalid method parameters."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32602
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InvalidParamsError"
    });
  }
};
Object.defineProperty(InvalidParamsError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32602
});
var InternalError = class _InternalError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      cause: parameters.cause,
      code: _InternalError.code,
      data: parameters.data,
      message: parameters.message ?? "Internal JSON-RPC error.",
      stack: parameters.stack
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32603
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InternalError"
    });
  }
};
Object.defineProperty(InternalError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32603
});
var ParseError = class _ParseError extends BaseError3 {
  constructor(parameters = {}) {
    super({
      code: _ParseError.code,
      data: parameters.data,
      message: parameters.message ?? "Failed to parse JSON-RPC response."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32700
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.ParseError"
    });
  }
};
Object.defineProperty(ParseError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32700
});

// node_modules/ox/_esm/core/Provider.js
var ProviderRpcError = class extends Error {
  constructor(code2, message) {
    super(message);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderRpcError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.code = code2;
    this.details = message;
  }
};
var UserRejectedRequestError = class extends ProviderRpcError {
  constructor({ message = "The user rejected the request." } = {}) {
    super(4001, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4001
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UserRejectedRequestError"
    });
  }
};
Object.defineProperty(UserRejectedRequestError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4001
});
var UnauthorizedError = class extends ProviderRpcError {
  constructor({ message = "The requested method and/or account has not been authorized by the user." } = {}) {
    super(4100, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4100
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnauthorizedError"
    });
  }
};
Object.defineProperty(UnauthorizedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4100
});
var UnsupportedMethodError = class extends ProviderRpcError {
  constructor({ message = "The provider does not support the requested method." } = {}) {
    super(4200, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4200
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnsupportedMethodError"
    });
  }
};
Object.defineProperty(UnsupportedMethodError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4200
});
var DisconnectedError = class extends ProviderRpcError {
  constructor({ message = "The provider is disconnected from all chains." } = {}) {
    super(4900, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4900
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.DisconnectedError"
    });
  }
};
Object.defineProperty(DisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4900
});
var ChainDisconnectedError = class extends ProviderRpcError {
  constructor({ message = "The provider is not connected to the requested chain." } = {}) {
    super(4901, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4901
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.ChainDisconnectedError"
    });
  }
};
Object.defineProperty(ChainDisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4901
});
var SwitchChainError = class extends ProviderRpcError {
  constructor({ message = "An error occurred when attempting to switch chain." } = {}) {
    super(4902, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4902
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.SwitchChainError"
    });
  }
};
Object.defineProperty(SwitchChainError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4902
});
var UnsupportedNonOptionalCapabilityError = class extends ProviderRpcError {
  constructor({ message = "This Wallet does not support a capability that was not marked as optional." } = {}) {
    super(5700, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5700
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnsupportedNonOptionalCapabilityError"
    });
  }
};
Object.defineProperty(UnsupportedNonOptionalCapabilityError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5700
});
var UnsupportedChainIdError = class extends ProviderRpcError {
  constructor({ message = "This Wallet does not support the requested chain ID." } = {}) {
    super(5710, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5710
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnsupportedChainIdError"
    });
  }
};
Object.defineProperty(UnsupportedChainIdError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5710
});
var DuplicateIdError = class extends ProviderRpcError {
  constructor({ message = "There is already a bundle submitted with this ID." } = {}) {
    super(5720, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5720
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.DuplicateIdError"
    });
  }
};
Object.defineProperty(DuplicateIdError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5720
});
var UnknownBundleIdError = class extends ProviderRpcError {
  constructor({ message = "This bundle id is unknown / has not been submitted." } = {}) {
    super(5730, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5730
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnknownBundleIdError"
    });
  }
};
Object.defineProperty(UnknownBundleIdError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5730
});
var BundleTooLargeError = class extends ProviderRpcError {
  constructor({ message = "The call bundle is too large for the Wallet to process." } = {}) {
    super(5740, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5740
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.BundleTooLargeError"
    });
  }
};
Object.defineProperty(BundleTooLargeError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5740
});
var AtomicReadyWalletRejectedUpgradeError = class extends ProviderRpcError {
  constructor({ message = "The Wallet can support atomicity after an upgrade, but the user rejected the upgrade." } = {}) {
    super(5750, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5750
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.AtomicReadyWalletRejectedUpgradeError"
    });
  }
};
Object.defineProperty(AtomicReadyWalletRejectedUpgradeError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5750
});
var AtomicityNotSupportedError = class extends ProviderRpcError {
  constructor({ message = "The wallet does not support atomic execution but the request requires it." } = {}) {
    super(5760, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 5760
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.AtomicityNotSupportedError"
    });
  }
};
Object.defineProperty(AtomicityNotSupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 5760
});
function createEmitter() {
  const emitter = new import_index.default();
  return {
    get eventNames() {
      return emitter.eventNames.bind(emitter);
    },
    get listenerCount() {
      return emitter.listenerCount.bind(emitter);
    },
    get listeners() {
      return emitter.listeners.bind(emitter);
    },
    addListener: emitter.addListener.bind(emitter),
    emit: emitter.emit.bind(emitter),
    off: emitter.off.bind(emitter),
    on: emitter.on.bind(emitter),
    once: emitter.once.bind(emitter),
    removeAllListeners: emitter.removeAllListeners.bind(emitter),
    removeListener: emitter.removeListener.bind(emitter)
  };
}
function from7(provider, options = {}) {
  var _a2, _b;
  const { includeEvents = true } = options;
  if (!provider)
    throw new IsUndefinedError();
  return {
    ...includeEvents ? {
      on: (_a2 = provider.on) == null ? void 0 : _a2.bind(provider),
      removeListener: (_b = provider.removeListener) == null ? void 0 : _b.bind(provider)
    } : {},
    async request(args) {
      try {
        const result = await provider.request(args);
        if (result && typeof result === "object" && "jsonrpc" in result)
          return parse2(result);
        return result;
      } catch (error46) {
        throw parseError2(error46);
      }
    }
  };
}
function parseError2(error46) {
  const error_ = parseError(error46);
  if (error_ instanceof InternalError) {
    if (!error_.data)
      return error_;
    const { code: code2 } = error_.data;
    if (code2 === DisconnectedError.code)
      return new DisconnectedError(error_);
    if (code2 === ChainDisconnectedError.code)
      return new ChainDisconnectedError(error_);
    if (code2 === UserRejectedRequestError.code)
      return new UserRejectedRequestError(error_);
    if (code2 === UnauthorizedError.code)
      return new UnauthorizedError(error_);
    if (code2 === UnsupportedMethodError.code)
      return new UnsupportedMethodError(error_);
    if (code2 === SwitchChainError.code)
      return new SwitchChainError(error_);
    if (code2 === AtomicReadyWalletRejectedUpgradeError.code)
      return new AtomicReadyWalletRejectedUpgradeError(error_);
    if (code2 === AtomicityNotSupportedError.code)
      return new AtomicityNotSupportedError(error_);
    if (code2 === BundleTooLargeError.code)
      return new BundleTooLargeError(error_);
    if (code2 === UnknownBundleIdError.code)
      return new UnknownBundleIdError(error_);
    if (code2 === DuplicateIdError.code)
      return new DuplicateIdError(error_);
    if (code2 === UnsupportedChainIdError.code)
      return new UnsupportedChainIdError(error_);
    if (code2 === UnsupportedNonOptionalCapabilityError.code)
      return new UnsupportedNonOptionalCapabilityError(error_);
  }
  return error_;
}
var IsUndefinedError = class extends BaseError2 {
  constructor() {
    super("`provider` is undefined.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.IsUndefinedError"
    });
  }
};

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/intersectionObserver.js
var supported = () => "IntersectionObserver" in window && "IntersectionObserverEntry" in window && "intersectionRatio" in IntersectionObserverEntry.prototype && "isVisible" in IntersectionObserverEntry.prototype;

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/logger.js
function create(options = {}) {
  const { prefix = "[Porto]" } = options;
  const memo = /* @__PURE__ */ new Set();
  return {
    error: createLogFn(console.error, { prefix }),
    errorOnce: createLogFn(console.error, { memo, prefix }),
    log: createLogFn(console.log, { prefix }),
    logOnce: createLogFn(console.log, { memo, prefix }),
    warn: createLogFn(console.warn, { prefix }),
    warnOnce: createLogFn(console.warn, { memo, prefix })
  };
}
var logger = create();
function createLogFn(fn, options = {}) {
  const { memo, prefix } = options;
  return (...messages) => {
    const message = messages.join(" ");
    if (memo == null ? void 0 : memo.has(message))
      return;
    memo == null ? void 0 : memo.add(message);
    fn(`${prefix} ${message}`);
  };
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/userAgent.js
function isSafari() {
  const ua = navigator.userAgent.toLowerCase();
  return ua.includes("safari") && !ua.includes("chrome");
}
function isFirefox() {
  const ua = navigator.userAgent.toLowerCase();
  return (ua.includes("firefox") || ua.includes("fxios")) && !ua.includes("seamonkey");
}
function isMobile() {
  var _a2, _b;
  if ((_b = (_a2 = window.navigator) == null ? void 0 : _a2.userAgentData) == null ? void 0 : _b.mobile)
    return true;
  return (
    // https://developer.mozilla.org/en-US/docs/Web/HTTP/Guides/Browser_detection_using_the_user_agent#alternatives_to_ua_sniffing
    navigator.maxTouchPoints > 1 || /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(navigator.userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(navigator.userAgent.slice(0, 4))
  );
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/Messenger.js
var Messenger_exports = {};
__export(Messenger_exports, {
  bridge: () => bridge,
  cliRelay: () => cliRelay,
  from: () => from8,
  fromWindow: () => fromWindow,
  noop: () => noop
});

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/promise.js
function withResolvers() {
  let resolve = () => void 0;
  let reject = () => void 0;
  const promise2 = new Promise((resolve_, reject_) => {
    resolve = resolve_;
    reject = reject_;
  });
  return { promise: promise2, reject, resolve };
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/utils.js
function normalizeValue(value) {
  if (Array.isArray(value))
    return value.map(normalizeValue);
  if (typeof value === "function")
    return void 0;
  if (typeof value !== "object" || value === null)
    return value;
  if (Object.getPrototypeOf(value) !== Object.prototype)
    try {
      return structuredClone(value);
    } catch {
      return void 0;
    }
  const normalized = {};
  for (const [k, v] of Object.entries(value))
    normalized[k] = normalizeValue(v);
  return normalized;
}
function uniqBy(data, fn) {
  const result = [];
  const seen = /* @__PURE__ */ new Set();
  for (const item of data) {
    const key = fn(item);
    if (!seen.has(key)) {
      seen.add(key);
      result.push(item);
    }
  }
  return result;
}
function uuidv4() {
  if (typeof globalThis !== "undefined" && "crypto" in globalThis)
    return globalThis.crypto.randomUUID();
  return crypto.randomUUID();
}
function withDedupe(fn, { enabled = true, id }) {
  if (!enabled || !id)
    return fn();
  if (withDedupe.cache.get(id))
    return withDedupe.cache.get(id);
  const promise2 = fn().finally(() => withDedupe.cache.delete(id));
  withDedupe.cache.set(id, promise2);
  return promise2;
}
(function(withDedupe2) {
  withDedupe2.cache = /* @__PURE__ */ new Map();
})(withDedupe || (withDedupe = {}));

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/Messenger.js
function from8(messenger) {
  return messenger;
}
function fromWindow(w, options = {}) {
  const { targetOrigin } = options;
  const listeners = /* @__PURE__ */ new Map();
  return from8({
    destroy() {
      for (const listener of listeners.values()) {
        w.removeEventListener("message", listener);
      }
    },
    on(topic, listener, id) {
      function handler(event) {
        if (event.data.topic !== topic)
          return;
        if (id && event.data.id !== id)
          return;
        if (targetOrigin && event.origin !== targetOrigin)
          return;
        listener(event.data.payload, event);
      }
      w.addEventListener("message", handler);
      listeners.set(topic, handler);
      return () => w.removeEventListener("message", handler);
    },
    async send(topic, payload, target) {
      const id = uuidv4();
      w.postMessage(normalizeValue({ id, payload, topic }), target ?? targetOrigin ?? "*");
      return { id, payload, topic };
    },
    async sendAsync(topic, payload, target) {
      const { id } = await this.send(topic, payload, target);
      return new Promise((resolve) => this.on(topic, resolve, id));
    }
  });
}
function bridge(parameters) {
  const { from: from_, to, waitForReady = false } = parameters;
  let pending = false;
  const ready = withResolvers();
  from_.on("ready", ready.resolve);
  const messenger = from8({
    destroy() {
      from_.destroy();
      to.destroy();
      if (pending)
        ready.reject();
    },
    on(topic, listener, id) {
      return from_.on(topic, listener, id);
    },
    async send(topic, payload) {
      pending = true;
      if (waitForReady)
        await ready.promise.finally(() => pending = false);
      return to.send(topic, payload);
    },
    async sendAsync(topic, payload) {
      pending = true;
      if (waitForReady)
        await ready.promise.finally(() => pending = false);
      return to.sendAsync(topic, payload);
    }
  });
  return {
    ...messenger,
    ready(options) {
      void messenger.send("ready", options);
    },
    waitForReady() {
      return ready.promise;
    }
  };
}
function noop() {
  return {
    destroy() {
    },
    on() {
      return () => {
      };
    },
    ready() {
    },
    send() {
      return Promise.resolve(void 0);
    },
    sendAsync() {
      return Promise.resolve(void 0);
    },
    waitForReady() {
      return Promise.resolve(void 0);
    }
  };
}
function cliRelay(options) {
  const { relayUrl } = options;
  let eventSource = null;
  const listenerSets = /* @__PURE__ */ new Map();
  function connect() {
    if (!relayUrl || eventSource)
      return;
    eventSource = new EventSource(relayUrl);
    eventSource.onmessage = (event) => {
      try {
        const data = JSON.parse(event.data);
        if (!data.topic)
          return;
        if (!data.payload)
          return;
        const listeners = listenerSets.get(data.topic);
        if (!listeners)
          return;
        for (const listener of listeners)
          listener(data.payload, { data, origin: relayUrl });
      } catch (error46) {
        console.error("Error parsing SSE message:", error46);
      }
    };
    eventSource.onerror = (error46) => {
      console.error("SSE connection error:", error46);
      eventSource == null ? void 0 : eventSource.close();
      eventSource = null;
      setTimeout(connect, 1e3);
    };
  }
  connect();
  async function request(topic, payload) {
    const id = uuidv4();
    const data = { id, payload, topic };
    const response = await fetch(relayUrl, {
      body: stringify(data),
      headers: {
        "Content-Type": "application/json"
      },
      method: "POST"
    });
    return { id, payload, response, topic };
  }
  return {
    destroy() {
      eventSource == null ? void 0 : eventSource.close();
      eventSource = null;
      listenerSets.clear();
    },
    on(topic, listener) {
      if (!listenerSets.has(topic))
        listenerSets.set(topic, /* @__PURE__ */ new Set());
      listenerSets.get(topic).add(listener);
      return () => {
        const listeners = listenerSets.get(topic);
        if (!listeners)
          return;
        listeners.delete(listener);
        if (listeners.size === 0)
          listenerSets.delete(topic);
      };
    },
    async ready(options2) {
      await new Promise((resolve) => setTimeout(resolve, 32));
      void this.send("ready", options2);
    },
    async send(topic, payload) {
      const { id } = await request(topic, payload);
      return { id, payload, topic };
    },
    async sendAsync(topic, payload) {
      const { response } = await request(topic, payload);
      if (!response.ok)
        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
      const contentType = response.headers.get("content-type");
      if (contentType == null ? void 0 : contentType.includes("application/json"))
        return await response.json();
      return void 0;
    }
  };
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/react-native/environment.js
var environment;
var reactNative = {
  get environment() {
    if (!environment)
      throw new Error("React Native environment is not configured");
    return environment;
  },
  set environment(env) {
    environment = env;
  }
};

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/react-native/utils.js
function isReactNative() {
  if (typeof navigator !== "undefined" && navigator.product === "ReactNative")
    return true;
  if (typeof window !== "undefined" && Object.hasOwn(window, "ReactNativeWebView"))
    return true;
  if (typeof globalThis !== "undefined" && Object.hasOwn(globalThis, "HermesEngine"))
    return true;
  return false;
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/Dialog.js
var AuthSessionStatus = {
  cancel: "cancel",
  error: "error",
  success: "success",
  unknown: "unknown"
};
var hostUrls = {
  local: "http://localhost:5175/dialog/",
  prod: "https://id.porto.sh/dialog",
  stg: "https://stg.id.porto.sh/dialog"
};
function from9(dialog2) {
  return dialog2;
}
function iframe(options = {}) {
  const { skipProtocolCheck, skipUnsupported } = options;
  const includesUnsupported = (requests) => !skipUnsupported && isSafari() && (requests == null ? void 0 : requests.some((x) => ["wallet_connect", "eth_requestAccounts"].includes(x.method)));
  if (typeof window === "undefined")
    return noop2();
  return from9({
    name: "iframe",
    setup(parameters) {
      const { host, internal, theme, themeController } = parameters;
      const { store } = internal;
      const fallback2 = popup().setup(parameters);
      let open = false;
      const hostUrl = new URL(host);
      const root = document.createElement("dialog");
      root.dataset.porto = "";
      root.setAttribute("role", "dialog");
      root.setAttribute("aria-closed", "true");
      root.setAttribute("aria-label", "Porto Wallet");
      root.setAttribute("hidden", "until-found");
      Object.assign(root.style, {
        background: "transparent",
        border: "0",
        outline: "0",
        padding: "0",
        position: "fixed"
      });
      document.body.appendChild(root);
      const iframe2 = document.createElement("iframe");
      iframe2.setAttribute("data-testid", "porto");
      const iframeAllow = [
        "payment",
        `publickey-credentials-get ${hostUrl.origin}`,
        `publickey-credentials-create ${hostUrl.origin}`
      ];
      if (!isFirefox())
        iframeAllow.push("clipboard-write");
      iframe2.setAttribute("allow", iframeAllow.join("; "));
      iframe2.setAttribute("tabindex", "0");
      iframe2.setAttribute("sandbox", "allow-forms allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox");
      iframe2.setAttribute("src", getDialogUrl(host));
      iframe2.setAttribute("title", "Porto");
      Object.assign(iframe2.style, {
        backgroundColor: "transparent",
        border: "0",
        colorScheme: "light dark",
        height: "100%",
        left: "0",
        position: "fixed",
        top: "0",
        width: "100%"
      });
      const style = document.createElement("style");
      style.innerHTML = `
        dialog[data-porto]::backdrop {
          background: transparent!important;
        }
      `;
      root.appendChild(style);
      root.appendChild(iframe2);
      const messenger = bridge({
        from: fromWindow(window, { targetOrigin: hostUrl.origin }),
        to: fromWindow(iframe2.contentWindow, {
          targetOrigin: hostUrl.origin
        }),
        waitForReady: true
      });
      themeController == null ? void 0 : themeController._setup(messenger, true);
      const drawerModeQuery = window.matchMedia("(max-width: 460px)");
      const onDrawerModeChange = () => {
        messenger.send("__internal", {
          type: "resize",
          // 460 = drawer mode, 461 = floating mode
          width: drawerModeQuery.matches ? 460 : 461
        });
      };
      drawerModeQuery.addEventListener("change", onDrawerModeChange);
      messenger.on("ready", (options2) => {
        const chainIds = parameters.internal.store.getState().chainIds;
        let compatibleChainIds = chainIds.filter((id) => options2.chainIds.includes(id));
        if (compatibleChainIds.length === 0)
          compatibleChainIds = options2.chainIds;
        store.setState((x) => ({
          ...x,
          chainIds: compatibleChainIds
        }));
        messenger.send("__internal", {
          chainIds: compatibleChainIds,
          mode: "iframe",
          referrer: getReferrer(),
          theme,
          type: "init"
        });
        onDrawerModeChange();
      });
      messenger.on("rpc-response", (response) => {
        if (includesUnsupported([response._request])) {
          const src = iframe2.src;
          iframe2.src = src;
        }
        handleResponse(store, response);
      });
      messenger.on("__internal", (payload) => {
        if (payload.type === "switch" && payload.mode === "popup") {
          fallback2.open();
          fallback2.syncRequests(store.getState().requestQueue);
        }
      });
      let bodyStyle = null;
      let opener = null;
      const onBlur = () => handleBlur(store);
      const onEscape = (event) => {
        if (event.key === "Escape")
          handleBlur(store);
      };
      const inertObserver = new MutationObserver((mutations) => {
        for (const mutation of mutations) {
          if (mutation.type !== "attributes")
            continue;
          const name = mutation.attributeName;
          if (!name)
            continue;
          if (name !== "inert")
            continue;
          root.removeAttribute(name);
        }
      });
      inertObserver.observe(root, {
        attributeOldValue: true,
        attributes: true
      });
      let dialogActive = false;
      const activatePage = () => {
        if (!dialogActive)
          return;
        dialogActive = false;
        root.removeEventListener("click", onBlur);
        document.removeEventListener("keydown", onEscape);
        root.style.pointerEvents = "none";
        opener == null ? void 0 : opener.focus();
        opener = null;
        Object.assign(document.body.style, bodyStyle ?? "");
        document.body.style.overflow = (bodyStyle == null ? void 0 : bodyStyle.overflow) ?? "";
      };
      const activateDialog = () => {
        if (dialogActive)
          return;
        dialogActive = true;
        root.addEventListener("click", onBlur);
        document.addEventListener("keydown", onEscape);
        iframe2.focus();
        root.style.pointerEvents = "auto";
        bodyStyle = Object.assign({}, document.body.style);
        document.body.style.overflow = "hidden";
      };
      let visible = false;
      const showDialog = () => {
        if (visible)
          return;
        visible = true;
        if (document.activeElement instanceof HTMLElement)
          opener = document.activeElement;
        root.removeAttribute("hidden");
        root.removeAttribute("aria-closed");
        root.showModal();
      };
      const hideDialog = () => {
        if (!visible)
          return;
        visible = false;
        root.setAttribute("hidden", "true");
        root.setAttribute("aria-closed", "true");
        root.close();
        for (const sibling of root.parentNode ? Array.from(root.parentNode.children) : []) {
          if (sibling === root)
            continue;
          if (!sibling.hasAttribute("inert"))
            continue;
          sibling.removeAttribute("inert");
        }
      };
      return {
        close() {
          fallback2.close();
          open = false;
          messenger.send("__internal", {
            mode: "iframe",
            referrer: getReferrer(),
            type: "init"
          });
          hideDialog();
          activatePage();
        },
        destroy() {
          fallback2.close();
          open = false;
          activatePage();
          hideDialog();
          fallback2.destroy();
          messenger.destroy();
          root.remove();
          inertObserver.disconnect();
          drawerModeQuery.removeEventListener("change", onDrawerModeChange);
        },
        open() {
          if (open)
            return;
          open = true;
          showDialog();
          activateDialog();
          messenger.send("__internal", {
            mode: "iframe",
            referrer: getReferrer(),
            type: "init"
          });
        },
        async secure() {
          const { trustedHosts } = await messenger.waitForReady();
          const secureProtocol = (() => {
            if (skipProtocolCheck)
              return true;
            const secure = window.location.protocol.startsWith("https");
            if (!secure)
              logger.warnOnce("Detected insecure protocol (HTTP).", `

The Porto iframe is not supported on HTTP origins (${window.location.origin})`, "due to lack of WebAuthn support.", "See https://porto.sh/sdk#secure-origins-https for more information.");
            return secure;
          })();
          const intersectionObserverSupported = supported();
          const trustedHost = Boolean(trustedHosts == null ? void 0 : trustedHosts.includes(window.location.hostname));
          const secureFrame = Boolean(intersectionObserverSupported || trustedHost);
          if (!secureFrame)
            logger.warnOnce([
              `Warning: Browser does not support IntersectionObserver v2 or host "${hostUrl.hostname}" is not trusted by Porto.`,
              "This may result in the dialog falling back to a popup.",
              "",
              `Add "${hostUrl.hostname}" to the trusted hosts list to enable iframe dialog: https://github.com/ithacaxyz/porto/edit/main/src/trusted-hosts.ts`
            ].join("\n"));
          return {
            frame: secureFrame,
            host: trustedHost,
            protocol: secureProtocol
          };
        },
        async syncRequests(requests) {
          const { methodPolicies } = await messenger.waitForReady();
          const secure = await this.secure();
          const headless = requests == null ? void 0 : requests.every((request) => {
            var _a2, _b;
            return ((_b = (_a2 = methodPolicies == null ? void 0 : methodPolicies.find((policy) => policy.method === request.request.method)) == null ? void 0 : _a2.modes) == null ? void 0 : _b.headless) === true;
          });
          const unsupported = includesUnsupported(requests.map((x) => x.request));
          if (!headless && (unsupported || !secure.protocol || !secure.frame))
            fallback2.syncRequests(requests);
          else {
            const requiresConfirm = requests.some((x) => requiresConfirmation(x.request, {
              methodPolicies,
              targetOrigin: hostUrl.origin
            }));
            if (!open && requiresConfirm)
              this.open();
            messenger.send("rpc-requests", requests);
          }
        }
      };
    },
    supportsHeadless: true
  });
}
function popup(options = {}) {
  if (typeof window === "undefined")
    return noop2();
  const { type = "auto", size: size2 = defaultSize } = options;
  return from9({
    name: "popup",
    setup(parameters) {
      const { host, internal, themeController } = parameters;
      const { store } = internal;
      const hostUrl = new URL(host);
      let popup2 = null;
      const resolvedType = type === "page" || type === "auto" && isMobile() ? "page" : "popup";
      function onBlur() {
        if (popup2)
          handleBlur(store);
      }
      const offDetectClosed = (() => {
        const timer = setInterval(() => {
          if (popup2 == null ? void 0 : popup2.closed)
            handleBlur(store);
        }, 100);
        return () => clearInterval(timer);
      })();
      let messenger;
      themeController == null ? void 0 : themeController._setup(null, true);
      return {
        close() {
          if (!popup2)
            return;
          popup2.close();
          popup2 = null;
        },
        destroy() {
          this.close();
          window.removeEventListener("focus", onBlur);
          messenger == null ? void 0 : messenger.destroy();
          offDetectClosed();
        },
        open() {
          if (resolvedType === "popup") {
            const left = (window.innerWidth - size2.width) / 2 + window.screenX;
            const top = window.screenY + 100;
            popup2 = window.open(getDialogUrl(host), "_blank", `width=${size2.width},height=${size2.height},left=${left},top=${top}`);
          } else {
            popup2 = window.open(getDialogUrl(host), "_blank");
          }
          if (!popup2)
            throw new Error("Failed to open popup");
          messenger = bridge({
            from: fromWindow(window, {
              targetOrigin: hostUrl.origin
            }),
            to: fromWindow(popup2, {
              targetOrigin: hostUrl.origin
            }),
            waitForReady: true
          });
          themeController == null ? void 0 : themeController._setup(messenger, false);
          messenger.send("__internal", {
            mode: resolvedType === "page" ? "page" : "popup",
            referrer: getReferrer(),
            theme: (themeController == null ? void 0 : themeController.getTheme()) ?? parameters.theme,
            type: "init"
          });
          messenger.on("rpc-response", (response) => handleResponse(store, response));
          window.removeEventListener("focus", onBlur);
          window.addEventListener("focus", onBlur);
        },
        async secure() {
          return {
            frame: true,
            host: true,
            protocol: true
          };
        },
        async syncRequests(requests) {
          const requiresConfirm = requests.some((x) => requiresConfirmation(x.request));
          if (requiresConfirm) {
            if (!popup2 || popup2.closed)
              this.open();
            popup2 == null ? void 0 : popup2.focus();
          }
          messenger == null ? void 0 : messenger.send("rpc-requests", requests);
        }
      };
    },
    supportsHeadless: false
  });
}
function authSession(options = {}) {
  if (!isReactNative())
    return noop2();
  const { requestOptions = { showTitle: true } } = options;
  return from9({
    name: "authSession",
    setup(parameters) {
      var _a2;
      const { host, internal } = parameters;
      const { store } = internal;
      const environment2 = reactNative.environment;
      (_a2 = environment2.maybeCompleteAuthSession) == null ? void 0 : _a2.call(environment2);
      let processing = false;
      let inFlightId = null;
      async function handle(request) {
        var _a3, _b, _c;
        const { request: rpcRequest } = request;
        const reactNativePaths = {
          account_verifyEmail: "account_verifyEmail",
          eth_requestAccounts: "eth_requestAccounts",
          eth_sendTransaction: "eth_sendTransaction",
          eth_signTypedData_v4: "eth_signTypedData_v4",
          personal_sign: "personal_sign",
          wallet_addFunds: "wallet_addFunds",
          wallet_connect: "wallet_connect",
          wallet_getAccountVersion: "wallet_getAccountVersion",
          wallet_getAssets: "wallet_getAssets",
          wallet_getCallsStatus: "wallet_getCallsStatus",
          wallet_getCapabilities: "wallet_getCapabilities",
          wallet_getKeys: "wallet_getKeys",
          wallet_getPermissions: "wallet_getPermissions",
          wallet_grantAdmin: "wallet_grantAdmin",
          wallet_grantPermissions: "wallet_grantPermissions",
          wallet_prepareCalls: "wallet_prepareCalls",
          wallet_prepareUpgradeAccount: "wallet_prepareUpgradeAccount",
          wallet_revokeAdmin: "wallet_revokeAdmin",
          wallet_revokePermissions: "wallet_revokePermissions",
          wallet_sendCalls: "wallet_sendCalls",
          wallet_sendPreparedCalls: "wallet_sendPreparedCalls",
          wallet_switchEthereumChain: "wallet_switchEthereumChain",
          wallet_verifySignature: "wallet_verifySignature"
        };
        const rpcMethod = reactNativePaths[rpcRequest.method];
        if (!rpcMethod)
          throw new UnsupportedMethodError({
            message: `Method not supported in Mode.reactNative(): ${rpcRequest.method}`
          });
        const redirectUri = environment2.makeRedirectUri({
          ...options.redirectUri ? { scheme: options.redirectUri.scheme } : {},
          path: ((_a3 = options.redirectUri) == null ? void 0 : _a3.path) ?? "/",
          preferLocalhost: typeof __DEV__ === "boolean" && __DEV__
        });
        const url2 = new URL(host);
        url2.pathname = `${url2.pathname.replace(/\/$/, "")}/${rpcMethod}`;
        const searchParams = new URLSearchParams({
          id: String(rpcRequest.id),
          jsonrpc: "2.0",
          method: rpcRequest.method,
          redirectUri
        });
        const params = rpcRequest.params ?? [];
        if (params.length > 0)
          searchParams.set("params", stringify(params));
        const decodedParams = (_b = rpcRequest._decoded) == null ? void 0 : _b.params;
        if (decodedParams)
          searchParams.set("_decoded", stringify(decodedParams));
        url2.search = searchParams.toString();
        const result = await environment2.openAuthSessionAsync(url2.toString(), redirectUri, requestOptions);
        const response = (() => {
          if (result.type === "success" && result.url) {
            const resolved = new URL(result.url);
            const status = resolved.searchParams.get("status") ?? AuthSessionStatus.unknown;
            const message = resolved.searchParams.get("message") ?? void 0;
            const payload = resolved.searchParams.get("payload") ?? void 0;
            if (status === AuthSessionStatus.success)
              try {
                return {
                  id: rpcRequest.id,
                  jsonrpc: "2.0",
                  result: payload ? parse(payload) : void 0
                };
              } catch (error47) {
                return {
                  error: {
                    code: -32603,
                    message: error47 instanceof Error ? error47.message : "Failed to parse redirect payload"
                  },
                  id: rpcRequest.id,
                  jsonrpc: "2.0"
                };
              }
            const error46 = status === AuthSessionStatus.cancel ? new UserRejectedRequestError({
              message: message ?? "User rejected request"
            }) : new ProviderRpcError(-32603, message ?? status ?? "Request failed");
            return {
              error: {
                code: error46.code,
                message: error46.message
              },
              id: rpcRequest.id,
              jsonrpc: "2.0"
            };
          }
          if (result.type === "cancel" || result.type === "dismiss")
            return {
              error: {
                code: UserRejectedRequestError.code,
                message: "User rejected request"
              },
              id: rpcRequest.id,
              jsonrpc: "2.0"
            };
          return {
            error: {
              code: -32603,
              message: result.error ?? "Request failed"
            },
            id: rpcRequest.id,
            jsonrpc: "2.0"
          };
        })();
        handleResponse(store, response);
        (_c = environment2.dismissAuthSession) == null ? void 0 : _c.call(environment2);
      }
      return {
        close() {
          var _a3;
          (_a3 = environment2.dismissAuthSession) == null ? void 0 : _a3.call(environment2);
        },
        destroy() {
          var _a3;
          (_a3 = environment2.dismissAuthSession) == null ? void 0 : _a3.call(environment2);
        },
        open() {
        },
        async secure() {
          return {
            frame: false,
            host: true,
            protocol: true
          };
        },
        async syncRequests(requests) {
          var _a3;
          if (processing)
            return;
          const [request] = requests;
          if (!request)
            return;
          if (inFlightId === request.request.id)
            return;
          inFlightId = request.request.id;
          processing = true;
          try {
            await handle(request);
          } catch (error46) {
            handleResponse(store, {
              error: {
                code: -32603,
                message: error46 instanceof Error ? error46.message : "Request failed"
              },
              id: request.request.id,
              jsonrpc: "2.0"
            });
            (_a3 = environment2.dismissAuthSession) == null ? void 0 : _a3.call(environment2);
          } finally {
            inFlightId = null;
            processing = false;
          }
        }
      };
    },
    supportsHeadless: false
  });
}
function noop2() {
  return from9({
    name: "noop",
    setup() {
      return {
        close() {
        },
        destroy() {
        },
        open() {
        },
        async secure() {
          return {
            frame: true,
            host: true,
            protocol: true
          };
        },
        async syncRequests() {
        }
      };
    },
    supportsHeadless: true
  });
}
function experimental_inline(options) {
  const { element } = options;
  if (typeof window === "undefined")
    return noop2();
  return from9({
    name: "inline",
    setup(parameters) {
      const { host, internal, theme, themeController } = parameters;
      const { store } = internal;
      let open = false;
      const hostUrl = new URL(host);
      const root = document.createElement("div");
      root.dataset.porto = "";
      root.style.height = "100%";
      element().appendChild(root);
      const iframe2 = document.createElement("iframe");
      iframe2.setAttribute("allow", `payment; publickey-credentials-get ${hostUrl.origin}; publickey-credentials-create ${hostUrl.origin}`);
      iframe2.setAttribute("aria-label", "Porto Wallet");
      iframe2.setAttribute("tabindex", "0");
      iframe2.setAttribute("sandbox", "allow-forms allow-scripts allow-same-origin allow-popups allow-popups-to-escape-sandbox");
      iframe2.setAttribute("src", getDialogUrl(host));
      iframe2.setAttribute("title", "Porto");
      Object.assign(iframe2.style, {
        border: "0",
        height: "100%",
        width: "100%"
      });
      root.appendChild(iframe2);
      const messenger = bridge({
        from: fromWindow(window, { targetOrigin: hostUrl.origin }),
        to: fromWindow(iframe2.contentWindow, {
          targetOrigin: hostUrl.origin
        }),
        waitForReady: true
      });
      themeController == null ? void 0 : themeController._setup(messenger, true);
      messenger.on("ready", () => {
        messenger.send("__internal", {
          mode: "inline-iframe",
          referrer: getReferrer(),
          theme,
          type: "init"
        });
      });
      messenger.on("rpc-response", (response) => handleResponse(store, response));
      return {
        close() {
        },
        destroy() {
          messenger.destroy();
          root.remove();
        },
        open() {
          if (open)
            return;
          open = true;
          messenger.send("__internal", {
            mode: "iframe",
            referrer: getReferrer(),
            type: "init"
          });
        },
        async secure() {
          return {
            frame: true,
            host: true,
            protocol: true
          };
        },
        async syncRequests(requests) {
          messenger.send("rpc-requests", requests);
        }
      };
    },
    supportsHeadless: true
  });
}
function createThemeController() {
  let lastTheme = null;
  let messenger = null;
  const controller = {
    _setup(messenger_, resetTheme = false) {
      if (resetTheme)
        lastTheme = null;
      messenger = messenger_;
    },
    getTheme() {
      return lastTheme;
    },
    setTheme(theme) {
      lastTheme = theme;
      messenger == null ? void 0 : messenger.send("__internal", {
        theme,
        type: "set-theme"
      }).catch(() => {
      });
    }
  };
  return controller;
}
var defaultSize = { height: 282, width: 360 };
function requiresConfirmation(request, options = {}) {
  var _a2;
  const { methodPolicies, targetOrigin } = options;
  const policy = methodPolicies == null ? void 0 : methodPolicies.find((x) => x.method === request.method);
  if (!policy)
    return true;
  if ((_a2 = policy.modes) == null ? void 0 : _a2.headless) {
    if (typeof policy.modes.headless === "object" && policy.modes.headless.sameOrigin && targetOrigin !== window.location.origin)
      return true;
    return false;
  }
  return true;
}
function getReferrer() {
  const icon = (() => {
    var _a2, _b, _c;
    const dark = (_a2 = document.querySelector('link[rel="icon"][media="(prefers-color-scheme: dark)"]')) == null ? void 0 : _a2.href;
    const light = ((_b = document.querySelector('link[rel="icon"][media="(prefers-color-scheme: light)"]')) == null ? void 0 : _b.href) ?? ((_c = document.querySelector('link[rel="icon"]')) == null ? void 0 : _c.href);
    if (dark && light && dark !== light)
      return { dark, light };
    const isDark = window.matchMedia("(prefers-color-scheme: dark)").matches;
    if (isDark)
      return dark;
    return light;
  })();
  return {
    icon,
    title: document.title
  };
}
function handleBlur(store) {
  store.setState((x) => ({
    ...x,
    requestQueue: x.requestQueue.map((x2) => ({
      account: x2.account,
      error: new UserRejectedRequestError(),
      request: x2.request,
      status: "error"
    }))
  }));
}
function handleResponse(store, response) {
  store.setState((x) => ({
    ...x,
    requestQueue: x.requestQueue.map((queued) => {
      if (queued.request.id !== response.id)
        return queued;
      if (response.error)
        return {
          account: queued.account,
          error: response.error,
          request: queued.request,
          status: "error"
        };
      return {
        account: queued.account,
        request: queued.request,
        result: response.result,
        status: "success"
      };
    })
  }));
}
function getDialogUrl(host) {
  const url2 = new URL(host);
  const parentParams = new URLSearchParams(window.location.search);
  const prefix = "porto.";
  for (const [key, value] of parentParams.entries()) {
    if (key.startsWith(prefix))
      url2.searchParams.set(key.slice(prefix.length), value);
  }
  return url2.toString();
}

// node_modules/@wagmi/connectors/node_modules/zod/mini/index.js
var mini_exports = {};
__export(mini_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodMiniAny: () => ZodMiniAny,
  ZodMiniArray: () => ZodMiniArray,
  ZodMiniBase64: () => ZodMiniBase64,
  ZodMiniBase64URL: () => ZodMiniBase64URL,
  ZodMiniBigInt: () => ZodMiniBigInt,
  ZodMiniBigIntFormat: () => ZodMiniBigIntFormat,
  ZodMiniBoolean: () => ZodMiniBoolean,
  ZodMiniCIDRv4: () => ZodMiniCIDRv4,
  ZodMiniCIDRv6: () => ZodMiniCIDRv6,
  ZodMiniCUID: () => ZodMiniCUID,
  ZodMiniCUID2: () => ZodMiniCUID2,
  ZodMiniCatch: () => ZodMiniCatch,
  ZodMiniCodec: () => ZodMiniCodec,
  ZodMiniCustom: () => ZodMiniCustom,
  ZodMiniCustomStringFormat: () => ZodMiniCustomStringFormat,
  ZodMiniDate: () => ZodMiniDate,
  ZodMiniDefault: () => ZodMiniDefault,
  ZodMiniDiscriminatedUnion: () => ZodMiniDiscriminatedUnion,
  ZodMiniE164: () => ZodMiniE164,
  ZodMiniEmail: () => ZodMiniEmail,
  ZodMiniEmoji: () => ZodMiniEmoji,
  ZodMiniEnum: () => ZodMiniEnum,
  ZodMiniFile: () => ZodMiniFile,
  ZodMiniFunction: () => ZodMiniFunction,
  ZodMiniGUID: () => ZodMiniGUID,
  ZodMiniIPv4: () => ZodMiniIPv4,
  ZodMiniIPv6: () => ZodMiniIPv6,
  ZodMiniISODate: () => ZodMiniISODate,
  ZodMiniISODateTime: () => ZodMiniISODateTime,
  ZodMiniISODuration: () => ZodMiniISODuration,
  ZodMiniISOTime: () => ZodMiniISOTime,
  ZodMiniIntersection: () => ZodMiniIntersection,
  ZodMiniJWT: () => ZodMiniJWT,
  ZodMiniKSUID: () => ZodMiniKSUID,
  ZodMiniLazy: () => ZodMiniLazy,
  ZodMiniLiteral: () => ZodMiniLiteral,
  ZodMiniMAC: () => ZodMiniMAC,
  ZodMiniMap: () => ZodMiniMap,
  ZodMiniNaN: () => ZodMiniNaN,
  ZodMiniNanoID: () => ZodMiniNanoID,
  ZodMiniNever: () => ZodMiniNever,
  ZodMiniNonOptional: () => ZodMiniNonOptional,
  ZodMiniNull: () => ZodMiniNull,
  ZodMiniNullable: () => ZodMiniNullable,
  ZodMiniNumber: () => ZodMiniNumber,
  ZodMiniNumberFormat: () => ZodMiniNumberFormat,
  ZodMiniObject: () => ZodMiniObject,
  ZodMiniOptional: () => ZodMiniOptional,
  ZodMiniPipe: () => ZodMiniPipe,
  ZodMiniPrefault: () => ZodMiniPrefault,
  ZodMiniPromise: () => ZodMiniPromise,
  ZodMiniReadonly: () => ZodMiniReadonly,
  ZodMiniRecord: () => ZodMiniRecord,
  ZodMiniSet: () => ZodMiniSet,
  ZodMiniString: () => ZodMiniString,
  ZodMiniStringFormat: () => ZodMiniStringFormat,
  ZodMiniSuccess: () => ZodMiniSuccess,
  ZodMiniSymbol: () => ZodMiniSymbol,
  ZodMiniTemplateLiteral: () => ZodMiniTemplateLiteral,
  ZodMiniTransform: () => ZodMiniTransform,
  ZodMiniTuple: () => ZodMiniTuple,
  ZodMiniType: () => ZodMiniType,
  ZodMiniULID: () => ZodMiniULID,
  ZodMiniURL: () => ZodMiniURL,
  ZodMiniUUID: () => ZodMiniUUID,
  ZodMiniUndefined: () => ZodMiniUndefined,
  ZodMiniUnion: () => ZodMiniUnion,
  ZodMiniUnknown: () => ZodMiniUnknown,
  ZodMiniVoid: () => ZodMiniVoid,
  ZodMiniXID: () => ZodMiniXID,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  catchall: () => catchall,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone,
  codec: () => codec,
  coerce: () => coerce_exports,
  config: () => config,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date2,
  decode: () => decode,
  decodeAsync: () => decodeAsync,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  encode: () => encode2,
  encodeAsync: () => encodeAsync,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  extend: () => extend2,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  function: () => _function,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => _lazy2,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  mac: () => mac2,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  maximum: () => _lte,
  merge: () => merge2,
  meta: () => meta2,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  minimum: () => _gte,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  omit: () => omit2,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse3,
  parseAsync: () => parseAsync,
  partial: () => partial2,
  partialRecord: () => partialRecord,
  pick: () => pick2,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  required: () => required2,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeExtend: () => safeExtend2,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  set: () => set2,
  size: () => _size,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  util: () => util_exports,
  uuid: () => uuid2,
  uuidv4: () => uuidv42,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  z: () => external_exports
});

// node_modules/@wagmi/connectors/node_modules/zod/v4/mini/external.js
var external_exports = {};
__export(external_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodMiniAny: () => ZodMiniAny,
  ZodMiniArray: () => ZodMiniArray,
  ZodMiniBase64: () => ZodMiniBase64,
  ZodMiniBase64URL: () => ZodMiniBase64URL,
  ZodMiniBigInt: () => ZodMiniBigInt,
  ZodMiniBigIntFormat: () => ZodMiniBigIntFormat,
  ZodMiniBoolean: () => ZodMiniBoolean,
  ZodMiniCIDRv4: () => ZodMiniCIDRv4,
  ZodMiniCIDRv6: () => ZodMiniCIDRv6,
  ZodMiniCUID: () => ZodMiniCUID,
  ZodMiniCUID2: () => ZodMiniCUID2,
  ZodMiniCatch: () => ZodMiniCatch,
  ZodMiniCodec: () => ZodMiniCodec,
  ZodMiniCustom: () => ZodMiniCustom,
  ZodMiniCustomStringFormat: () => ZodMiniCustomStringFormat,
  ZodMiniDate: () => ZodMiniDate,
  ZodMiniDefault: () => ZodMiniDefault,
  ZodMiniDiscriminatedUnion: () => ZodMiniDiscriminatedUnion,
  ZodMiniE164: () => ZodMiniE164,
  ZodMiniEmail: () => ZodMiniEmail,
  ZodMiniEmoji: () => ZodMiniEmoji,
  ZodMiniEnum: () => ZodMiniEnum,
  ZodMiniFile: () => ZodMiniFile,
  ZodMiniFunction: () => ZodMiniFunction,
  ZodMiniGUID: () => ZodMiniGUID,
  ZodMiniIPv4: () => ZodMiniIPv4,
  ZodMiniIPv6: () => ZodMiniIPv6,
  ZodMiniISODate: () => ZodMiniISODate,
  ZodMiniISODateTime: () => ZodMiniISODateTime,
  ZodMiniISODuration: () => ZodMiniISODuration,
  ZodMiniISOTime: () => ZodMiniISOTime,
  ZodMiniIntersection: () => ZodMiniIntersection,
  ZodMiniJWT: () => ZodMiniJWT,
  ZodMiniKSUID: () => ZodMiniKSUID,
  ZodMiniLazy: () => ZodMiniLazy,
  ZodMiniLiteral: () => ZodMiniLiteral,
  ZodMiniMAC: () => ZodMiniMAC,
  ZodMiniMap: () => ZodMiniMap,
  ZodMiniNaN: () => ZodMiniNaN,
  ZodMiniNanoID: () => ZodMiniNanoID,
  ZodMiniNever: () => ZodMiniNever,
  ZodMiniNonOptional: () => ZodMiniNonOptional,
  ZodMiniNull: () => ZodMiniNull,
  ZodMiniNullable: () => ZodMiniNullable,
  ZodMiniNumber: () => ZodMiniNumber,
  ZodMiniNumberFormat: () => ZodMiniNumberFormat,
  ZodMiniObject: () => ZodMiniObject,
  ZodMiniOptional: () => ZodMiniOptional,
  ZodMiniPipe: () => ZodMiniPipe,
  ZodMiniPrefault: () => ZodMiniPrefault,
  ZodMiniPromise: () => ZodMiniPromise,
  ZodMiniReadonly: () => ZodMiniReadonly,
  ZodMiniRecord: () => ZodMiniRecord,
  ZodMiniSet: () => ZodMiniSet,
  ZodMiniString: () => ZodMiniString,
  ZodMiniStringFormat: () => ZodMiniStringFormat,
  ZodMiniSuccess: () => ZodMiniSuccess,
  ZodMiniSymbol: () => ZodMiniSymbol,
  ZodMiniTemplateLiteral: () => ZodMiniTemplateLiteral,
  ZodMiniTransform: () => ZodMiniTransform,
  ZodMiniTuple: () => ZodMiniTuple,
  ZodMiniType: () => ZodMiniType,
  ZodMiniULID: () => ZodMiniULID,
  ZodMiniURL: () => ZodMiniURL,
  ZodMiniUUID: () => ZodMiniUUID,
  ZodMiniUndefined: () => ZodMiniUndefined,
  ZodMiniUnion: () => ZodMiniUnion,
  ZodMiniUnknown: () => ZodMiniUnknown,
  ZodMiniVoid: () => ZodMiniVoid,
  ZodMiniXID: () => ZodMiniXID,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  catchall: () => catchall,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone,
  codec: () => codec,
  coerce: () => coerce_exports,
  config: () => config,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date2,
  decode: () => decode,
  decodeAsync: () => decodeAsync,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  encode: () => encode2,
  encodeAsync: () => encodeAsync,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  extend: () => extend2,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  function: () => _function,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => _lazy2,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  mac: () => mac2,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  maximum: () => _lte,
  merge: () => merge2,
  meta: () => meta2,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  minimum: () => _gte,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  omit: () => omit2,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse3,
  parseAsync: () => parseAsync,
  partial: () => partial2,
  partialRecord: () => partialRecord,
  pick: () => pick2,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  required: () => required2,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeExtend: () => safeExtend2,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  set: () => set2,
  size: () => _size,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  util: () => util_exports,
  uuid: () => uuid2,
  uuidv4: () => uuidv42,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2
});

// node_modules/@wagmi/connectors/node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCodec: () => $ZodCodec,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMAC: () => $ZodMAC,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _check: () => _check,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _decode: () => _decode,
  _decodeAsync: () => _decodeAsync,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _encode: () => _encode,
  _encodeAsync: () => _encodeAsync,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _mac: () => _mac,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeDecode: () => _safeDecode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeEncode: () => _safeEncode,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _slugify: () => _slugify,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _superRefine: () => _superRefine,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  clone: () => clone,
  config: () => config,
  decode: () => decode,
  decodeAsync: () => decodeAsync,
  describe: () => describe,
  encode: () => encode2,
  encodeAsync: () => encodeAsync,
  flattenError: () => flattenError,
  formatError: () => formatError,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  meta: () => meta,
  parse: () => parse3,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version
});

// node_modules/@wagmi/connectors/node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name, initializer2, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: /* @__PURE__ */ new Set()
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer2(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  const Parent = (params == null ? void 0 : params.Parent) ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a2;
    const inst = (params == null ? void 0 : params.Parent) ? new Definition() : this;
    init(inst, def);
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      var _a2, _b;
      if ((params == null ? void 0 : params.Parent) && inst instanceof params.Parent)
        return true;
      return (_b = (_a2 = inst == null ? void 0 : inst._zod) == null ? void 0 : _a2.traits) == null ? void 0 : _b.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var $ZodEncodeError = class extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
};
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  slugify: () => slugify,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error();
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set3 = false;
  return {
    get value() {
      if (!set3) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match == null ? void 0 : match[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING = Symbol("evaluating");
function defineLazy(object2, key, getter) {
  let value = void 0;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc == null ? void 0 : acc[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  var _a2;
  if (typeof navigator !== "undefined" && ((_a2 = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a2.includes("Cloudflare"))) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || (params == null ? void 0 : params.parent))
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if ((params == null ? void 0 : params.message) !== void 0) {
    if ((params == null ? void 0 : params.error) !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")],
  uint64: [BigInt(0), BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error("Object schemas containing refinements cannot be extended. Use `.safeExtend()` instead.");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = {
    ...schema._zod.def,
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    checks: schema._zod.def.checks
  };
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
function partial(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  var _a2;
  if (x.aborted === true)
    return true;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (((_a2 = x.issues[i]) == null ? void 0 : _a2.continue) !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a2;
    (_a2 = iss).path ?? (_a2.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message == null ? void 0 : message.message;
}
function finalizeIssue(iss, ctx, config2) {
  var _a2, _b, _c, _d, _e, _f;
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage((_c = (_b = (_a2 = iss.inst) == null ? void 0 : _a2._zod.def) == null ? void 0 : _b.error) == null ? void 0 : _c.call(_b, iss)) ?? unwrapMessage((_d = ctx == null ? void 0 : ctx.error) == null ? void 0 : _d.call(ctx, iss)) ?? unwrapMessage((_e = config2.customError) == null ? void 0 : _e.call(config2, iss)) ?? unwrapMessage((_f = config2.localeError) == null ? void 0 : _f.call(config2, iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!(ctx == null ? void 0 : ctx.reportInput)) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base643) {
  const binaryString = atob(base643);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url3) {
  const base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base643.length % 4) % 4);
  return base64ToUint8Array(base643 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex4) {
  const cleanHex = hex4.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var Class = class {
  constructor(..._args) {
  }
};

// node_modules/@wagmi/connectors/node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error46, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error46.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error46, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error47) => {
    for (const issue2 of error47.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error46);
  return fieldErrors;
}
function treeifyError(error46, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = (error47, path = []) => {
    var _a2, _b;
    for (const issue2 of error47.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a2 = curr.properties)[el] ?? (_a2[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error46);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error46) {
  var _a2;
  const lines = [];
  const issues = [...error46.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(` ${issue2.message}`);
    if ((_a2 = issue2.path) == null ? void 0 : _a2.length)
      lines.push(`   at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new ((_params == null ? void 0 : _params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params == null ? void 0 : _params.callee);
    throw e;
  }
  return result.value;
};
var parse3 = _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new ((params == null ? void 0 : params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params == null ? void 0 : params.callee);
    throw e;
  }
  return result.value;
};
var parseAsync = _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = _safeParseAsync($ZodRealError);
var _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
var encode2 = _encode($ZodRealError);
var _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
var decode = _decode($ZodRealError);
var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
var encodeAsync = _encodeAsync($ZodRealError);
var _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
var decodeAsync = _decodeAsync($ZodRealError);
var _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
var safeEncode = _safeEncode($ZodRealError);
var _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
var safeDecode = _safeDecode($ZodRealError);
var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
var safeEncodeAsync = _safeEncodeAsync($ZodRealError);
var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};
var safeDecodeAsync = _safeDecodeAsync($ZodRealError);

// node_modules/@wagmi/connectors/node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  mac: () => mac,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version2) => {
  if (!version2)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version2}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = uuid(4);
var uuid6 = uuid(6);
var uuid7 = uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail = unicodeEmail;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var mac = (delimiter) => {
  const escapedDelim = escapeRegex(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
};
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+(?:[0-9]){6,14}[0-9]$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time3 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${(params == null ? void 0 : params.minimum) ?? 0},${(params == null ? void 0 : params.maximum) ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^-?\d+n?$/;
var integer = /^-?\d+$/;
var number = /^-?\d+(?:\.\d+)?/;
var boolean = /^(?:true|false)$/i;
var _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;
var hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex = /^[0-9a-fA-F]{32}$/;
var md5_base64 = fixedBase64(22, "==");
var md5_base64url = fixedBase64url(22);
var sha1_hex = /^[0-9a-fA-F]{40}$/;
var sha1_base64 = fixedBase64(27, "=");
var sha1_base64url = fixedBase64url(27);
var sha256_hex = /^[0-9a-fA-F]{64}$/;
var sha256_base64 = fixedBase64(43, "=");
var sha256_base64url = fixedBase64url(43);
var sha384_hex = /^[0-9a-fA-F]{96}$/;
var sha384_base64 = fixedBase64(64, "");
var sha384_base64url = fixedBase64url(64);
var sha512_hex = /^[0-9a-fA-F]{128}$/;
var sha512_base64 = fixedBase64(86, "==");
var sha512_base64url = fixedBase64url(86);

// node_modules/@wagmi/connectors/node_modules/zod/v4/core/checks.js
var $ZodCheck = $constructor("$ZodCheck", (inst, def) => {
  var _a2;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a2 = inst._zod).onattach ?? (_a2.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a2;
    (_a2 = inst2._zod.bag).multipleOf ?? (_a2.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = $constructor("$ZodCheckNumberFormat", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = (_a2 = def.format) == null ? void 0 : _a2.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckBigIntFormat = $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inst
      });
    }
  };
});
var $ZodCheckMaxSize = $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size2 = input.size;
    if (size2 <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size2 = input.size;
    if (size2 >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size2 = input.size;
    if (size2 === def.size)
      return;
    const tooBig = size2 > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a2;
  $ZodCheck.init(inst, def);
  (_a2 = inst._zod.def).when ?? (_a2.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a2, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a2 = inst._zod).check ?? (_a2.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex = $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/@wagmi/connectors/node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this == null ? void 0 : this.args;
    const content = (this == null ? void 0 : this.content) ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/@wagmi/connectors/node_modules/zod/v4/core/versions.js
var version = {
  major: 4,
  minor: 1,
  patch: 13
};

// node_modules/@wagmi/connectors/node_modules/zod/v4/core/schemas.js
var $ZodType = $constructor("$ZodType", (inst, def) => {
  var _a3;
  var _a2;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a2 = inst._zod).deferred ?? (_a2.deferred = []);
    (_a3 = inst._zod.deferred) == null ? void 0 : _a3.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && (ctx == null ? void 0 : ctx.async) === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  inst["~standard"] = {
    validate: (value) => {
      var _a4;
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: (_a4 = r.error) == null ? void 0 : _a4.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => {
          var _a5;
          return r.success ? { value: r.data } : { issues: (_a5 = r.error) == null ? void 0 : _a5.issues };
        });
      }
    },
    vendor: "zod",
    version: 1
  };
});
var $ZodString = $constructor("$ZodString", (inst, def) => {
  var _a2;
  $ZodType.init(inst, def);
  inst._zod.pattern = [...((_a2 = inst == null ? void 0 : inst._zod.bag) == null ? void 0 : _a2.patterns) ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url2 = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: def.hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url2.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv4`;
});
var $ZodIPv6 = $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv6`;
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodMAC = $constructor("$ZodMAC", (inst, def) => {
  def.pattern ?? (def.pattern = mac(def.delimiter));
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `mac`;
});
var $ZodCIDRv4 = $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error();
      const [address2, prefix] = parts;
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address2}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64";
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64url";
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && (parsedHeader == null ? void 0 : parsedHeader.typ) !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = $constructor("$ZodBigIntFormat", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = /* @__PURE__ */ new Set([void 0]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodArray = $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  var _a2, _b, _c, _d;
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!((_d = (_c = (_b = (_a2 = def.shape) == null ? void 0 : _a2[k]) == null ? void 0 : _b._zod) == null ? void 0 : _c.traits) == null ? void 0 : _d.has("$ZodType"))) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
    } else {
      handlePropertyResult(r, payload, key, input);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject = $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!(desc == null ? void 0 : desc.get)) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject2 = isObject;
  const catchall2 = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input)));
      } else {
        handlePropertyResult(r, payload, key, input);
      }
    }
    if (!catchall2) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT = $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = (shape) => {
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc(key);
      doc.write(`const ${id} = ${parseStr(key)};`);
      doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall2 = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && (ctx == null ? void 0 : ctx.async) === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall2)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    var _a2;
    const opts = def.options;
    const map2 = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values = (_a2 = o._zod.propValues) == null ? void 0 : _a2[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map2.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map2.set(v, o);
      }
    }
    return map2;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input == null ? void 0 : input[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  if (left.issues.length) {
    result.issues.push(...left.issues);
  }
  if (right.issues.length) {
    result.issues.push(...right.issues);
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
    const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index, result.issues));
  }
  final.value[index] = result.value;
}
var $ZodRecord = $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    const values = def.keyType._zod.values;
    if (values) {
      payload.value = {};
      const recordKeys = /* @__PURE__ */ new Set();
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          recordKeys.add(typeof key === "number" ? key.toString() : key);
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!recordKeys.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        if (keyResult.issues.length) {
          payload.issues.push({
            code: "invalid_key",
            origin: "record",
            issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
            input: key,
            path: [key],
            inst
          });
          payload.value[keyResult.value] = keyResult.value;
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  const values = new Set(def.values);
  inst._zod.values = values;
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
var $ZodOptional = $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec = $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult(left2, def, ctx));
      }
      return handleCodecAResult(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult(right2, def, ctx));
      }
      return handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly = $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => {
    var _a2, _b;
    return (_b = (_a2 = def.innerType) == null ? void 0 : _a2._zod) == null ? void 0 : _b.optin;
  });
  defineLazy(inst._zod, "optout", () => {
    var _a2, _b;
    return (_b = (_a2 = def.innerType) == null ? void 0 : _a2._zod) == null ? void 0 : _b.optout;
  });
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "template_literal",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction = $constructor("$ZodFunction", (inst, def) => {
  $ZodType.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse3(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse3(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise = $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => {
    var _a2, _b;
    return (_b = (_a2 = inst._zod.innerType) == null ? void 0 : _a2._zod) == null ? void 0 : _b.pattern;
  });
  defineLazy(inst._zod, "propValues", () => {
    var _a2, _b;
    return (_b = (_a2 = inst._zod.innerType) == null ? void 0 : _a2._zod) == null ? void 0 : _b.propValues;
  });
  defineLazy(inst._zod, "optin", () => {
    var _a2, _b;
    return ((_b = (_a2 = inst._zod.innerType) == null ? void 0 : _a2._zod) == null ? void 0 : _b.optin) ?? void 0;
  });
  defineLazy(inst._zod, "optout", () => {
    var _a2, _b;
    return ((_b = (_a2 = inst._zod.innerType) == null ? void 0 : _a2._zod) == null ? void 0 : _b.optout) ?? void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  bg: () => bg_default,
  ca: () => ca_default,
  cs: () => cs_default,
  da: () => da_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  id: () => id_default,
  is: () => is_default,
  it: () => it_default,
  ja: () => ja_default,
  ka: () => ka_default,
  kh: () => kh_default,
  km: () => km_default,
  ko: () => ko_default,
  lt: () => lt_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  uk: () => uk_default,
  ur: () => ur_default,
  vi: () => vi_default,
  yo: () => yo_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: " ",
    url: "",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ISO",
    date: "  ISO",
    time: "  ISO",
    duration: "  ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: "   IPv4",
    cidrv6: "   IPv6",
    base64: "  base64-encoded",
    base64url: "  base64url-encoded",
    json_string: "   JSON",
    e164: "   E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `  :   ${issue2.expected}    ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  :   ${stringifyPrimitive(issue2.values[0])}`;
        return `  :     : ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `   :    ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `  :    ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `  :   ${issue2.origin}   ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `  :   ${issue2.origin}   ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `  :     "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `  :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `  :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `  :     ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format}  `;
      }
      case "not_multiple_of":
        return `  :      ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, " ")}`;
      case "invalid_key":
        return `    ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `    ${issue2.origin}`;
      default:
        return "  ";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmaldr" },
    file: { unit: "bayt", verb: "olmaldr" },
    array: { unit: "element", verb: "olmaldr" },
    set: { unit: "element", verb: "olmaldr" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Yanl dyr: gzlniln ${issue2.expected}, daxil olan ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl dyr: gzlniln ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl seim: aadaklardan biri olmaldr: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ox byk: gzlniln ${issue2.origin ?? "dyr"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `ox byk: gzlniln ${issue2.origin ?? "dyr"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ox kiik: gzlniln ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `ox kiik: gzlniln ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl mtn: "${_issue.prefix}" il balamaldr`;
        if (_issue.format === "ends_with")
          return `Yanl mtn: "${_issue.suffix}" il bitmlidir`;
        if (_issue.format === "includes")
          return `Yanl mtn: "${_issue.includes}" daxil olmaldr`;
        if (_issue.format === "regex")
          return `Yanl mtn: ${_issue.pattern} ablonuna uyun olmaldr`;
        return `Yanl ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl dd: ${issue2.divisor} il bln biln olmaldr`;
      case "unrecognized_keys":
        return `Tannmayan aar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind yanl aar`;
      case "invalid_union":
        return "Yanl dyr";
      case "invalid_element":
        return `${issue2.origin} daxilind yanl dyr`;
      default:
        return `Yanl dyr`;
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "email ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "   base64",
    base64url: "   base64url",
    json_string: "JSON ",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected},  ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return ` : ,  ${issue2.origin ?? ""}  ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return ` : ,  ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return ` : ,  ${issue2.origin}  ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return ` : ,  ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/bg.js
var parsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error4 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected},  ${parsedType(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :     "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return ` :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :     ${_issue.pattern}`;
        let invalid_adj = "";
        if (_issue.format === "emoji")
          invalid_adj = "";
        if (_issue.format === "datetime")
          invalid_adj = "";
        if (_issue.format === "date")
          invalid_adj = "";
        if (_issue.format === "time")
          invalid_adj = "";
        if (_issue.format === "duration")
          invalid_adj = "";
        return `${invalid_adj} ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :      ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function bg_default() {
  return {
    localeError: error4()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/ca.js
var error5 = () => {
  const Sizable = {
    string: { unit: "carcters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "adrea electrnica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adrea IPv4",
    ipv6: "adrea IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipus invlid: s'esperava ${issue2.expected}, s'ha rebut ${parsedType8(issue2.input)}`;
      // return `Tipus invlid: s'esperava ${issue.expected}, s'ha rebut ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor invlid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci invlida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a mxim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingus ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a mnim" : "ms de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingus ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format invlid: ha de comenar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format invlid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format invlid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format invlid: ha de coincidir amb el patr ${_issue.pattern}`;
        return `Format invlid per a ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlid: ha de ser mltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau invlida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      // Could also be "Tipus d'uni invlid" but "Entrada invlida" is more general
      case "invalid_element":
        return `Element invlid a ${issue2.origin}`;
      default:
        return `Entrada invlida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error5()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/cs.js
var error6 = () => {
  const Sizable = {
    string: { unit: "znak", verb: "mt" },
    file: { unit: "bajt", verb: "mt" },
    array: { unit: "prvk", verb: "mt" },
    set: { unit: "prvk", verb: "mt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "slo";
      }
      case "string": {
        return "etzec";
      }
      case "boolean": {
        return "boolean";
      }
      case "bigint": {
        return "bigint";
      }
      case "function": {
        return "funkce";
      }
      case "symbol": {
        return "symbol";
      }
      case "undefined": {
        return "undefined";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "pole";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "regulrn vraz",
    email: "e-mailov adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a as ve formtu ISO",
    date: "datum ve formtu ISO",
    time: "as ve formtu ISO",
    duration: "doba trvn ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "etzec zakdovan ve formtu base64",
    base64url: "etzec zakdovan ve formtu base64url",
    json_string: "etzec ve formtu JSON",
    e164: "slo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neplatn vstup: oekvno ${issue2.expected}, obdreno ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn vstup: oekvno ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn monost: oekvna jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je pli velk: ${issue2.origin ?? "hodnota"} mus mt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk"}`;
        }
        return `Hodnota je pli velk: ${issue2.origin ?? "hodnota"} mus bt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je pli mal: ${issue2.origin ?? "hodnota"} mus mt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk"}`;
        }
        return `Hodnota je pli mal: ${issue2.origin ?? "hodnota"} mus bt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn etzec: mus zanat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn etzec: mus konit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn etzec: mus obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn etzec: mus odpovdat vzoru ${_issue.pattern}`;
        return `Neplatn formt ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn slo: mus bt nsobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neznm kle: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn kl v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn vstup";
      case "invalid_element":
        return `Neplatn hodnota v ${issue2.origin}`;
      default:
        return `Neplatn vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error6()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/da.js
var error7 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  const TypeNames = {
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "st",
    file: "fil"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
        return "objekt";
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslt",
    date: "ISO-dato",
    time: "ISO-klokkeslt",
    duration: "ISO-varighed",
    ipv4: "IPv4-omrde",
    ipv6: "IPv6-omrde",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldigt input: forventede ${getTypeName(issue2.expected)}, fik ${getTypeName(parsedType8(issue2.input))}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig vrdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af flgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche mnsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal vre deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte ngler" : "Ukendt ngle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig ngle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig vrdi i ${issue2.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
function da_default() {
  return {
    localeError: error7()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/de.js
var error8 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "Zahl";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "Array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ungltige Eingabe: erwartet ${issue2.expected}, erhalten ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ungltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ungltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ungltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ungltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ungltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ungltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ungltig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ungltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ungltiger Schlssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ungltige Eingabe";
      case "invalid_element":
        return `Ungltiger Wert in ${issue2.origin}`;
      default:
        return `Ungltige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error8()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/en.js
var parsedType2 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error9 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Invalid input: expected ${issue2.expected}, received ${parsedType2(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error9()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/eo.js
var parsedType3 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nombro";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "tabelo";
      }
      if (data === null) {
        return "senvalora";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error10 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nevalida enigo: atendiis ${issue2.expected}, riceviis ${parsedType3(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendiis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendiis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendiis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendiis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendiis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendiis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komencii per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas finii per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} losilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida losilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error10()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/es.js
var error11 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  const TypeNames = {
    string: "texto",
    number: "nmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "nmero grande",
    symbol: "smbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funcin",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeracin",
    union: "unin",
    literal: "literal",
    promise: "promesa",
    void: "vaco",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  function getTypeName(type) {
    return TypeNames[type] ?? type;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype) {
          return data.constructor.name;
        }
        return "object";
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entrada",
    email: "direccin de correo electrnico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duracin ISO",
    ipv4: "direccin IPv4",
    ipv6: "direccin IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entrada invlida: se esperaba ${getTypeName(issue2.expected)}, recibido ${getTypeName(parsedType8(issue2.input))}`;
      // return `Entrada invlida: se esperaba ${issue.expected}, recibido ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada invlida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opcin invlida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = getTypeName(issue2.origin);
        if (sizing) {
          return `Demasiado pequeo: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado pequeo: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena invlida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena invlida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena invlida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena invlida: debe coincidir con el patrn ${_issue.pattern}`;
        return `Invlido ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlido: debe ser mltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave invlida en ${getTypeName(issue2.origin)}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido en ${getTypeName(issue2.origin)}`;
      default:
        return `Entrada invlida`;
    }
  };
};
function es_default() {
  return {
    localeError: error11()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/fa.js
var error12 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ",
    date: " ",
    time: " ",
    duration: "  ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected}  ${parsedType8(issue2.input)}  `;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return ` :  ${stringifyPrimitive(issue2.values[0])} `;
        }
        return ` :    ${joinValues(issue2.values, "|")} `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""} `;
        }
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit} `;
        }
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :   "${_issue.prefix}"  `;
        }
        if (_issue.format === "ends_with") {
          return ` :   "${_issue.suffix}"  `;
        }
        if (_issue.format === "includes") {
          return ` :   "${_issue.includes}" `;
        }
        if (_issue.format === "regex") {
          return ` :    ${_issue.pattern}   `;
        }
        return `${Nouns[_issue.format] ?? issue2.format} `;
      }
      case "not_multiple_of":
        return ` :   ${issue2.divisor} `;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function fa_default() {
  return {
    localeError: error12()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/fi.js
var error13 = () => {
  const Sizable = {
    string: { unit: "merkki", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "pivmrn" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "snnllinen lauseke",
    email: "shkpostiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-pivmr",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Virheellinen tyyppi: odotettiin ${issue2.expected}, oli ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen syte: tytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: tytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} tytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon tytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} tytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon tytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen syte: tytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen syte: tytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen syte: tytyy sislt "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen syte: tytyy vastata snnllist lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: tytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen syte`;
    }
  };
};
function fi_default() {
  return {
    localeError: error13()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/fr.js
var error14 = () => {
  const Sizable = {
    string: { unit: "caractres", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "lments", verb: "avoir" },
    set: { unit: "lments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombre";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tableau";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entre",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dure ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chane encode en base64",
    base64url: "chane encode en base64url",
    json_string: "chane JSON",
    e164: "numro E.164",
    jwt: "JWT",
    template_literal: "entre"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entre invalide : ${issue2.expected} attendu, ${parsedType8(issue2.input)} reu`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entre invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "lment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit tre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit tre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chane invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chane invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chane invalide : doit correspondre au modle ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entre invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error14()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/fr-CA.js
var error15 = () => {
  const Sizable = {
    string: { unit: "caractres", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "lments", verb: "avoir" },
    set: { unit: "lments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "entre",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dure ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chane encode en base64",
    base64url: "chane encode en base64url",
    json_string: "chane JSON",
    e164: "numro E.164",
    jwt: "JWT",
    template_literal: "entre"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Entre invalide : attendu ${issue2.expected}, reu ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entre invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Chane invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chane invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chane invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entre invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error15()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/he.js
var error16 = () => {
  const TypeNames = {
    string: { label: "", gender: "f" },
    number: { label: "", gender: "m" },
    boolean: { label: " ", gender: "m" },
    bigint: { label: "BigInt", gender: "m" },
    date: { label: "", gender: "m" },
    array: { label: "", gender: "m" },
    object: { label: "", gender: "m" },
    null: { label: "  (null)", gender: "m" },
    undefined: { label: "   (undefined)", gender: "m" },
    symbol: { label: " (Symbol)", gender: "m" },
    function: { label: "", gender: "f" },
    map: { label: " (Map)", gender: "f" },
    set: { label: " (Set)", gender: "f" },
    file: { label: "", gender: "m" },
    promise: { label: "Promise", gender: "m" },
    NaN: { label: "NaN", gender: "m" },
    unknown: { label: "  ", gender: "m" },
    value: { label: "", gender: "m" }
  };
  const Sizable = {
    string: { unit: "", shortLabel: "", longLabel: "" },
    file: { unit: "", shortLabel: "", longLabel: "" },
    array: { unit: "", shortLabel: "", longLabel: "" },
    set: { unit: "", shortLabel: "", longLabel: "" },
    number: { unit: "", shortLabel: "", longLabel: "" }
    // no unit
  };
  const typeEntry = (t) => t ? TypeNames[t] : void 0;
  const typeLabel = (t) => {
    const e = typeEntry(t);
    if (e)
      return e.label;
    return t ?? TypeNames.unknown.label;
  };
  const withDefinite = (t) => `${typeLabel(t)}`;
  const verbFor = (t) => {
    const e = typeEntry(t);
    const gender = (e == null ? void 0 : e.gender) ?? "m";
    return gender === "f" ? " " : " ";
  };
  const getSizing = (origin) => {
    if (!origin)
      return null;
    return Sizable[origin] ?? null;
  };
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number":
        return Number.isNaN(data) ? "NaN" : "number";
      case "object": {
        if (Array.isArray(data))
          return "array";
        if (data === null)
          return "null";
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
        return "object";
      }
      default:
        return t;
    }
  };
  const Nouns = {
    regex: { label: "", gender: "m" },
    email: { label: " ", gender: "f" },
    url: { label: " ", gender: "f" },
    emoji: { label: "'", gender: "m" },
    uuid: { label: "UUID", gender: "m" },
    nanoid: { label: "nanoid", gender: "m" },
    guid: { label: "GUID", gender: "m" },
    cuid: { label: "cuid", gender: "m" },
    cuid2: { label: "cuid2", gender: "m" },
    ulid: { label: "ULID", gender: "m" },
    xid: { label: "XID", gender: "m" },
    ksuid: { label: "KSUID", gender: "m" },
    datetime: { label: "  ISO", gender: "m" },
    date: { label: " ISO", gender: "m" },
    time: { label: " ISO", gender: "m" },
    duration: { label: "  ISO", gender: "m" },
    ipv4: { label: " IPv4", gender: "f" },
    ipv6: { label: " IPv6", gender: "f" },
    cidrv4: { label: " IPv4", gender: "m" },
    cidrv6: { label: " IPv6", gender: "m" },
    base64: { label: "  64", gender: "f" },
    base64url: { label: "  64  ", gender: "f" },
    json_string: { label: " JSON", gender: "f" },
    e164: { label: " E.164", gender: "m" },
    jwt: { label: "JWT", gender: "m" },
    ends_with: { label: "", gender: "m" },
    includes: { label: "", gender: "m" },
    lowercase: { label: "", gender: "m" },
    starts_with: { label: "", gender: "m" },
    uppercase: { label: "", gender: "m" }
  };
  return (issue2) => {
    var _a2;
    switch (issue2.code) {
      case "invalid_type": {
        const expectedKey = issue2.expected;
        const expected = typeLabel(expectedKey);
        const receivedKey = parsedType8(issue2.input);
        const received = ((_a2 = TypeNames[receivedKey]) == null ? void 0 : _a2.label) ?? receivedKey;
        return `  :   ${expected},  ${received}`;
      }
      case "invalid_value": {
        if (issue2.values.length === 1) {
          return `  :    ${stringifyPrimitive(issue2.values[0])}`;
        }
        const stringified = issue2.values.map((v) => stringifyPrimitive(v));
        if (issue2.values.length === 2) {
          return `  :    ${stringified[0]}  ${stringified[1]}`;
        }
        const lastValue = stringified[stringified.length - 1];
        const restValues = stringified.slice(0, -1).join(", ");
        return `  :    ${restValues}  ${lastValue}`;
      }
      case "too_big": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${(sizing == null ? void 0 : sizing.longLabel) ?? ""} : ${subject}   ${issue2.maximum.toString()} ${(sizing == null ? void 0 : sizing.unit) ?? ""} ${issue2.inclusive ? " " : " "}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `   -${issue2.maximum}` : ` -${issue2.maximum}`;
          return ` : ${subject}   ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "" : "";
          const comparison = issue2.inclusive ? `${issue2.maximum} ${(sizing == null ? void 0 : sizing.unit) ?? ""}  ` : ` -${issue2.maximum} ${(sizing == null ? void 0 : sizing.unit) ?? ""}`;
          return ` : ${subject} ${verb}  ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? "<=" : "<";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing == null ? void 0 : sizing.unit) {
          return `${sizing.longLabel} : ${subject} ${be} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        }
        return `${(sizing == null ? void 0 : sizing.longLabel) ?? ""} : ${subject} ${be} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${(sizing == null ? void 0 : sizing.shortLabel) ?? ""} : ${subject}   ${issue2.minimum.toString()} ${(sizing == null ? void 0 : sizing.unit) ?? ""} ${issue2.inclusive ? " " : ""}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `   -${issue2.minimum}` : ` -${issue2.minimum}`;
          return ` : ${subject}   ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "" : "";
          if (issue2.minimum === 1 && issue2.inclusive) {
            const singularPhrase = issue2.origin === "set" ? "  " : "  ";
            return ` : ${subject} ${verb}  ${singularPhrase}`;
          }
          const comparison = issue2.inclusive ? `${issue2.minimum} ${(sizing == null ? void 0 : sizing.unit) ?? ""}  ` : ` -${issue2.minimum} ${(sizing == null ? void 0 : sizing.unit) ?? ""}`;
          return ` : ${subject} ${verb}  ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? ">=" : ">";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing == null ? void 0 : sizing.unit) {
          return `${sizing.shortLabel} : ${subject} ${be} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `${(sizing == null ? void 0 : sizing.shortLabel) ?? ""} : ${subject} ${be} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `    ${_issue.pattern}`;
        const nounEntry = Nouns[_issue.format];
        const noun = (nounEntry == null ? void 0 : nounEntry.label) ?? _issue.format;
        const gender = (nounEntry == null ? void 0 : nounEntry.gender) ?? "m";
        const adjective = gender === "f" ? "" : "";
        return `${noun}  ${adjective}`;
      }
      case "not_multiple_of":
        return `  :     ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}  ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key": {
        return `   `;
      }
      case "invalid_union":
        return "  ";
      case "invalid_element": {
        const place = withDefinite(issue2.origin ?? "array");
        return `   ${place}`;
      }
      default:
        return `  `;
    }
  };
};
function he_default() {
  return {
    localeError: error16()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/hu.js
var error17 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "szm";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tmb";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "bemenet",
    email: "email cm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO idblyeg",
    date: "ISO dtum",
    time: "ISO id",
    duration: "ISO idintervallum",
    ipv4: "IPv4 cm",
    ipv6: "IPv6 cm",
    cidrv4: "IPv4 tartomny",
    cidrv6: "IPv6 tartomny",
    base64: "base64-kdolt string",
    base64url: "base64url-kdolt string",
    json_string: "JSON string",
    e164: "E.164 szm",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `rvnytelen bemenet: a vrt rtk ${issue2.expected}, a kapott rtk ${parsedType8(issue2.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `rvnytelen bemenet: a vrt rtk ${stringifyPrimitive(issue2.values[0])}`;
        return `rvnytelen opci: valamelyik rtk vrt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tl nagy: ${issue2.origin ?? "rtk"} mrete tl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `Tl nagy: a bemeneti rtk ${issue2.origin ?? "rtk"} tl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tl kicsi: a bemeneti rtk ${issue2.origin} mrete tl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tl kicsi: a bemeneti rtk ${issue2.origin} tl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `rvnytelen string: "${_issue.prefix}" rtkkel kell kezddnie`;
        if (_issue.format === "ends_with")
          return `rvnytelen string: "${_issue.suffix}" rtkkel kell vgzdnie`;
        if (_issue.format === "includes")
          return `rvnytelen string: "${_issue.includes}" rtket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `rvnytelen string: ${_issue.pattern} mintnak kell megfelelnie`;
        return `rvnytelen ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `rvnytelen szm: ${issue2.divisor} tbbszrsnek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `rvnytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "rvnytelen bemenet";
      case "invalid_element":
        return `rvnytelen rtk: ${issue2.origin}`;
      default:
        return `rvnytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error17()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/id.js
var error18 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak valid: diharapkan ${issue2.expected}, diterima ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error18()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/is.js
var parsedType4 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "nmer";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "fylki";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error19 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "a hafa" },
    file: { unit: "bti", verb: "a hafa" },
    array: { unit: "hluti", verb: "a hafa" },
    set: { unit: "hluti", verb: "a hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og tmi",
    date: "ISO dagsetning",
    time: "ISO tmi",
    duration: "ISO tmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 tlugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Rangt gildi:  slst inn ${parsedType4(issue2.input)} ar sem  a vera ${issue2.expected}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Rangt gildi: gert r fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `gilt val: m vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of strt: gert er r fyrir a ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of strt: gert er r fyrir a ${issue2.origin ?? "gildi"} s ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Of lti: gert er r fyrir a ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Of lti: gert er r fyrir a ${issue2.origin} s ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `gildur strengur: verur a byrja  "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `gildur strengur: verur a enda  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `gildur strengur: verur a innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `gildur strengur: verur a fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Rng tala: verur a vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `ekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill  ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi  ${issue2.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
function is_default() {
  return {
    localeError: error19()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/it.js
var error20 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "vettore";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input non valido: atteso ${issue2.expected}, ricevuto ${parsedType8(issue2.input)}`;
      // return `Input non valido: atteso ${issue.expected}, ricevuto ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error20()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/ja.js
var error21 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO",
    date: "ISO",
    time: "ISO",
    duration: "ISO",
    ipv4: "IPv4",
    ipv6: "IPv6",
    cidrv4: "IPv4",
    cidrv6: "IPv6",
    base64: "base64",
    base64url: "base64url",
    json_string: "JSON",
    e164: "E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `: ${issue2.expected}${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `: ${stringifyPrimitive(issue2.values[0])}`;
        return `: ${joinValues(issue2.values, "")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin ?? ""}${issue2.maximum.toString()}${sizing.unit ?? ""}${adj}`;
        return `: ${issue2.origin ?? ""}${issue2.maximum.toString()}${adj}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin}${issue2.minimum.toString()}${sizing.unit}${adj}`;
        return `: ${issue2.origin}${issue2.minimum.toString()}${adj}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `: "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `: "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `: "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `: ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `: ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, "")}`;
      case "invalid_key":
        return `${issue2.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin}`;
      default:
        return ``;
    }
  };
};
function ja_default() {
  return {
    localeError: error21()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/ka.js
var parsedType5 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  const typeMap = {
    string: "",
    boolean: "",
    undefined: "undefined",
    bigint: "bigint",
    symbol: "symbol",
    function: ""
  };
  return typeMap[t] ?? t;
};
var error22 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "",
    email: "- ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "-",
    date: "",
    time: "",
    duration: "",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected},  ${parsedType5(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :  - ${joinValues(issue2.values, "|")}-`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :  ${issue2.origin ?? ""} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return ` :  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :  ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` :  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :   "${_issue.prefix}"-`;
        }
        if (_issue.format === "ends_with")
          return ` :   "${_issue.suffix}"-`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"-`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :   ${issue2.divisor}- `;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `  ${issue2.origin}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${issue2.origin}-`;
      default:
        return ` `;
    }
  };
};
function ka_default() {
  return {
    localeError: error22()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/km.js
var error23 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? " (NaN)" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return " (Array)";
        }
        if (data === null) {
          return " (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: " base64",
    base64url: " base64url",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `  ${issue2.expected}  ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  ${stringifyPrimitive(issue2.values[0])}`;
        return `  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `  ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `  ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `  ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `  ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `  "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `  "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `  ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `  ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` ${issue2.origin}`;
      case "invalid_union":
        return ``;
      case "invalid_element":
        return ` ${issue2.origin}`;
      default:
        return ``;
    }
  };
};
function km_default() {
  return {
    localeError: error23()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/ko.js
var error24 = () => {
  const Sizable = {
    string: { unit: "", verb: "to have" },
    file: { unit: "", verb: "to have" },
    array: { unit: "", verb: "to have" },
    set: { unit: "", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64  ",
    base64url: "base64url  ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :   ${issue2.expected},   ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}  `;
        return ` : ${joinValues(issue2.values, " ")}   `;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "";
        const suffix = adj === "" ? " " : " ";
        const sizing = getSizing(issue2.origin);
        const unit = (sizing == null ? void 0 : sizing.unit) ?? "";
        if (sizing)
          return `${issue2.origin ?? ""}  : ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? ""}  : ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : "";
        const suffix = adj === "" ? " " : " ";
        const sizing = getSizing(issue2.origin);
        const unit = (sizing == null ? void 0 : sizing.unit) ?? "";
        if (sizing) {
          return `${issue2.origin ?? ""}  : ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? ""}  : ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` : "${_issue.prefix}"()  `;
        }
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"()  `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"()  `;
        if (_issue.format === "regex")
          return ` :  ${_issue.pattern}   `;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}  `;
      case "unrecognized_keys":
        return `   : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` : ${issue2.origin}`;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return ` : ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function ko_default() {
  return {
    localeError: error24()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/lt.js
var parsedType6 = (data) => {
  const t = typeof data;
  return parsedTypeFromType(t, data);
};
var parsedTypeFromType = (t, data = void 0) => {
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "skaiius";
    }
    case "bigint": {
      return "sveikasis skaiius";
    }
    case "string": {
      return "eilut";
    }
    case "boolean": {
      return "login reikm";
    }
    case "undefined":
    case "void": {
      return "neapibrta reikm";
    }
    case "function": {
      return "funkcija";
    }
    case "symbol": {
      return "simbolis";
    }
    case "object": {
      if (data === void 0)
        return "neinomas objektas";
      if (data === null)
        return "nulin reikm";
      if (Array.isArray(data))
        return "masyvas";
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
      return "objektas";
    }
    //Zod types below
    case "null": {
      return "nulin reikm";
    }
  }
  return t;
};
var capitalizeFirstCharacter = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber(number5) {
  const abs = Math.abs(number5);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
var error25 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli"
      },
      verb: {
        smaller: {
          inclusive: "turi bti ne ilgesn kaip",
          notInclusive: "turi bti trumpesn kaip"
        },
        bigger: {
          inclusive: "turi bti ne trumpesn kaip",
          notInclusive: "turi bti ilgesn kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait"
      },
      verb: {
        smaller: {
          inclusive: "turi bti ne didesnis kaip",
          notInclusive: "turi bti maesnis kaip"
        },
        bigger: {
          inclusive: "turi bti ne maesnis kaip",
          notInclusive: "turi bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element",
        few: "elementus",
        many: "element"
      },
      verb: {
        smaller: {
          inclusive: "turi turti ne daugiau kaip",
          notInclusive: "turi turti maiau kaip"
        },
        bigger: {
          inclusive: "turi turti ne maiau kaip",
          notInclusive: "turi turti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element",
        few: "elementus",
        many: "element"
      },
      verb: {
        smaller: {
          inclusive: "turi turti ne daugiau kaip",
          notInclusive: "turi turti maiau kaip"
        },
        bigger: {
          inclusive: "turi turti ne maiau kaip",
          notInclusive: "turi turti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const Nouns = {
    regex: "vestis",
    email: "el. pato adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 ukoduota eilut",
    base64url: "base64url ukoduota eilut",
    json_string: "JSON eilut",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "vestis"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Gautas tipas ${parsedType6(issue2.input)}, o tiktasi - ${parsedTypeFromType(issue2.expected)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Privalo bti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo bti vienas i ${joinValues(issue2.values, "|")} pasirinkim`;
      case "too_big": {
        const origin = parsedTypeFromType(issue2.origin);
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
        if (sizing == null ? void 0 : sizing.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        const adj = issue2.inclusive ? "ne didesnis kaip" : "maesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} turi bti ${adj} ${issue2.maximum.toString()} ${sizing == null ? void 0 : sizing.unit}`;
      }
      case "too_small": {
        const origin = parsedTypeFromType(issue2.origin);
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
        if (sizing == null ? void 0 : sizing.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element"}`;
        const adj = issue2.inclusive ? "ne maesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} turi bti ${adj} ${issue2.minimum.toString()} ${sizing == null ? void 0 : sizing.unit}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Eilut privalo prasidti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut privalo traukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skaiius privalo bti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpaint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga vestis";
      case "invalid_element": {
        const origin = parsedTypeFromType(issue2.origin);
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} turi klaiding vest`;
      }
      default:
        return "Klaidinga vestis";
    }
  };
};
function lt_default() {
  return {
    localeError: error25()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/mk.js
var error26 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "  -",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :   ${issue2.expected},  ${parsedType8(issue2.input)}`;
      // return `Invalid input: expected ${issue.expected}, received ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :     "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return ` :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :      ${_issue.pattern}`;
        return `Invalid ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :      ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? " " : " "}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function mk_default() {
  return {
    localeError: error26()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/ms.js
var error27 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nombor";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Input tidak sah: dijangka ${issue2.expected}, diterima ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error27()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/nl.js
var error28 = () => {
  const Sizable = {
    string: { unit: "tekens", verb: "te hebben" },
    file: { unit: "bytes", verb: "te hebben" },
    array: { unit: "elementen", verb: "te hebben" },
    set: { unit: "elementen", verb: "te hebben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "getal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ongeldige invoer: verwacht ${issue2.expected}, ontving ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Te groot: verwacht dat ${issue2.origin ?? "waarde"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"}`;
        return `Te groot: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Te klein: verwacht dat ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Te klein: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error28()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/no.js
var error29 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: " ha" },
    file: { unit: "bytes", verb: " ha" },
    array: { unit: "elementer", verb: " inneholde" },
    set: { unit: "elementer", verb: " inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tall";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "liste";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omrde",
    ipv6: "IPv6-omrde",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ugyldig input: forventet ${issue2.expected}, fikk ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til  ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til  ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til  ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til  ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m matche mnsteret ${_issue.pattern}`;
        return `Ugyldig ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m vre et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nkkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error29()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/ota.js
var error30 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmaldr" },
    file: { unit: "bayt", verb: "olmaldr" },
    array: { unit: "unsur", verb: "olmaldr" },
    set: { unit: "unsur", verb: "olmaldr" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "numara";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "saf";
        }
        if (data === null) {
          return "gayb";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "giren",
    email: "epostagh",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengm",
    date: "ISO tarihi",
    time: "ISO zaman",
    duration: "ISO mddeti",
    ipv4: "IPv4 nin",
    ipv6: "IPv6 nin",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-ifreli metin",
    base64url: "base64url-ifreli metin",
    json_string: "JSON metin",
    e164: "E.164 says",
    jwt: "JWT",
    template_literal: "giren"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Fsit giren: umulan ${issue2.expected}, alnan ${parsedType8(issue2.input)}`;
      // return `Fsit giren: umulan ${issue.expected}, alnan ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Fsit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `Fsit tercih: mteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla byk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalyd.`;
        return `Fazla byk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmalyd.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla kk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmalyd.`;
        }
        return `Fazla kk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmalyd.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Fsit metin: "${_issue.prefix}" ile balamal.`;
        if (_issue.format === "ends_with")
          return `Fsit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `Fsit metin: "${_issue.includes}" ihtiv etmeli.`;
        if (_issue.format === "regex")
          return `Fsit metin: ${_issue.pattern} nakna uymal.`;
        return `Fsit ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Fsit say: ${issue2.divisor} kat olmalyd.`;
      case "unrecognized_keys":
        return `Tannmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} iin tannmayan anahtar var.`;
      case "invalid_union":
        return "Giren tannamad.";
      case "invalid_element":
        return `${issue2.origin} iin tannmayan kymet var.`;
      default:
        return `Kymet tannamad.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error30()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/ps.js
var error31 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "  ",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ",
    date: "",
    time: "",
    duration: "",
    ipv4: " IPv4 ",
    ipv6: " IPv6 ",
    cidrv4: " IPv4 ",
    cidrv6: " IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: " E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected} ,  ${parsedType8(issue2.input)}  `;
      case "invalid_value":
        if (issue2.values.length === 1) {
          return ` :  ${stringifyPrimitive(issue2.values[0])} `;
        }
        return ` :    ${joinValues(issue2.values, "|")}  `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""} `;
        }
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit} `;
        }
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :   "${_issue.prefix}"   `;
        }
        if (_issue.format === "ends_with") {
          return ` :   "${_issue.suffix}"    `;
        }
        if (_issue.format === "includes") {
          return ` :  "${_issue.includes}" `;
        }
        if (_issue.format === "regex") {
          return ` :   ${_issue.pattern}   `;
        }
        return `${Nouns[_issue.format] ?? issue2.format}  `;
      }
      case "not_multiple_of":
        return ` :   ${issue2.divisor}  `;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin} `;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return `   ${issue2.origin} `;
      default:
        return ` `;
    }
  };
};
function ps_default() {
  return {
    localeError: error31()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/pl.js
var error32 = () => {
  const Sizable = {
    string: { unit: "znakw", verb: "mie" },
    file: { unit: "bajtw", verb: "mie" },
    array: { unit: "elementw", verb: "mie" },
    set: { unit: "elementw", verb: "mie" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "liczba";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tablica";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "wyraenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "cig znakw zakodowany w formacie base64",
    base64url: "cig znakw zakodowany w formacie base64url",
    json_string: "cig znakw w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejcie"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Nieprawidowe dane wejciowe: oczekiwano ${issue2.expected}, otrzymano ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawidowe dane wejciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za dua warto: oczekiwano, e ${issue2.origin ?? "warto"} bdzie mie ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementw"}`;
        }
        return `Zbyt du(y/a/e): oczekiwano, e ${issue2.origin ?? "warto"} bdzie wynosi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za maa warto: oczekiwano, e ${issue2.origin ?? "warto"} bdzie mie ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "elementw"}`;
        }
        return `Zbyt ma(y/a/e): oczekiwano, e ${issue2.origin ?? "warto"} bdzie wynosi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawidowy cig znakw: musi zaczyna si od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawidowy cig znakw: musi koczy si na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawidowy cig znakw: musi zawiera "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${_issue.pattern}`;
        return `Nieprawidow(y/a/e) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidowa liczba: musi by wielokrotnoci ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidowy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawidowe dane wejciowe";
      case "invalid_element":
        return `Nieprawidowa warto w ${issue2.origin}`;
      default:
        return `Nieprawidowe dane wejciowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error32()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/pt.js
var error33 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nmero";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "nulo";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "padro",
    email: "endereo de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durao ISO",
    ipv4: "endereo IPv4",
    ipv6: "endereo IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Tipo invlido: esperado ${issue2.expected}, recebido ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada invlida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Opo invlida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto invlido: deve comear com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto invlido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto invlido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto invlido: deve corresponder ao padro ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} invlido`;
      }
      case "not_multiple_of":
        return `Nmero invlido: deve ser mltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave invlida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido em ${issue2.origin}`;
      default:
        return `Campo invlido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error33()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error34 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "email ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "   base64",
    base64url: "   base64url",
    json_string: "JSON ",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected},  ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `  : ,  ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `  : ,  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `  : ,  ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `  : ,  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return `  `;
    }
  };
};
function ru_default() {
  return {
    localeError: error34()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/sl.js
var error35 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "tevilo";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "tabela";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "vnos",
    email: "e-potni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in as",
    date: "ISO datum",
    time: "ISO as",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Neveljaven vnos: priakovano ${issue2.expected}, prejeto ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: priakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna monost: priakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: priakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: priakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: priakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: priakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se zaeti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se konati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno tevilo: mora biti vekratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i kljui" : " klju"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error35()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/sv.js
var error36 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehlla" },
    set: { unit: "objekt", verb: "att innehlla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "antal";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "lista";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "reguljrt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad strng",
    base64url: "base64url-kodad strng",
    json_string: "JSON-strng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Ogiltig inmatning: frvntat ${issue2.expected}, fick ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: frvntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: frvntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fr stor(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `Fr stor(t): frvntat ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fr lite(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Fr lite(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig strng: mste brja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig strng: mste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig strng: mste innehlla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig strng: mste matcha mnstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: mste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "vrdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt vrde i ${issue2.origin ?? "vrdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error36()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/ta.js
var error37 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? " " : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO  ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO  ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: "input"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` :  ${issue2.expected},  ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :  ${joinValues(issue2.values, "|")}  `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :  ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}   `;
        }
        return ` :  ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()}   `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :  ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}   `;
        }
        return ` :  ${issue2.origin} ${adj}${issue2.minimum.toString()}   `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` : "${_issue.prefix}"   `;
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"   `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"   `;
        if (_issue.format === "regex")
          return ` : ${_issue.pattern}   `;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}    `;
      case "unrecognized_keys":
        return `  ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin}   `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `${issue2.origin}   `;
      default:
        return ` `;
    }
  };
};
function ta_default() {
  return {
    localeError: error37()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/th.js
var error38 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? " (NaN)" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return " (Array)";
        }
        if (data === null) {
          return " (null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: " ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IP  IPv4",
    cidrv6: " IP  IPv6",
    base64: " Base64",
    base64url: " Base64  URL",
    json_string: " JSON",
    e164: " (E.164)",
    jwt: " JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `:  ${issue2.expected}  ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `:  ${stringifyPrimitive(issue2.values[0])}`;
        return `:  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `: ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `: ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `: ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `:  "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `:  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `:  "${_issue.includes}" `;
        if (_issue.format === "regex")
          return `:  ${_issue.pattern}`;
        return `: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `:  ${issue2.divisor} `;
      case "unrecognized_keys":
        return `: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` ${issue2.origin}`;
      case "invalid_union":
        return ": ";
      case "invalid_element":
        return ` ${issue2.origin}`;
      default:
        return ``;
    }
  };
};
function th_default() {
  return {
    localeError: error38()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/tr.js
var parsedType7 = (data) => {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "NaN" : "number";
    }
    case "object": {
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
        return data.constructor.name;
      }
    }
  }
  return t;
};
var error39 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal" },
    file: { unit: "bayt", verb: "olmal" },
    array: { unit: "e", verb: "olmal" },
    set: { unit: "e", verb: "olmal" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const Nouns = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO sre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral",
    cidrv6: "IPv6 aral",
    base64: "base64 ile ifrelenmi metin",
    base64url: "base64url ile ifrelenmi metin",
    json_string: "JSON dizesi",
    e164: "E.164 says",
    jwt: "JWT",
    template_literal: "ablon dizesi"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `Geersiz deer: beklenen ${issue2.expected}, alnan ${parsedType7(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Geersiz deer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Geersiz seenek: aadakilerden biri olmal: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ok byk: beklenen ${issue2.origin ?? "deer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "e"}`;
        return `ok byk: beklenen ${issue2.origin ?? "deer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ok kk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `ok kk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Geersiz metin: "${_issue.prefix}" ile balamal`;
        if (_issue.format === "ends_with")
          return `Geersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Geersiz metin: "${_issue.includes}" iermeli`;
        if (_issue.format === "regex")
          return `Geersiz metin: ${_issue.pattern} desenine uymal`;
        return `Geersiz ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Geersiz say: ${issue2.divisor} ile tam blnebilmeli`;
      case "unrecognized_keys":
        return `Tannmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} iinde geersiz anahtar`;
      case "invalid_union":
        return "Geersiz deer";
      case "invalid_element":
        return `${issue2.origin} iinde geersiz deer`;
      default:
        return `Geersiz deer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error39()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/uk.js
var error40 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: " ",
    email: "  ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: "   base64",
    base64url: "   base64url",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: " "
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `  :  ${issue2.expected},  ${parsedType8(issue2.input)}`;
      // return `  :  ${issue.expected},  ${util.getParsedType(issue.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ,  ${issue2.origin ?? ""} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` : ,  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ,  ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` : ,  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return `  `;
    }
  };
};
function uk_default() {
  return {
    localeError: error40()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/ur.js
var error41 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: " ",
    email: "  ",
    url: "  ",
    emoji: "",
    uuid: "   ",
    uuidv4: "     4",
    uuidv6: "     6",
    nanoid: "  ",
    guid: "   ",
    cuid: "   ",
    cuid2: "    2",
    ulid: "   ",
    xid: "  ",
    ksuid: "    ",
    datetime: "    ",
    date: "   ",
    time: "   ",
    duration: "   ",
    ipv4: "   4 ",
    ipv6: "   6 ",
    cidrv4: "   4 ",
    cidrv6: "   6 ",
    base64: " 64   ",
    base64url: " 64      ",
    json_string: "    ",
    e164: " 164 ",
    jwt: "  ",
    template_literal: " "
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `  : ${issue2.expected}   ${parsedType8(issue2.input)}  `;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  : ${stringifyPrimitive(issue2.values[0])}  `;
        return ` : ${joinValues(issue2.values, "|")}     `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}   `;
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}   `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit}   `;
        }
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()}   `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` : "${_issue.prefix}"    `;
        }
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"    `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"   `;
        if (_issue.format === "regex")
          return ` :  ${_issue.pattern}    `;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}    `;
      case "unrecognized_keys":
        return `   ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, " ")}`;
      case "invalid_key":
        return `${issue2.origin}   `;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `${issue2.origin}   `;
      default:
        return `  `;
    }
  };
};
function ur_default() {
  return {
    localeError: error41()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/vi.js
var error42 = () => {
  const Sizable = {
    string: { unit: "k t", verb: "c" },
    file: { unit: "byte", verb: "c" },
    array: { unit: "phn t", verb: "c" },
    set: { unit: "phn t", verb: "c" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "s";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "mng";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "u vo",
    email: "a ch email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngy gi ISO",
    date: "ngy ISO",
    time: "gi ISO",
    duration: "khong thi gian ISO",
    ipv4: "a ch IPv4",
    ipv6: "a ch IPv6",
    cidrv4: "di IPv4",
    cidrv6: "di IPv6",
    base64: "chui m ha base64",
    base64url: "chui m ha base64url",
    json_string: "chui JSON",
    e164: "s E.164",
    jwt: "JWT",
    template_literal: "u vo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `u vo khng hp l: mong i ${issue2.expected}, nhn c ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `u vo khng hp l: mong i ${stringifyPrimitive(issue2.values[0])}`;
        return `Ty chn khng hp l: mong i mt trong cc gi tr ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu ln: mong i ${issue2.origin ?? "gi tr"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "phn t"}`;
        return `Qu ln: mong i ${issue2.origin ?? "gi tr"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu nh: mong i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu nh: mong i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chui khng hp l: phi bt u bng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chui khng hp l: phi kt thc bng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chui khng hp l: phi bao gm "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chui khng hp l: phi khp vi mu ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format} khng hp l`;
      }
      case "not_multiple_of":
        return `S khng hp l: phi l bi s ca ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kha khng c nhn dng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kha khng hp l trong ${issue2.origin}`;
      case "invalid_union":
        return "u vo khng hp l";
      case "invalid_element":
        return `Gi tr khng hp l trong ${issue2.origin}`;
      default:
        return `u vo khng hp l`;
    }
  };
};
function vi_default() {
  return {
    localeError: error42()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/zh-CN.js
var error43 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "(NaN)" : "";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "";
        }
        if (data === null) {
          return "(null)";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO",
    date: "ISO",
    time: "ISO",
    duration: "ISO",
    ipv4: "IPv4",
    ipv6: "IPv6",
    cidrv4: "IPv4",
    cidrv6: "IPv6",
    base64: "base64",
    base64url: "base64url",
    json_string: "JSON",
    e164: "E.164",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` ${issue2.expected} ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` ${stringifyPrimitive(issue2.values[0])}`;
        return ` ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` "${_issue.prefix}" `;
        if (_issue.format === "ends_with")
          return ` "${_issue.suffix}" `;
        if (_issue.format === "includes")
          return ` "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` ${_issue.pattern}`;
        return `${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` ${issue2.divisor} `;
      case "unrecognized_keys":
        return `(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} (key)`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin} (value)`;
      default:
        return ``;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error43()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/zh-TW.js
var error44 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "number";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "array";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64 ",
    base64url: "base64url ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return ` ${issue2.expected} ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` ${stringifyPrimitive(issue2.values[0])}`;
        return ` ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` "${_issue.prefix}" `;
        }
        if (_issue.format === "ends_with")
          return ` "${_issue.suffix}" `;
        if (_issue.format === "includes")
          return ` "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` ${_issue.pattern}`;
        return ` ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` ${issue2.divisor} `;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}${joinValues(issue2.keys, "")}`;
      case "invalid_key":
        return `${issue2.origin} `;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin} `;
      default:
        return ``;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error44()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/locales/yo.js
var error45 = () => {
  const Sizable = {
    string: { unit: "mi", verb: "n" },
    file: { unit: "bytes", verb: "n" },
    array: { unit: "nkan", verb: "n" },
    set: { unit: "nkan", verb: "n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const parsedType8 = (data) => {
    const t = typeof data;
    switch (t) {
      case "number": {
        return Number.isNaN(data) ? "NaN" : "nmb";
      }
      case "object": {
        if (Array.isArray(data)) {
          return "akop";
        }
        if (data === null) {
          return "null";
        }
        if (Object.getPrototypeOf(data) !== Object.prototype && data.constructor) {
          return data.constructor.name;
        }
      }
    }
    return t;
  };
  const Nouns = {
    regex: "r bwl",
    email: "drs ml",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "kk ISO",
    date: "j ISO",
    time: "kk ISO",
    duration: "kk t p ISO",
    ipv4: "drs IPv4",
    ipv6: "drs IPv6",
    cidrv4: "gbgb IPv4",
    cidrv6: "gbgb IPv6",
    base64: "r t a k n base64",
    base64url: "r base64url",
    json_string: "r JSON",
    e164: "nmb E.164",
    jwt: "JWT",
    template_literal: "r bwl"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type":
        return `bwl ae: a n lti fi ${issue2.expected}, m a r ${parsedType8(issue2.input)}`;
      case "invalid_value":
        if (issue2.values.length === 1)
          return `bwl ae: a n lti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `yn ae: yan kan lra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T p j: a n lti j p ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `T p j: a n lti j ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Kr ju: a n lti j p ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `Kr ju: a n lti j ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `r ae: gbd br pl "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `r ae: gbd par pl "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `r ae: gbd n "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `r ae: gbd b pr mu ${_issue.pattern}`;
        return `Ae: ${Nouns[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nmb ae: gbd j y ppn ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Btn m: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Btn ae nn ${issue2.origin}`;
      case "invalid_union":
        return "bwl ae";
      case "invalid_element":
        return `Iye ae nn ${issue2.origin}`;
      default:
        return "bwl ae";
    }
  };
};
function yo_default() {
  return {
    localeError: error45()
  };
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/core/registries.js
var _a;
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");
var $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta4 = _meta[0];
    this._map.set(schema, meta4);
    if (meta4 && typeof meta4 === "object" && "id" in meta4) {
      if (this._idmap.has(meta4.id)) {
        throw new Error(`ID ${meta4.id} already exists in the registry`);
      }
      this._idmap.set(meta4.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta4 = this._map.get(schema);
    if (meta4 && typeof meta4 === "object" && "id" in meta4) {
      this._idmap.delete(meta4.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
(_a = globalThis).__zod_globalRegistry ?? (_a.__zod_globalRegistry = registry());
var globalRegistry = globalThis.__zod_globalRegistry;

// node_modules/@wagmi/connectors/node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size2, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size: size2
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _slugify() {
  return _overwrite((input) => slugify(input));
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _superRefine(fn) {
  const ch = _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
function describe(description) {
  const ch = new $ZodCheck({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
function meta(metadata) {
  const ch = new $ZodCheck({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    },
    reverseTransform: (input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    },
    error: params.error
  });
  return codec2;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/core/to-json-schema.js
var JSONSchemaGenerator = class {
  constructor(params) {
    this.counter = 0;
    this.metadataRegistry = (params == null ? void 0 : params.metadata) ?? globalRegistry;
    this.target = (params == null ? void 0 : params.target) ?? "draft-2020-12";
    this.unrepresentable = (params == null ? void 0 : params.unrepresentable) ?? "throw";
    this.override = (params == null ? void 0 : params.override) ?? (() => {
    });
    this.io = (params == null ? void 0 : params.io) ?? "output";
    this.seen = /* @__PURE__ */ new Map();
  }
  process(schema, _params = { path: [], schemaPath: [] }) {
    var _a3, _b, _c;
    var _a2;
    const def = schema._zod.def;
    const formatMap = {
      guid: "uuid",
      url: "uri",
      datetime: "date-time",
      json_string: "json-string",
      regex: ""
      // do not set
    };
    const seen = this.seen.get(schema);
    if (seen) {
      seen.count++;
      const isCycle = _params.schemaPath.includes(schema);
      if (isCycle) {
        seen.cycle = _params.path;
      }
      return seen.schema;
    }
    const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
    this.seen.set(schema, result);
    const overrideSchema = (_b = (_a3 = schema._zod).toJSONSchema) == null ? void 0 : _b.call(_a3);
    if (overrideSchema) {
      result.schema = overrideSchema;
    } else {
      const params = {
        ..._params,
        schemaPath: [..._params.schemaPath, schema],
        path: _params.path
      };
      const parent = schema._zod.parent;
      if (parent) {
        result.ref = parent;
        this.process(parent, params);
        this.seen.get(parent).isParent = true;
      } else {
        const _json = result.schema;
        switch (def.type) {
          case "string": {
            const json2 = _json;
            json2.type = "string";
            const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minLength = minimum;
            if (typeof maximum === "number")
              json2.maxLength = maximum;
            if (format) {
              json2.format = formatMap[format] ?? format;
              if (json2.format === "")
                delete json2.format;
            }
            if (contentEncoding)
              json2.contentEncoding = contentEncoding;
            if (patterns && patterns.size > 0) {
              const regexes = [...patterns];
              if (regexes.length === 1)
                json2.pattern = regexes[0].source;
              else if (regexes.length > 1) {
                result.schema.allOf = [
                  ...regexes.map((regex) => ({
                    ...this.target === "draft-7" || this.target === "draft-4" || this.target === "openapi-3.0" ? { type: "string" } : {},
                    pattern: regex.source
                  }))
                ];
              }
            }
            break;
          }
          case "number": {
            const json2 = _json;
            const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
            if (typeof format === "string" && format.includes("int"))
              json2.type = "integer";
            else
              json2.type = "number";
            if (typeof exclusiveMinimum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.minimum = exclusiveMinimum;
                json2.exclusiveMinimum = true;
              } else {
                json2.exclusiveMinimum = exclusiveMinimum;
              }
            }
            if (typeof minimum === "number") {
              json2.minimum = minimum;
              if (typeof exclusiveMinimum === "number" && this.target !== "draft-4") {
                if (exclusiveMinimum >= minimum)
                  delete json2.minimum;
                else
                  delete json2.exclusiveMinimum;
              }
            }
            if (typeof exclusiveMaximum === "number") {
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.maximum = exclusiveMaximum;
                json2.exclusiveMaximum = true;
              } else {
                json2.exclusiveMaximum = exclusiveMaximum;
              }
            }
            if (typeof maximum === "number") {
              json2.maximum = maximum;
              if (typeof exclusiveMaximum === "number" && this.target !== "draft-4") {
                if (exclusiveMaximum <= maximum)
                  delete json2.maximum;
                else
                  delete json2.exclusiveMaximum;
              }
            }
            if (typeof multipleOf === "number")
              json2.multipleOf = multipleOf;
            break;
          }
          case "boolean": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "bigint": {
            if (this.unrepresentable === "throw") {
              throw new Error("BigInt cannot be represented in JSON Schema");
            }
            break;
          }
          case "symbol": {
            if (this.unrepresentable === "throw") {
              throw new Error("Symbols cannot be represented in JSON Schema");
            }
            break;
          }
          case "null": {
            if (this.target === "openapi-3.0") {
              _json.type = "string";
              _json.nullable = true;
              _json.enum = [null];
            } else
              _json.type = "null";
            break;
          }
          case "any": {
            break;
          }
          case "unknown": {
            break;
          }
          case "undefined": {
            if (this.unrepresentable === "throw") {
              throw new Error("Undefined cannot be represented in JSON Schema");
            }
            break;
          }
          case "void": {
            if (this.unrepresentable === "throw") {
              throw new Error("Void cannot be represented in JSON Schema");
            }
            break;
          }
          case "never": {
            _json.not = {};
            break;
          }
          case "date": {
            if (this.unrepresentable === "throw") {
              throw new Error("Date cannot be represented in JSON Schema");
            }
            break;
          }
          case "array": {
            const json2 = _json;
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minItems = minimum;
            if (typeof maximum === "number")
              json2.maxItems = maximum;
            json2.type = "array";
            json2.items = this.process(def.element, { ...params, path: [...params.path, "items"] });
            break;
          }
          case "object": {
            const json2 = _json;
            json2.type = "object";
            json2.properties = {};
            const shape = def.shape;
            for (const key in shape) {
              json2.properties[key] = this.process(shape[key], {
                ...params,
                path: [...params.path, "properties", key]
              });
            }
            const allKeys = new Set(Object.keys(shape));
            const requiredKeys = new Set([...allKeys].filter((key) => {
              const v = def.shape[key]._zod;
              if (this.io === "input") {
                return v.optin === void 0;
              } else {
                return v.optout === void 0;
              }
            }));
            if (requiredKeys.size > 0) {
              json2.required = Array.from(requiredKeys);
            }
            if (((_c = def.catchall) == null ? void 0 : _c._zod.def.type) === "never") {
              json2.additionalProperties = false;
            } else if (!def.catchall) {
              if (this.io === "output")
                json2.additionalProperties = false;
            } else if (def.catchall) {
              json2.additionalProperties = this.process(def.catchall, {
                ...params,
                path: [...params.path, "additionalProperties"]
              });
            }
            break;
          }
          case "union": {
            const json2 = _json;
            const isDiscriminated = def.discriminator !== void 0;
            const options = def.options.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, isDiscriminated ? "oneOf" : "anyOf", i]
            }));
            if (isDiscriminated) {
              json2.oneOf = options;
            } else {
              json2.anyOf = options;
            }
            break;
          }
          case "intersection": {
            const json2 = _json;
            const a = this.process(def.left, {
              ...params,
              path: [...params.path, "allOf", 0]
            });
            const b = this.process(def.right, {
              ...params,
              path: [...params.path, "allOf", 1]
            });
            const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
            const allOf = [
              ...isSimpleIntersection(a) ? a.allOf : [a],
              ...isSimpleIntersection(b) ? b.allOf : [b]
            ];
            json2.allOf = allOf;
            break;
          }
          case "tuple": {
            const json2 = _json;
            json2.type = "array";
            const prefixPath = this.target === "draft-2020-12" ? "prefixItems" : "items";
            const restPath = this.target === "draft-2020-12" ? "items" : this.target === "openapi-3.0" ? "items" : "additionalItems";
            const prefixItems = def.items.map((x, i) => this.process(x, {
              ...params,
              path: [...params.path, prefixPath, i]
            }));
            const rest = def.rest ? this.process(def.rest, {
              ...params,
              path: [...params.path, restPath, ...this.target === "openapi-3.0" ? [def.items.length] : []]
            }) : null;
            if (this.target === "draft-2020-12") {
              json2.prefixItems = prefixItems;
              if (rest) {
                json2.items = rest;
              }
            } else if (this.target === "openapi-3.0") {
              json2.items = {
                anyOf: prefixItems
              };
              if (rest) {
                json2.items.anyOf.push(rest);
              }
              json2.minItems = prefixItems.length;
              if (!rest) {
                json2.maxItems = prefixItems.length;
              }
            } else {
              json2.items = prefixItems;
              if (rest) {
                json2.additionalItems = rest;
              }
            }
            const { minimum, maximum } = schema._zod.bag;
            if (typeof minimum === "number")
              json2.minItems = minimum;
            if (typeof maximum === "number")
              json2.maxItems = maximum;
            break;
          }
          case "record": {
            const json2 = _json;
            json2.type = "object";
            if (this.target === "draft-7" || this.target === "draft-2020-12") {
              json2.propertyNames = this.process(def.keyType, {
                ...params,
                path: [...params.path, "propertyNames"]
              });
            }
            json2.additionalProperties = this.process(def.valueType, {
              ...params,
              path: [...params.path, "additionalProperties"]
            });
            break;
          }
          case "map": {
            if (this.unrepresentable === "throw") {
              throw new Error("Map cannot be represented in JSON Schema");
            }
            break;
          }
          case "set": {
            if (this.unrepresentable === "throw") {
              throw new Error("Set cannot be represented in JSON Schema");
            }
            break;
          }
          case "enum": {
            const json2 = _json;
            const values = getEnumValues(def.entries);
            if (values.every((v) => typeof v === "number"))
              json2.type = "number";
            if (values.every((v) => typeof v === "string"))
              json2.type = "string";
            json2.enum = values;
            break;
          }
          case "literal": {
            const json2 = _json;
            const vals = [];
            for (const val of def.values) {
              if (val === void 0) {
                if (this.unrepresentable === "throw") {
                  throw new Error("Literal `undefined` cannot be represented in JSON Schema");
                } else {
                }
              } else if (typeof val === "bigint") {
                if (this.unrepresentable === "throw") {
                  throw new Error("BigInt literals cannot be represented in JSON Schema");
                } else {
                  vals.push(Number(val));
                }
              } else {
                vals.push(val);
              }
            }
            if (vals.length === 0) {
            } else if (vals.length === 1) {
              const val = vals[0];
              json2.type = val === null ? "null" : typeof val;
              if (this.target === "draft-4" || this.target === "openapi-3.0") {
                json2.enum = [val];
              } else {
                json2.const = val;
              }
            } else {
              if (vals.every((v) => typeof v === "number"))
                json2.type = "number";
              if (vals.every((v) => typeof v === "string"))
                json2.type = "string";
              if (vals.every((v) => typeof v === "boolean"))
                json2.type = "string";
              if (vals.every((v) => v === null))
                json2.type = "null";
              json2.enum = vals;
            }
            break;
          }
          case "file": {
            const json2 = _json;
            const file2 = {
              type: "string",
              format: "binary",
              contentEncoding: "binary"
            };
            const { minimum, maximum, mime } = schema._zod.bag;
            if (minimum !== void 0)
              file2.minLength = minimum;
            if (maximum !== void 0)
              file2.maxLength = maximum;
            if (mime) {
              if (mime.length === 1) {
                file2.contentMediaType = mime[0];
                Object.assign(json2, file2);
              } else {
                json2.anyOf = mime.map((m) => {
                  const mFile = { ...file2, contentMediaType: m };
                  return mFile;
                });
              }
            } else {
              Object.assign(json2, file2);
            }
            break;
          }
          case "transform": {
            if (this.unrepresentable === "throw") {
              throw new Error("Transforms cannot be represented in JSON Schema");
            }
            break;
          }
          case "nullable": {
            const inner = this.process(def.innerType, params);
            if (this.target === "openapi-3.0") {
              result.ref = def.innerType;
              _json.nullable = true;
            } else {
              _json.anyOf = [inner, { type: "null" }];
            }
            break;
          }
          case "nonoptional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "success": {
            const json2 = _json;
            json2.type = "boolean";
            break;
          }
          case "default": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.default = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "prefault": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            if (this.io === "input")
              _json._prefault = JSON.parse(JSON.stringify(def.defaultValue));
            break;
          }
          case "catch": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            let catchValue;
            try {
              catchValue = def.catchValue(void 0);
            } catch {
              throw new Error("Dynamic catch values are not supported in JSON Schema");
            }
            _json.default = catchValue;
            break;
          }
          case "nan": {
            if (this.unrepresentable === "throw") {
              throw new Error("NaN cannot be represented in JSON Schema");
            }
            break;
          }
          case "template_literal": {
            const json2 = _json;
            const pattern = schema._zod.pattern;
            if (!pattern)
              throw new Error("Pattern not found in template literal");
            json2.type = "string";
            json2.pattern = pattern.source;
            break;
          }
          case "pipe": {
            const innerType = this.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "readonly": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            _json.readOnly = true;
            break;
          }
          // passthrough types
          case "promise": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "optional": {
            this.process(def.innerType, params);
            result.ref = def.innerType;
            break;
          }
          case "lazy": {
            const innerType = schema._zod.innerType;
            this.process(innerType, params);
            result.ref = innerType;
            break;
          }
          case "custom": {
            if (this.unrepresentable === "throw") {
              throw new Error("Custom types cannot be represented in JSON Schema");
            }
            break;
          }
          case "function": {
            if (this.unrepresentable === "throw") {
              throw new Error("Function types cannot be represented in JSON Schema");
            }
            break;
          }
          default: {
            def;
          }
        }
      }
    }
    const meta4 = this.metadataRegistry.get(schema);
    if (meta4)
      Object.assign(result.schema, meta4);
    if (this.io === "input" && isTransforming(schema)) {
      delete result.schema.examples;
      delete result.schema.default;
    }
    if (this.io === "input" && result.schema._prefault)
      (_a2 = result.schema).default ?? (_a2.default = result.schema._prefault);
    delete result.schema._prefault;
    const _result = this.seen.get(schema);
    return _result.schema;
  }
  emit(schema, _params) {
    var _a2, _b, _c, _d, _e, _f;
    const params = {
      cycles: (_params == null ? void 0 : _params.cycles) ?? "ref",
      reused: (_params == null ? void 0 : _params.reused) ?? "inline",
      // unrepresentable: _params?.unrepresentable ?? "throw",
      // uri: _params?.uri ?? ((id) => `${id}`),
      external: (_params == null ? void 0 : _params.external) ?? void 0
    };
    const root = this.seen.get(schema);
    if (!root)
      throw new Error("Unprocessed schema. This is a bug in Zod.");
    const makeURI = (entry) => {
      var _a3;
      const defsSegment = this.target === "draft-2020-12" ? "$defs" : "definitions";
      if (params.external) {
        const externalId = (_a3 = params.external.registry.get(entry[0])) == null ? void 0 : _a3.id;
        const uriGenerator = params.external.uri ?? ((id2) => id2);
        if (externalId) {
          return { ref: uriGenerator(externalId) };
        }
        const id = entry[1].defId ?? entry[1].schema.id ?? `schema${this.counter++}`;
        entry[1].defId = id;
        return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
      }
      if (entry[1] === root) {
        return { ref: "#" };
      }
      const uriPrefix = `#`;
      const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
      const defId = entry[1].schema.id ?? `__schema${this.counter++}`;
      return { defId, ref: defUriPrefix + defId };
    };
    const extractToDef = (entry) => {
      if (entry[1].schema.$ref) {
        return;
      }
      const seen = entry[1];
      const { ref, defId } = makeURI(entry);
      seen.def = { ...seen.schema };
      if (defId)
        seen.defId = defId;
      const schema2 = seen.schema;
      for (const key in schema2) {
        delete schema2[key];
      }
      schema2.$ref = ref;
    };
    if (params.cycles === "throw") {
      for (const entry of this.seen.entries()) {
        const seen = entry[1];
        if (seen.cycle) {
          throw new Error(`Cycle detected: #/${(_a2 = seen.cycle) == null ? void 0 : _a2.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
        }
      }
    }
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (schema === entry[0]) {
        extractToDef(entry);
        continue;
      }
      if (params.external) {
        const ext = (_b = params.external.registry.get(entry[0])) == null ? void 0 : _b.id;
        if (schema !== entry[0] && ext) {
          extractToDef(entry);
          continue;
        }
      }
      const id = (_c = this.metadataRegistry.get(entry[0])) == null ? void 0 : _c.id;
      if (id) {
        extractToDef(entry);
        continue;
      }
      if (seen.cycle) {
        extractToDef(entry);
        continue;
      }
      if (seen.count > 1) {
        if (params.reused === "ref") {
          extractToDef(entry);
          continue;
        }
      }
    }
    const flattenRef = (zodSchema, params2) => {
      const seen = this.seen.get(zodSchema);
      const schema2 = seen.def ?? seen.schema;
      const _cached = { ...schema2 };
      if (seen.ref === null) {
        return;
      }
      const ref = seen.ref;
      seen.ref = null;
      if (ref) {
        flattenRef(ref, params2);
        const refSchema = this.seen.get(ref).schema;
        if (refSchema.$ref && (params2.target === "draft-7" || params2.target === "draft-4" || params2.target === "openapi-3.0")) {
          schema2.allOf = schema2.allOf ?? [];
          schema2.allOf.push(refSchema);
        } else {
          Object.assign(schema2, refSchema);
          Object.assign(schema2, _cached);
        }
      }
      if (!seen.isParent)
        this.override({
          zodSchema,
          jsonSchema: schema2,
          path: seen.path ?? []
        });
    };
    for (const entry of [...this.seen.entries()].reverse()) {
      flattenRef(entry[0], { target: this.target });
    }
    const result = {};
    if (this.target === "draft-2020-12") {
      result.$schema = "https://json-schema.org/draft/2020-12/schema";
    } else if (this.target === "draft-7") {
      result.$schema = "http://json-schema.org/draft-07/schema#";
    } else if (this.target === "draft-4") {
      result.$schema = "http://json-schema.org/draft-04/schema#";
    } else if (this.target === "openapi-3.0") {
    } else {
      console.warn(`Invalid target: ${this.target}`);
    }
    if ((_d = params.external) == null ? void 0 : _d.uri) {
      const id = (_e = params.external.registry.get(schema)) == null ? void 0 : _e.id;
      if (!id)
        throw new Error("Schema is missing an `id` property");
      result.$id = params.external.uri(id);
    }
    Object.assign(result, root.def);
    const defs = ((_f = params.external) == null ? void 0 : _f.defs) ?? {};
    for (const entry of this.seen.entries()) {
      const seen = entry[1];
      if (seen.def && seen.defId) {
        defs[seen.defId] = seen.def;
      }
    }
    if (params.external) {
    } else {
      if (Object.keys(defs).length > 0) {
        if (this.target === "draft-2020-12") {
          result.$defs = defs;
        } else {
          result.definitions = defs;
        }
      }
    }
    try {
      return JSON.parse(JSON.stringify(result));
    } catch (_err) {
      throw new Error("Error converting schema to JSON.");
    }
  }
};
function toJSONSchema(input, _params) {
  if (input instanceof $ZodRegistry) {
    const gen2 = new JSONSchemaGenerator(_params);
    const defs = {};
    for (const entry of input._idmap.entries()) {
      const [_, schema] = entry;
      gen2.process(schema);
    }
    const schemas = {};
    const external = {
      registry: input,
      uri: _params == null ? void 0 : _params.uri,
      defs
    };
    for (const entry of input._idmap.entries()) {
      const [key, schema] = entry;
      schemas[key] = gen2.emit(schema, {
        ..._params,
        external
      });
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = gen2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const gen = new JSONSchemaGenerator(_params);
  gen.process(input);
  return gen.emit(input, _params);
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};

// node_modules/@wagmi/connectors/node_modules/zod/v4/mini/schemas.js
var ZodMiniType = $constructor("ZodMiniType", (inst, def) => {
  if (!inst._zod)
    throw new Error("Uninitialized schema in ZodMiniType.");
  $ZodType.init(inst, def);
  inst.def = def;
  inst.type = def.type;
  inst.parse = (data, params) => parse3(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);
  inst.check = (...checks) => {
    return inst.clone(
      {
        ...def,
        checks: [
          ...def.checks ?? [],
          ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
        ]
      }
      // { parent: true }
    );
  };
  inst.clone = (_def, params) => clone(inst, _def, params);
  inst.brand = () => inst;
  inst.register = (reg, meta4) => {
    reg.add(inst, meta4);
    return inst;
  };
});
var ZodMiniString = $constructor("ZodMiniString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodMiniType.init(inst, def);
});
function string2(params) {
  return _string(ZodMiniString, params);
}
var ZodMiniStringFormat = $constructor("ZodMiniStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  ZodMiniString.init(inst, def);
});
var ZodMiniEmail = $constructor("ZodMiniEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodMiniEmail, params);
}
var ZodMiniGUID = $constructor("ZodMiniGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodMiniGUID, params);
}
var ZodMiniUUID = $constructor("ZodMiniUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodMiniUUID, params);
}
function uuidv42(params) {
  return _uuidv4(ZodMiniUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodMiniUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodMiniUUID, params);
}
var ZodMiniURL = $constructor("ZodMiniURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodMiniURL, params);
}
function httpUrl(params) {
  return _url(ZodMiniURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMiniEmoji = $constructor("ZodMiniEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodMiniEmoji, params);
}
var ZodMiniNanoID = $constructor("ZodMiniNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodMiniNanoID, params);
}
var ZodMiniCUID = $constructor("ZodMiniCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodMiniCUID, params);
}
var ZodMiniCUID2 = $constructor("ZodMiniCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodMiniCUID2, params);
}
var ZodMiniULID = $constructor("ZodMiniULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodMiniULID, params);
}
var ZodMiniXID = $constructor("ZodMiniXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodMiniXID, params);
}
var ZodMiniKSUID = $constructor("ZodMiniKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodMiniKSUID, params);
}
var ZodMiniIPv4 = $constructor("ZodMiniIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodMiniIPv4, params);
}
var ZodMiniIPv6 = $constructor("ZodMiniIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodMiniIPv6, params);
}
var ZodMiniCIDRv4 = $constructor("ZodMiniCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodMiniCIDRv4, params);
}
var ZodMiniCIDRv6 = $constructor("ZodMiniCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodMiniCIDRv6, params);
}
var ZodMiniMAC = $constructor("ZodMiniMAC", (inst, def) => {
  $ZodMAC.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function mac2(params) {
  return _mac(ZodMiniMAC, params);
}
var ZodMiniBase64 = $constructor("ZodMiniBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodMiniBase64, params);
}
var ZodMiniBase64URL = $constructor("ZodMiniBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodMiniBase64URL, params);
}
var ZodMiniE164 = $constructor("ZodMiniE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodMiniE164, params);
}
var ZodMiniJWT = $constructor("ZodMiniJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodMiniJWT, params);
}
var ZodMiniCustomStringFormat = $constructor("ZodMiniCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodMiniCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodMiniCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodMiniCustomStringFormat, "hex", regexes_exports.hex, _params);
}
function hash(alg, params) {
  const enc = (params == null ? void 0 : params.enc) ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = regexes_exports[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodMiniCustomStringFormat, format, regex, params);
}
var ZodMiniNumber = $constructor("ZodMiniNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodMiniType.init(inst, def);
});
function number2(params) {
  return _number(ZodMiniNumber, params);
}
var ZodMiniNumberFormat = $constructor("ZodMiniNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodMiniNumber.init(inst, def);
});
function int(params) {
  return _int(ZodMiniNumberFormat, params);
}
function float32(params) {
  return _float32(ZodMiniNumberFormat, params);
}
function float64(params) {
  return _float64(ZodMiniNumberFormat, params);
}
function int32(params) {
  return _int32(ZodMiniNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodMiniNumberFormat, params);
}
var ZodMiniBoolean = $constructor("ZodMiniBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodMiniType.init(inst, def);
});
function boolean2(params) {
  return _boolean(ZodMiniBoolean, params);
}
var ZodMiniBigInt = $constructor("ZodMiniBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodMiniType.init(inst, def);
});
function bigint2(params) {
  return _bigint(ZodMiniBigInt, params);
}
var ZodMiniBigIntFormat = $constructor("ZodMiniBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodMiniBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodMiniBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodMiniBigIntFormat, params);
}
var ZodMiniSymbol = $constructor("ZodMiniSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodMiniType.init(inst, def);
});
function symbol(params) {
  return _symbol(ZodMiniSymbol, params);
}
var ZodMiniUndefined = $constructor("ZodMiniUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodMiniType.init(inst, def);
});
function _undefined3(params) {
  return _undefined2(ZodMiniUndefined, params);
}
var ZodMiniNull = $constructor("ZodMiniNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodMiniType.init(inst, def);
});
function _null3(params) {
  return _null2(ZodMiniNull, params);
}
var ZodMiniAny = $constructor("ZodMiniAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodMiniType.init(inst, def);
});
function any() {
  return _any(ZodMiniAny);
}
var ZodMiniUnknown = $constructor("ZodMiniUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodMiniType.init(inst, def);
});
function unknown() {
  return _unknown(ZodMiniUnknown);
}
var ZodMiniNever = $constructor("ZodMiniNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodMiniType.init(inst, def);
});
function never(params) {
  return _never(ZodMiniNever, params);
}
var ZodMiniVoid = $constructor("ZodMiniVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodMiniType.init(inst, def);
});
function _void2(params) {
  return _void(ZodMiniVoid, params);
}
var ZodMiniDate = $constructor("ZodMiniDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodMiniType.init(inst, def);
});
function date2(params) {
  return _date(ZodMiniDate, params);
}
var ZodMiniArray = $constructor("ZodMiniArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodMiniType.init(inst, def);
});
function array(element, params) {
  return new ZodMiniArray({
    type: "array",
    element,
    ...util_exports.normalizeParams(params)
  });
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
var ZodMiniObject = $constructor("ZodMiniObject", (inst, def) => {
  $ZodObject.init(inst, def);
  ZodMiniType.init(inst, def);
  util_exports.defineLazy(inst, "shape", () => def.shape);
});
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodMiniObject(def);
}
function strictObject(shape, params) {
  return new ZodMiniObject({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodMiniObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
function extend2(schema, shape) {
  return util_exports.extend(schema, shape);
}
function safeExtend2(schema, shape) {
  return util_exports.safeExtend(schema, shape);
}
function merge2(schema, shape) {
  return util_exports.extend(schema, shape);
}
function pick2(schema, mask) {
  return util_exports.pick(schema, mask);
}
function omit2(schema, mask) {
  return util_exports.omit(schema, mask);
}
function partial2(schema, mask) {
  return util_exports.partial(ZodMiniOptional, schema, mask);
}
function required2(schema, mask) {
  return util_exports.required(ZodMiniNonOptional, schema, mask);
}
function catchall(inst, catchall2) {
  return inst.clone({ ...inst._zod.def, catchall: catchall2 });
}
var ZodMiniUnion = $constructor("ZodMiniUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodMiniType.init(inst, def);
});
function union(options, params) {
  return new ZodMiniUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMiniDiscriminatedUnion = $constructor("ZodMiniDiscriminatedUnion", (inst, def) => {
  $ZodDiscriminatedUnion.init(inst, def);
  ZodMiniType.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodMiniDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMiniIntersection = $constructor("ZodMiniIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodMiniType.init(inst, def);
});
function intersection(left, right) {
  return new ZodMiniIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodMiniTuple = $constructor("ZodMiniTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodMiniType.init(inst, def);
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodMiniTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMiniRecord = $constructor("ZodMiniRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodMiniType.init(inst, def);
});
function record(keyType, valueType, params) {
  return new ZodMiniRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = void 0;
  return new ZodMiniRecord({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMiniMap = $constructor("ZodMiniMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodMiniType.init(inst, def);
});
function map(keyType, valueType, params) {
  return new ZodMiniMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMiniSet = $constructor("ZodMiniSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodMiniType.init(inst, def);
});
function set2(valueType, params) {
  return new ZodMiniSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMiniEnum = $constructor("ZodMiniEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodMiniType.init(inst, def);
  inst.options = Object.values(def.entries);
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodMiniEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodMiniEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMiniLiteral = $constructor("ZodMiniLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodMiniType.init(inst, def);
});
function literal(value, params) {
  return new ZodMiniLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
var ZodMiniFile = $constructor("ZodMiniFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodMiniType.init(inst, def);
});
function file(params) {
  return _file(ZodMiniFile, params);
}
var ZodMiniTransform = $constructor("ZodMiniTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodMiniType.init(inst, def);
});
function transform(fn) {
  return new ZodMiniTransform({
    type: "transform",
    transform: fn
  });
}
var ZodMiniOptional = $constructor("ZodMiniOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodMiniType.init(inst, def);
});
function optional(innerType) {
  return new ZodMiniOptional({
    type: "optional",
    innerType
  });
}
var ZodMiniNullable = $constructor("ZodMiniNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodMiniType.init(inst, def);
});
function nullable(innerType) {
  return new ZodMiniNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodMiniDefault = $constructor("ZodMiniDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodMiniType.init(inst, def);
});
function _default2(innerType, defaultValue) {
  return new ZodMiniDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodMiniPrefault = $constructor("ZodMiniPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodMiniType.init(inst, def);
});
function prefault(innerType, defaultValue) {
  return new ZodMiniPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodMiniNonOptional = $constructor("ZodMiniNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodMiniType.init(inst, def);
});
function nonoptional(innerType, params) {
  return new ZodMiniNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMiniSuccess = $constructor("ZodMiniSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodMiniType.init(inst, def);
});
function success(innerType) {
  return new ZodMiniSuccess({
    type: "success",
    innerType
  });
}
var ZodMiniCatch = $constructor("ZodMiniCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodMiniType.init(inst, def);
});
function _catch2(innerType, catchValue) {
  return new ZodMiniCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodMiniNaN = $constructor("ZodMiniNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodMiniType.init(inst, def);
});
function nan(params) {
  return _nan(ZodMiniNaN, params);
}
var ZodMiniPipe = $constructor("ZodMiniPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodMiniType.init(inst, def);
});
function pipe(in_, out) {
  return new ZodMiniPipe({
    type: "pipe",
    in: in_,
    out
  });
}
var ZodMiniCodec = $constructor("ZodMiniCodec", (inst, def) => {
  ZodMiniPipe.init(inst, def);
  $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodMiniCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodMiniReadonly = $constructor("ZodMiniReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodMiniType.init(inst, def);
});
function readonly(innerType) {
  return new ZodMiniReadonly({
    type: "readonly",
    innerType
  });
}
var ZodMiniTemplateLiteral = $constructor("ZodMiniTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodMiniType.init(inst, def);
});
function templateLiteral(parts, params) {
  return new ZodMiniTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
var ZodMiniLazy = $constructor("ZodMiniLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodMiniType.init(inst, def);
});
function _lazy2(getter) {
  return new ZodMiniLazy({
    type: "lazy",
    getter
  });
}
var ZodMiniPromise = $constructor("ZodMiniPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodMiniType.init(inst, def);
});
function promise(innerType) {
  return new ZodMiniPromise({
    type: "promise",
    innerType
  });
}
var ZodMiniCustom = $constructor("ZodMiniCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodMiniType.init(inst, def);
});
function check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...util_exports.normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodMiniCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodMiniCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
var describe2 = describe;
var meta2 = meta;
function _instanceof(cls, params = {
  error: `Input not instance of ${cls.name}`
}) {
  const inst = custom((data) => data instanceof cls, params);
  inst._zod.bag.Class = cls;
  return inst;
}
var stringbool = (...args) => _stringbool({
  Codec: ZodMiniCodec,
  Boolean: ZodMiniBoolean,
  String: ZodMiniString
}, ...args);
function json() {
  const jsonSchema = _lazy2(() => {
    return union([string2(), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
var ZodMiniFunction = $constructor("ZodMiniFunction", (inst, def) => {
  $ZodFunction.init(inst, def);
  ZodMiniType.init(inst, def);
});
function _function(params) {
  return new ZodMiniFunction({
    type: "function",
    input: Array.isArray(params == null ? void 0 : params.input) ? tuple(params == null ? void 0 : params.input) : (params == null ? void 0 : params.input) ?? array(unknown()),
    output: (params == null ? void 0 : params.output) ?? unknown()
  });
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/mini/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodMiniISODate: () => ZodMiniISODate,
  ZodMiniISODateTime: () => ZodMiniISODateTime,
  ZodMiniISODuration: () => ZodMiniISODuration,
  ZodMiniISOTime: () => ZodMiniISOTime,
  date: () => date3,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
var ZodMiniISODateTime = $constructor("ZodMiniISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodMiniISODateTime, params);
}
var ZodMiniISODate = $constructor("ZodMiniISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function date3(params) {
  return _isoDate(ZodMiniISODate, params);
}
var ZodMiniISOTime = $constructor("ZodMiniISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodMiniISOTime, params);
}
var ZodMiniISODuration = $constructor("ZodMiniISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodMiniStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodMiniISODuration, params);
}

// node_modules/@wagmi/connectors/node_modules/zod/v4/mini/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint3,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodMiniString, params);
}
function number3(params) {
  return _coercedNumber(ZodMiniNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodMiniBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodMiniBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodMiniDate, params);
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/viem/Account.js
var Account_exports = {};
__export(Account_exports, {
  from: () => from12,
  fromPrivateKey: () => fromPrivateKey,
  getKey: () => getKey,
  sign: () => sign6
});

// node_modules/@wagmi/connectors/node_modules/porto/dist/viem/Key.js
var Key_exports = {};
__export(Key_exports, {
  createHeadlessWebAuthnP256: () => createHeadlessWebAuthnP256,
  createP256: () => createP256,
  createSecp256k1: () => createSecp256k1,
  createWebAuthnP256: () => createWebAuthnP256,
  createWebCryptoP256: () => createWebCryptoP256,
  deserialize: () => deserialize,
  from: () => from11,
  fromHeadlessWebAuthnP256: () => fromHeadlessWebAuthnP256,
  fromP256: () => fromP256,
  fromRelay: () => fromRelay,
  fromRelayKeyRole: () => fromRelayKeyRole,
  fromRelayKeyType: () => fromRelayKeyType,
  fromSecp256k1: () => fromSecp256k1,
  fromSerializedKeyType: () => fromSerializedKeyType,
  fromSerializedSpendPeriod: () => fromSerializedSpendPeriod,
  fromWebAuthnP256: () => fromWebAuthnP256,
  fromWebCryptoP256: () => fromWebCryptoP256,
  getFeeToken: () => getFeeToken,
  hash: () => hash2,
  resolvePermissions: () => resolvePermissions,
  serialize: () => serialize,
  serializePublicKey: () => serializePublicKey,
  serializeWebAuthnSignature: () => serializeWebAuthnSignature,
  sign: () => sign5,
  toRelay: () => toRelay,
  toRelayKeyRole: () => toRelayKeyRole,
  toRelayKeyType: () => toRelayKeyType,
  toSerializedKeyType: () => toSerializedKeyType,
  toSerializedSpendPeriod: () => toSerializedSpendPeriod,
  wrapSignature: () => wrapSignature
});

// node_modules/ox/_esm/core/Value.js
function from10(value, decimals = 0) {
  if (!/^(-?)([0-9]*)\.?([0-9]*)$/.test(value))
    throw new InvalidDecimalNumberError({ value });
  let [integer2 = "", fraction = "0"] = value.split(".");
  const negative = integer2.startsWith("-");
  if (negative)
    integer2 = integer2.slice(1);
  fraction = fraction.replace(/(0+)$/, "");
  if (decimals === 0) {
    if (Math.round(Number(`.${fraction}`)) === 1)
      integer2 = `${BigInt(integer2) + 1n}`;
    fraction = "";
  } else if (fraction.length > decimals) {
    const [left, unit, right] = [
      fraction.slice(0, decimals - 1),
      fraction.slice(decimals - 1, decimals),
      fraction.slice(decimals)
    ];
    const rounded = Math.round(Number(`${unit}.${right}`));
    if (rounded > 9)
      fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, "0");
    else
      fraction = `${left}${rounded}`;
    if (fraction.length > decimals) {
      fraction = fraction.slice(1);
      integer2 = `${BigInt(integer2) + 1n}`;
    }
    fraction = fraction.slice(0, decimals);
  } else {
    fraction = fraction.padEnd(decimals, "0");
  }
  return BigInt(`${negative ? "-" : ""}${integer2}${fraction}`);
}
var InvalidDecimalNumberError = class extends BaseError2 {
  constructor({ value }) {
    super(`Value \`${value}\` is not a valid decimal number.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Value.InvalidDecimalNumberError"
    });
  }
};

// node_modules/ox/_esm/core/WebCryptoP256.js
async function createKeyPair(options = {}) {
  const { extractable = false } = options;
  const keypair = await globalThis.crypto.subtle.generateKey({
    name: "ECDSA",
    namedCurve: "P-256"
  }, extractable, ["sign", "verify"]);
  const publicKey_raw = await globalThis.crypto.subtle.exportKey("raw", keypair.publicKey);
  const publicKey = from3(new Uint8Array(publicKey_raw));
  return {
    privateKey: keypair.privateKey,
    publicKey
  };
}
async function sign4(options) {
  const { payload, privateKey } = options;
  const signature = await globalThis.crypto.subtle.sign({
    name: "ECDSA",
    hash: "SHA-256"
  }, privateKey, from(payload));
  const signature_bytes = fromArray(new Uint8Array(signature));
  const r = toBigInt(slice(signature_bytes, 0, 32));
  let s = toBigInt(slice(signature_bytes, 32, 64));
  if (s > p256.CURVE.n / 2n)
    s = p256.CURVE.n - s;
  return { r, s };
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/call.js
var call_exports = {};
__export(call_exports, {
  anyHash: () => anyHash,
  anySelector: () => anySelector,
  anyTarget: () => anyTarget,
  authorize: () => authorize,
  removeSpendLimit: () => removeSpendLimit,
  revoke: () => revoke,
  selfAddress: () => selfAddress,
  setCanExecute: () => setCanExecute,
  setLabel: () => setLabel,
  setSignatureCheckerApproval: () => setSignatureCheckerApproval,
  setSpendLimit: () => setSpendLimit,
  upgradeProxyAccount: () => upgradeProxyAccount
});

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/_generated/contracts/IthacaAccount.js
var abi = [
  {
    "type": "constructor",
    "inputs": [
      {
        "name": "orchestrator",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "payable"
  },
  {
    "type": "fallback",
    "stateMutability": "payable"
  },
  {
    "type": "receive",
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "ANY_FN_SEL",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ANY_KEYHASH",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ANY_TARGET",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "CALL_TYPEHASH",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "DOMAIN_TYPEHASH",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EMPTY_CALLDATA_FN_SEL",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "EXECUTE_TYPEHASH",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "MULTICHAIN_NONCE_PREFIX",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint16",
        "internalType": "uint16"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "ORCHESTRATOR",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "address",
        "internalType": "address"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "SIGN_TYPEHASH",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "approvedSignatureCheckers",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "address[]",
        "internalType": "address[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "authorize",
    "inputs": [
      {
        "name": "key",
        "type": "tuple",
        "internalType": "struct IthacaAccount.Key",
        "components": [
          {
            "name": "expiry",
            "type": "uint40",
            "internalType": "uint40"
          },
          {
            "name": "keyType",
            "type": "uint8",
            "internalType": "enum IthacaAccount.KeyType"
          },
          {
            "name": "isSuperAdmin",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "publicKey",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "callCheckerInfos",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "results",
        "type": "tuple[]",
        "internalType": "struct GuardedExecutor.CallCheckerInfo[]",
        "components": [
          {
            "name": "target",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "checker",
            "type": "address",
            "internalType": "address"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "canExecute",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "canExecutePackedInfos",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "checkAndIncrementNonce",
    "inputs": [
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "computeDigest",
    "inputs": [
      {
        "name": "calls",
        "type": "tuple[]",
        "internalType": "struct ERC7821.Call[]",
        "components": [
          {
            "name": "to",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "value",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "data",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      },
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "eip712Domain",
    "inputs": [],
    "outputs": [
      {
        "name": "fields",
        "type": "bytes1",
        "internalType": "bytes1"
      },
      {
        "name": "name",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "version",
        "type": "string",
        "internalType": "string"
      },
      {
        "name": "chainId",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "verifyingContract",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "salt",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "extensions",
        "type": "uint256[]",
        "internalType": "uint256[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "execute",
    "inputs": [
      {
        "name": "mode",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "executionData",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "payable"
  },
  {
    "type": "function",
    "name": "getContextKeyHash",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKey",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "key",
        "type": "tuple",
        "internalType": "struct IthacaAccount.Key",
        "components": [
          {
            "name": "expiry",
            "type": "uint40",
            "internalType": "uint40"
          },
          {
            "name": "keyType",
            "type": "uint8",
            "internalType": "enum IthacaAccount.KeyType"
          },
          {
            "name": "isSuperAdmin",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "publicKey",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getKeys",
    "inputs": [],
    "outputs": [
      {
        "name": "keys",
        "type": "tuple[]",
        "internalType": "struct IthacaAccount.Key[]",
        "components": [
          {
            "name": "expiry",
            "type": "uint40",
            "internalType": "uint40"
          },
          {
            "name": "keyType",
            "type": "uint8",
            "internalType": "enum IthacaAccount.KeyType"
          },
          {
            "name": "isSuperAdmin",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "publicKey",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      },
      {
        "name": "keyHashes",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "getNonce",
    "inputs": [
      {
        "name": "seqKey",
        "type": "uint192",
        "internalType": "uint192"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "hash",
    "inputs": [
      {
        "name": "key",
        "type": "tuple",
        "internalType": "struct IthacaAccount.Key",
        "components": [
          {
            "name": "expiry",
            "type": "uint40",
            "internalType": "uint40"
          },
          {
            "name": "keyType",
            "type": "uint8",
            "internalType": "enum IthacaAccount.KeyType"
          },
          {
            "name": "isSuperAdmin",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "publicKey",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "invalidateNonce",
    "inputs": [
      {
        "name": "nonce",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "isValidSignature",
    "inputs": [
      {
        "name": "digest",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bytes4",
        "internalType": "bytes4"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "keyAt",
    "inputs": [
      {
        "name": "i",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "tuple",
        "internalType": "struct IthacaAccount.Key",
        "components": [
          {
            "name": "expiry",
            "type": "uint40",
            "internalType": "uint40"
          },
          {
            "name": "keyType",
            "type": "uint8",
            "internalType": "enum IthacaAccount.KeyType"
          },
          {
            "name": "isSuperAdmin",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "publicKey",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "keyCount",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "label",
    "inputs": [],
    "outputs": [
      {
        "name": "",
        "type": "string",
        "internalType": "string"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "pay",
    "inputs": [
      {
        "name": "paymentAmount",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "keyHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "intentDigest",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "encodedIntent",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "removeSpendLimit",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "period",
        "type": "uint8",
        "internalType": "enum GuardedExecutor.SpendPeriod"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "revoke",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setCallChecker",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "checker",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setCanExecute",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "fnSel",
        "type": "bytes4",
        "internalType": "bytes4"
      },
      {
        "name": "can",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setLabel",
    "inputs": [
      {
        "name": "newLabel",
        "type": "string",
        "internalType": "string"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setSignatureCheckerApproval",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "checker",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "isApproved",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "setSpendLimit",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "period",
        "type": "uint8",
        "internalType": "enum GuardedExecutor.SpendPeriod"
      },
      {
        "name": "limit",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "spendAndExecuteInfos",
    "inputs": [
      {
        "name": "keyHashes",
        "type": "bytes32[]",
        "internalType": "bytes32[]"
      }
    ],
    "outputs": [
      {
        "name": "spends",
        "type": "tuple[][]",
        "internalType": "struct GuardedExecutor.SpendInfo[][]",
        "components": [
          {
            "name": "token",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "period",
            "type": "uint8",
            "internalType": "enum GuardedExecutor.SpendPeriod"
          },
          {
            "name": "limit",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "spent",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "lastUpdated",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "currentSpent",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "current",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      },
      {
        "name": "executes",
        "type": "bytes32[][]",
        "internalType": "bytes32[][]"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "spendInfos",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "results",
        "type": "tuple[]",
        "internalType": "struct GuardedExecutor.SpendInfo[]",
        "components": [
          {
            "name": "token",
            "type": "address",
            "internalType": "address"
          },
          {
            "name": "period",
            "type": "uint8",
            "internalType": "enum GuardedExecutor.SpendPeriod"
          },
          {
            "name": "limit",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "spent",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "lastUpdated",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "currentSpent",
            "type": "uint256",
            "internalType": "uint256"
          },
          {
            "name": "current",
            "type": "uint256",
            "internalType": "uint256"
          }
        ]
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "startOfSpendPeriod",
    "inputs": [
      {
        "name": "unixTimestamp",
        "type": "uint256",
        "internalType": "uint256"
      },
      {
        "name": "period",
        "type": "uint8",
        "internalType": "enum GuardedExecutor.SpendPeriod"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "uint256",
        "internalType": "uint256"
      }
    ],
    "stateMutability": "pure"
  },
  {
    "type": "function",
    "name": "supportsExecutionMode",
    "inputs": [
      {
        "name": "mode",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "result",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "unwrapAndValidateSignature",
    "inputs": [
      {
        "name": "digest",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "signature",
        "type": "bytes",
        "internalType": "bytes"
      }
    ],
    "outputs": [
      {
        "name": "isValid",
        "type": "bool",
        "internalType": "bool"
      },
      {
        "name": "keyHash",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "stateMutability": "view"
  },
  {
    "type": "function",
    "name": "upgradeHook",
    "inputs": [
      {
        "name": "previousVersion",
        "type": "bytes32",
        "internalType": "bytes32"
      }
    ],
    "outputs": [
      {
        "name": "",
        "type": "bool",
        "internalType": "bool"
      }
    ],
    "stateMutability": "nonpayable"
  },
  {
    "type": "function",
    "name": "upgradeProxyAccount",
    "inputs": [
      {
        "name": "newImplementation",
        "type": "address",
        "internalType": "address"
      }
    ],
    "outputs": [],
    "stateMutability": "nonpayable"
  },
  {
    "type": "event",
    "name": "Authorized",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "key",
        "type": "tuple",
        "indexed": false,
        "internalType": "struct IthacaAccount.Key",
        "components": [
          {
            "name": "expiry",
            "type": "uint40",
            "internalType": "uint40"
          },
          {
            "name": "keyType",
            "type": "uint8",
            "internalType": "enum IthacaAccount.KeyType"
          },
          {
            "name": "isSuperAdmin",
            "type": "bool",
            "internalType": "bool"
          },
          {
            "name": "publicKey",
            "type": "bytes",
            "internalType": "bytes"
          }
        ]
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "CallCheckerSet",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "target",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "checker",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "CanExecuteSet",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "target",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "fnSel",
        "type": "bytes4",
        "indexed": false,
        "internalType": "bytes4"
      },
      {
        "name": "can",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ImplementationApprovalSet",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "isApproved",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "ImplementationCallerApprovalSet",
    "inputs": [
      {
        "name": "implementation",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "caller",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "isApproved",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "LabelSet",
    "inputs": [
      {
        "name": "newLabel",
        "type": "string",
        "indexed": false,
        "internalType": "string"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "NonceInvalidated",
    "inputs": [
      {
        "name": "nonce",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "Revoked",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SignatureCheckerApprovalSet",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "indexed": true,
        "internalType": "bytes32"
      },
      {
        "name": "checker",
        "type": "address",
        "indexed": true,
        "internalType": "address"
      },
      {
        "name": "isApproved",
        "type": "bool",
        "indexed": false,
        "internalType": "bool"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SpendLimitRemoved",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "token",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "period",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum GuardedExecutor.SpendPeriod"
      }
    ],
    "anonymous": false
  },
  {
    "type": "event",
    "name": "SpendLimitSet",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "indexed": false,
        "internalType": "bytes32"
      },
      {
        "name": "token",
        "type": "address",
        "indexed": false,
        "internalType": "address"
      },
      {
        "name": "period",
        "type": "uint8",
        "indexed": false,
        "internalType": "enum GuardedExecutor.SpendPeriod"
      },
      {
        "name": "limit",
        "type": "uint256",
        "indexed": false,
        "internalType": "uint256"
      }
    ],
    "anonymous": false
  },
  {
    "type": "error",
    "name": "BatchOfBatchesDecodingError",
    "inputs": []
  },
  {
    "type": "error",
    "name": "CannotSelfExecute",
    "inputs": []
  },
  {
    "type": "error",
    "name": "ExceededSpendLimit",
    "inputs": [
      {
        "name": "token",
        "type": "address",
        "internalType": "address"
      }
    ]
  },
  {
    "type": "error",
    "name": "ExceedsCapacity",
    "inputs": []
  },
  {
    "type": "error",
    "name": "FnSelectorNotRecognized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "IndexOutOfBounds",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidNonce",
    "inputs": []
  },
  {
    "type": "error",
    "name": "InvalidPublicKey",
    "inputs": []
  },
  {
    "type": "error",
    "name": "KeyDoesNotExist",
    "inputs": []
  },
  {
    "type": "error",
    "name": "KeyHashIsZero",
    "inputs": []
  },
  {
    "type": "error",
    "name": "KeyTypeCannotBeSuperAdmin",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NewImplementationIsZero",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NewSequenceMustBeLarger",
    "inputs": []
  },
  {
    "type": "error",
    "name": "NoSpendPermissions",
    "inputs": []
  },
  {
    "type": "error",
    "name": "OpDataError",
    "inputs": []
  },
  {
    "type": "error",
    "name": "PaymasterNonceError",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SuperAdminCanExecuteEverything",
    "inputs": []
  },
  {
    "type": "error",
    "name": "SuperAdminCanSpendAnything",
    "inputs": []
  },
  {
    "type": "error",
    "name": "Unauthorized",
    "inputs": []
  },
  {
    "type": "error",
    "name": "UnauthorizedCall",
    "inputs": [
      {
        "name": "keyHash",
        "type": "bytes32",
        "internalType": "bytes32"
      },
      {
        "name": "target",
        "type": "address",
        "internalType": "address"
      },
      {
        "name": "data",
        "type": "bytes",
        "internalType": "bytes"
      }
    ]
  },
  {
    "type": "error",
    "name": "UnsupportedExecutionMode",
    "inputs": []
  }
];

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/call.js
var selfAddress = "0x2323232323232323232323232323232323232323";
function authorize(parameters) {
  const { key } = parameters;
  return {
    data: encodeData(fromAbi(abi, "authorize"), [serialize(key)]),
    to: selfAddress
  };
}
var anyHash = "0x3232323232323232323232323232323232323232323232323232323232323232";
var anyTarget = "0x3232323232323232323232323232323232323232";
var anySelector = "0x32323232";
function setCanExecute(parameters = {}) {
  const { enabled = true, key, selector = anySelector, to = anyTarget } = parameters;
  const hash3 = key ? key.hash : anyHash;
  return {
    data: encodeData(fromAbi(abi, "setCanExecute"), [hash3, to, selector, enabled]),
    to: selfAddress
  };
}
function setLabel(parameters) {
  const { label } = parameters;
  return {
    data: encodeData(fromAbi(abi, "setLabel"), [label]),
    to: selfAddress
  };
}
function setSpendLimit(parameters) {
  const { key, period, limit } = parameters;
  const token = parameters.token ?? "0x0000000000000000000000000000000000000000";
  return {
    data: encodeData(fromAbi(abi, "setSpendLimit"), [key.hash, token, toSerializedSpendPeriod[period], limit]),
    to: selfAddress
  };
}
function setSignatureCheckerApproval(parameters) {
  const { address: address2, key, enabled } = parameters;
  return {
    data: encodeData(fromAbi(abi, "setSignatureCheckerApproval"), [key.hash, address2, enabled]),
    to: selfAddress
  };
}
function removeSpendLimit(parameters) {
  const { key, token, period } = parameters;
  return {
    data: encodeData(fromAbi(abi, "removeSpendLimit"), [key.hash, token, toSerializedSpendPeriod[period]]),
    to: selfAddress
  };
}
function revoke(parameters) {
  const { keyHash } = parameters;
  return {
    data: encodeData(fromAbi(abi, "revoke"), [keyHash]),
    to: selfAddress
  };
}
function upgradeProxyAccount(parameters) {
  const { address: address2, to = selfAddress } = parameters;
  return {
    data: encodeData(fromAbi(abi, "upgradeProxyAccount"), [address2]),
    to
  };
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/viem/Key.js
var fromRelayKeyType = {
  p256: "p256",
  secp256k1: "secp256k1",
  webauthnp256: "webauthn-p256"
};
var fromRelayKeyRole = {
  admin: "admin",
  normal: "session"
};
var fromSerializedKeyType = {
  0: "p256",
  1: "webauthn-p256",
  2: "secp256k1"
};
var fromSerializedSpendPeriod = {
  0: "minute",
  1: "hour",
  2: "day",
  3: "week",
  4: "month",
  5: "year"
};
var toRelayKeyType = {
  address: "secp256k1",
  p256: "p256",
  secp256k1: "secp256k1",
  "webauthn-p256": "webauthnp256"
};
var toRelayKeyRole = {
  admin: "admin",
  session: "normal"
};
var toSerializedKeyType = {
  address: 2,
  p256: 0,
  secp256k1: 2,
  "webauthn-p256": 1
};
var toSerializedSpendPeriod = {
  day: 2,
  hour: 1,
  minute: 0,
  month: 4,
  week: 3,
  year: 5
};
function createP256(parameters = {}) {
  const privateKey = randomPrivateKey2();
  return fromP256({
    ...parameters,
    privateKey
  });
}
function createSecp256k1(parameters = {}) {
  const privateKey = randomPrivateKey();
  return fromSecp256k1({
    ...parameters,
    privateKey
  });
}
async function createWebAuthnP256(parameters) {
  const { createFn, label, rpId, userId } = parameters;
  const credential = await createCredential({
    authenticatorSelection: {
      requireResidentKey: true,
      residentKey: "required",
      userVerification: "required"
    },
    createFn,
    extensions: {
      credProps: true
    },
    rp: rpId ? {
      id: rpId,
      name: rpId
    } : void 0,
    user: {
      displayName: label,
      id: new Uint8Array(userId ?? fromString(label)),
      name: label
    }
  });
  return fromWebAuthnP256({
    ...parameters,
    credential: {
      id: credential.id,
      publicKey: credential.publicKey
    },
    id: userId ? toHex(userId) : toHex2(credential.publicKey, {
      includePrefix: false
    })
  });
}
function createHeadlessWebAuthnP256(parameters = {}) {
  const privateKey = randomPrivateKey2();
  return fromHeadlessWebAuthnP256({
    ...parameters,
    privateKey
  });
}
async function createWebCryptoP256(parameters = {}) {
  const keyPair = await createKeyPair();
  return fromWebCryptoP256({
    ...parameters,
    keyPair
  });
}
function deserialize(serialized, options = {}) {
  const { chainId } = options;
  const publicKey = serialized.publicKey;
  const type = fromSerializedKeyType[serialized.keyType];
  return from11({
    chainId,
    expiry: serialized.expiry,
    publicKey,
    role: serialized.isSuperAdmin ? "admin" : "session",
    type
  });
}
function from11(key, options = {}) {
  const { chainId = key.chainId } = options;
  const { expiry = 0, id, prehash = false, role = "admin", type } = key;
  const publicKey = (() => {
    const publicKey2 = key.publicKey;
    if (publicKey2 === "0x")
      return publicKey2;
    if (type === "secp256k1" || type === "address") {
      const isAddress = size(publicKey2) === 20 || toBigInt2(slice2(publicKey2, 0, 12)) === 0n;
      const address2 = isAddress ? slice2(publicKey2, -20) : fromPublicKey(fromHex(publicKey2));
      return address2;
    }
    return publicKey2;
  })();
  return {
    ...key,
    chainId,
    expiry,
    hash: hash2({
      publicKey,
      type
    }),
    id: (id ?? publicKey).toLowerCase(),
    prehash,
    publicKey: publicKey.toLowerCase(),
    role,
    type
  };
}
function fromP256(parameters) {
  const { chainId, expiry, feeToken: feeToken2, permissions: permissions2, privateKey, role } = parameters;
  const publicKey = toHex2(getPublicKey2({ privateKey }), {
    includePrefix: false
  });
  return from11({
    chainId,
    expiry,
    feeToken: feeToken2,
    permissions: permissions2,
    privateKey() {
      return privateKey;
    },
    publicKey,
    role,
    type: "p256"
  });
}
function fromRelay(relayKey, options) {
  const { chainId } = options;
  const { publicKey } = relayKey;
  const isAddress = size(publicKey) === 20 || toBigInt2(slice2(publicKey, 0, 12)) === 0n;
  const permissions2 = {};
  for (const permission of relayKey.permissions) {
    if (permission.type === "call") {
      permissions2.calls ?? (permissions2.calls = []);
      permissions2.calls.push({
        signature: permission.selector,
        to: permission.to === anyTarget ? void 0 : permission.to
      });
    }
    if (permission.type === "spend") {
      permissions2.spend ?? (permissions2.spend = []);
      permissions2.spend.push({
        limit: permission.limit,
        period: permission.period,
        token: permission.token
      });
    }
  }
  return from11({
    chainId,
    expiry: relayKey.expiry,
    permissions: permissions2,
    publicKey: relayKey.publicKey,
    role: fromRelayKeyRole[relayKey.role],
    type: isAddress ? "address" : fromRelayKeyType[relayKey.type]
  });
}
function fromSecp256k1(parameters) {
  const { privateKey, role } = parameters;
  const publicKey = (() => {
    if (parameters.publicKey)
      return parameters.publicKey;
    if (privateKey)
      return fromPublicKey(getPublicKey({ privateKey }));
    return parameters.address.toLowerCase();
  })();
  return from11({
    expiry: parameters.expiry ?? 0,
    feeToken: parameters.feeToken,
    permissions: parameters.permissions,
    privateKey: privateKey ? () => privateKey : void 0,
    publicKey,
    role,
    type: "secp256k1"
  });
}
function fromWebAuthnP256(parameters) {
  const { credential, id, rpId } = parameters;
  const publicKey = toHex2(credential.publicKey, {
    includePrefix: false
  });
  return from11({
    chainId: parameters.chainId,
    expiry: parameters.expiry ?? 0,
    feeToken: parameters.feeToken,
    id,
    permissions: parameters.permissions,
    privateKey: {
      credential,
      rpId
    },
    publicKey,
    role: parameters.role,
    type: "webauthn-p256"
  });
}
function fromHeadlessWebAuthnP256(parameters) {
  const { privateKey } = parameters;
  const publicKey = toHex2(getPublicKey2({ privateKey }), {
    includePrefix: false
  });
  return from11({
    chainId: parameters.chainId,
    expiry: parameters.expiry ?? 0,
    feeToken: parameters.feeToken,
    permissions: parameters.permissions,
    privateKey: {
      privateKey() {
        return privateKey;
      }
    },
    publicKey,
    role: parameters.role,
    type: "webauthn-p256"
  });
}
function fromWebCryptoP256(parameters) {
  const { chainId, expiry, feeToken: feeToken2, keyPair, permissions: permissions2, role } = parameters;
  const { privateKey } = keyPair;
  const publicKey = toHex2(keyPair.publicKey, {
    includePrefix: false
  });
  return from11({
    chainId,
    expiry,
    feeToken: feeToken2,
    permissions: permissions2,
    prehash: true,
    privateKey,
    publicKey,
    role,
    type: "p256"
  });
}
function hash2(key) {
  const { type } = key;
  const publicKey = serializePublicKey(key.publicKey);
  return keccak256(encode([{ type: "uint8" }, { type: "bytes32" }], [toSerializedKeyType[type], keccak256(publicKey)]));
}
function serializePublicKey(publicKey) {
  return size(publicKey) < 32 ? padLeft(publicKey, 32) : publicKey;
}
function serialize(key) {
  const { expiry = 0, publicKey, role, type } = key;
  return {
    expiry,
    isSuperAdmin: role === "admin",
    keyType: toSerializedKeyType[type],
    publicKey: serializePublicKey(publicKey)
  };
}
async function sign5(key, parameters) {
  const { address: address2, storage, webAuthn, wrap: wrap3 = true } = parameters;
  const { privateKey, publicKey, type: keyType } = key;
  if (!privateKey)
    throw new Error("Key does not have a private key to sign with.\n\nKey:\n" + stringify(key, null, 2));
  const payload = (() => {
    if (!address2)
      return parameters.payload;
    return getSignPayload2({
      domain: { verifyingContract: address2 },
      message: {
        digest: parameters.payload
      },
      primaryType: "ERC1271Sign",
      types: {
        ERC1271Sign: [{ name: "digest", type: "bytes32" }]
      }
    });
  })();
  const [signature, prehash] = await (async () => {
    if (keyType === "p256") {
      const { privateKey: privateKey2 } = key;
      if (typeof privateKey2 === "function")
        return [
          toHex3(sign2({ payload, privateKey: privateKey2() })),
          false
        ];
      if (privateKey2 instanceof CryptoKey) {
        const signature2 = toHex3(await sign4({ payload, privateKey: privateKey2 }));
        return [signature2, true];
      }
    }
    if (keyType === "secp256k1") {
      return [
        toHex3(sign({ payload, privateKey: privateKey() })),
        false
      ];
    }
    if (keyType === "webauthn-p256") {
      if (privateKey.privateKey) {
        const { payload: wrapped, metadata: metadata2 } = getSignPayload({
          challenge: payload,
          origin: "https://ithaca.xyz",
          rpId: "ithaca.xyz"
        });
        const { r: r2, s: s2 } = sign2({
          hash: true,
          payload: wrapped,
          privateKey: privateKey.privateKey()
        });
        const signature3 = serializeWebAuthnSignature({
          metadata: metadata2,
          signature: { r: r2, s: s2 }
        });
        return [signature3, false];
      }
      const { credential, rpId } = privateKey;
      const cacheKey = `porto.webauthnVerified.${key.hash}`;
      const now = Date.now();
      const verificationTimeout = 10 * 60 * 1e3;
      let requireVerification = true;
      if (storage) {
        const lastVerified = await storage.getItem(cacheKey);
        requireVerification = !lastVerified || now - lastVerified > verificationTimeout;
      }
      const { signature: { r, s }, raw, metadata } = await sign3({
        challenge: payload,
        credentialId: credential.id,
        getFn: webAuthn == null ? void 0 : webAuthn.getFn,
        rpId,
        userVerification: requireVerification ? "required" : "preferred"
      });
      const response = raw.response;
      if (!(response == null ? void 0 : response.userHandle))
        throw new Error("No user handle in response", {
          cause: { response }
        });
      const id = toHex(new Uint8Array(response.userHandle));
      if (key.id && validate2(key.id) && !isEqual(key.id, id))
        throw new Error(`supplied webauthn key "${key.id}" does not match signature webauthn key "${id}"`, { cause: { id, key } });
      if (requireVerification && storage)
        await storage.setItem(cacheKey, now);
      const signature2 = serializeWebAuthnSignature({
        metadata,
        signature: { r, s }
      });
      return [signature2, false];
    }
    throw new Error(`Key type "${keyType}" is not supported.

Key:
` + stringify(key, null, 2));
  })();
  if (wrap3)
    return wrapSignature(signature, {
      keyType,
      prehash,
      publicKey
    });
  return signature;
}
function toRelay(key, options = {}) {
  const { expiry = 0, prehash = false, publicKey, role = "admin", type } = key;
  const { feeTokens, orchestrator } = options;
  const permissions2 = Object.entries(resolvePermissions(key, {
    feeTokens
  })).map(([key2, v]) => {
    if (key2 === "calls") {
      const calls = v;
      return calls.map(({ signature, to }) => {
        const selector = (() => {
          if (!signature)
            return anySelector;
          if (validate(signature))
            return signature;
          return getSelector2(signature);
        })();
        return {
          selector,
          to: to ?? anyTarget,
          type: "call"
        };
      });
    }
    if (key2 === "feeToken")
      return;
    if (key2 === "spend") {
      const value = v;
      return value.map(({ limit, period, token }) => {
        return {
          limit,
          period,
          token,
          type: "spend"
        };
      });
    }
    throw new Error(`Invalid permission type "${key2}".`);
  }).flat().filter(Boolean);
  if (key.role === "session" && orchestrator)
    permissions2.push({
      selector: anySelector,
      to: orchestrator,
      type: "call"
    });
  return {
    expiry,
    permissions: permissions2 ?? [],
    prehash,
    publicKey: serializePublicKey(publicKey),
    role: toRelayKeyRole[role],
    type: toRelayKeyType[type]
  };
}
function resolvePermissions(key, options) {
  var _a2;
  const { permissions: permissions2 } = key;
  const calls = (permissions2 == null ? void 0 : permissions2.calls) ? [...permissions2.calls] : [];
  const spend = (permissions2 == null ? void 0 : permissions2.spend) ? [...permissions2.spend] : [];
  const feeTokens = (_a2 = options.feeTokens) == null ? void 0 : _a2.filter((token) => token.feeToken);
  if (feeTokens && feeTokens.length > 0) {
    const feeToken2 = getFeeToken(key, {
      feeTokens
    });
    if (feeToken2) {
      let index = -1;
      let minPeriod = toSerializedSpendPeriod.year;
      for (let i = 0; i < spend.length; i++) {
        const s = spend[i];
        if (s.token && isEqual(feeToken2.address, s.token)) {
          index = i;
          break;
        }
        if (!s.token && feeToken2.address === zeroAddress) {
          index = i;
          break;
        }
        const period = toSerializedSpendPeriod[s.period];
        if (period < minPeriod)
          minPeriod = period;
      }
      if (index !== -1) {
        spend[index] = {
          ...spend[index],
          limit: spend[index].limit + feeToken2.value
        };
        spend.unshift(spend.splice(index, 1)[0]);
      } else if (typeof minPeriod === "number")
        spend.unshift({
          limit: feeToken2.value,
          period: fromSerializedSpendPeriod[minPeriod],
          token: feeToken2.address
        });
    }
  }
  return { ...permissions2, calls, spend };
}
function getFeeToken(key, options) {
  const { feeTokens } = options;
  if (!key.feeToken)
    return void 0;
  const feeToken2 = feeTokens.find((token) => {
    if (key.feeToken.symbol === token.symbol)
      return true;
    if (!key.feeToken.symbol)
      return token.address === zeroAddress;
    if (key.feeToken.symbol === "native")
      return token.address === zeroAddress;
    return false;
  });
  if (!feeToken2)
    return void 0;
  const value = from10(key.feeToken.limit, feeToken2.decimals);
  return {
    ...feeToken2,
    value
  };
}
function serializeWebAuthnSignature(options) {
  const { metadata, signature } = options;
  return encode(from5([
    "struct WebAuthnAuth { bytes authenticatorData; string clientDataJSON; uint256 challengeIndex; uint256 typeIndex; bytes32 r; bytes32 s; }",
    "WebAuthnAuth auth"
  ]), [
    {
      authenticatorData: metadata.authenticatorData,
      challengeIndex: BigInt(metadata.challengeIndex),
      clientDataJSON: metadata.clientDataJSON,
      r: fromNumber(signature.r, { size: 32 }),
      s: fromNumber(signature.s, { size: 32 }),
      typeIndex: BigInt(metadata.typeIndex)
    }
  ]);
}
function wrapSignature(signature, options) {
  const { keyType: type, prehash = false, publicKey } = options;
  const keyHash = hash2({ publicKey, type });
  return encodePacked(["bytes", "bytes32", "bool"], [signature, keyHash, prehash]);
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/viem/Account.js
function from12(parameters) {
  const account = typeof parameters === "string" ? { address: parameters } : parameters;
  const source = account.sign ? "privateKey" : "porto";
  const { address: address2, sign: sign_, signMessage, signTransaction, signTypedData, type } = toAccount({
    address: account.address,
    sign({ hash: hash3 }) {
      if (source === "porto")
        throw new Error("`sign` not supported on porto accounts.");
      if (!account.sign)
        throw new Error("`sign` not supported.");
      return account.sign({ hash: hash3 });
    },
    signMessage({ message }) {
      return this.sign({
        hash: hashMessage(message)
      });
    },
    signTransaction() {
      throw new Error("`signTransaction` not supported on porto accounts.");
    },
    signTypedData(typedData) {
      return this.sign({
        hash: hashTypedData(typedData)
      });
    }
  });
  return {
    address: address2,
    keys: account.keys ?? void 0,
    sign: sign_,
    signMessage,
    signTransaction,
    signTypedData,
    source,
    type
  };
}
function fromPrivateKey(privateKey, options = {}) {
  const { keys } = options;
  const address2 = fromPublicKey(getPublicKey({ privateKey }));
  return from12({
    address: address2,
    keys,
    async sign({ hash: hash3 }) {
      return toHex3(sign({
        payload: hash3,
        privateKey
      }));
    },
    source: "privateKey"
  });
}
function getKey(account, parameters = {}) {
  const { key, role } = parameters;
  if (key === null)
    return void 0;
  if (typeof key === "object")
    return key;
  if (account.keys && account.keys.length > 0) {
    if (typeof key === "number")
      return account.keys[key];
    return account.keys.find((key2) => key2.privateKey && (!role || key2.role === role));
  }
  return void 0;
}
async function sign6(account, parameters) {
  const { storage, replaySafe = true, wrap: wrap3 = true, webAuthn } = parameters;
  const key = getKey(account, parameters);
  const payload = (() => {
    if (!replaySafe)
      return parameters.payload;
    return getSignPayload2({
      domain: { verifyingContract: account.address },
      message: {
        digest: parameters.payload
      },
      primaryType: "ERC1271Sign",
      types: {
        ERC1271Sign: [{ name: "digest", type: "bytes32" }]
      }
    });
  })();
  const sign7 = (() => {
    if (!key) {
      if (account.source === "privateKey")
        return account.sign;
      return void 0;
    }
    return ({ hash: hash3 }) => sign5(key, {
      address: null,
      payload: hash3,
      storage,
      webAuthn,
      wrap: wrap3
    });
  })();
  if (!sign7)
    throw new Error("cannot find key to sign with.");
  return await sign7({ hash: payload });
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/schema/utils.js
var address = () => templateLiteral(["0x", string2()], {
  message: "Needs string in format ^0x[A-Fa-f0-9]{40}$."
});
var hex3 = () => templateLiteral(["0x", string2()], {
  message: "Needs string in format ^0x[A-Fa-f0-9]+$."
});
var number4 = () => codec(hex3(), number2(), {
  decode: (value) => toNumber(value),
  encode: (value) => fromNumber(value)
});
var bigint4 = () => codec(hex3(), bigint2({ message: "Required bigint" }), {
  decode: (value) => toBigInt2(value),
  encode: (value) => fromNumber(value)
});
function oneOf(options) {
  return union(options);
}
var ValidationError = class extends BaseError2 {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Schema.ValidationError"
    });
  }
};
function toValidationError(e) {
  const error46 = e;
  let message = `Validation failed with ${error46.issues.length} error${error46.issues.length === 1 ? "" : "s"}:`;
  message += "\n";
  for (const issue2 of error46.issues) {
    if (!issue2)
      continue;
    message += "\n";
    message += formatIssue(issue2);
  }
  return new ValidationError(message);
}
function formatIssue(issue2, level = 0) {
  const path = formatPath(issue2.path);
  const prefix = `- ${path ? `${path}: ` : ""}`;
  const indent = "  ".repeat(level + 1);
  let message = prefix;
  switch (issue2.code) {
    case "invalid_type": {
      const expected = issue2.expected;
      const received = issue2.input ? formatReceivedType(issue2) : "undefined";
      message += `Expected ${expected}. ${issue2.message !== "Invalid input" ? issue2.message : ""}`;
      if (received !== "undefined")
        message += `but received ${received}`;
      break;
    }
    case "too_big": {
      const max = issue2.maximum;
      const inclusive = issue2.inclusive ?? true;
      const exact = issue2.exact ?? false;
      if (exact)
        message += `${issue2.origin} must be exactly ${max}`;
      else
        message += `${issue2.origin} must be ${inclusive ? "at most" : "less than"} ${max}`;
      break;
    }
    case "too_small": {
      const min = issue2.minimum;
      const inclusive = issue2.inclusive ?? true;
      const exact = issue2.exact ?? false;
      if (exact)
        message += `${issue2.origin} must be exactly ${min}`;
      else
        message += `${issue2.origin} must be ${inclusive ? "at least" : "greater than"} ${min}`;
      break;
    }
    case "invalid_format": {
      switch (issue2.format) {
        case "regex":
          message += `Must match pattern: ${issue2.pattern}`;
          break;
        case "starts_with":
          message += `Must start with "${issue2.prefix}"`;
          break;
        case "ends_with":
          message += `Must end with "${issue2.suffix}"`;
          break;
        case "includes":
          message += `Must include "${issue2.includes}"`;
          break;
        case "template_literal":
          message += `Must match pattern: ${issue2.pattern}`;
          break;
        default:
          message += `Invalid ${issue2.format} format`;
      }
      break;
    }
    case "not_multiple_of": {
      message += `Number must be a multiple of ${issue2.divisor}`;
      break;
    }
    case "unrecognized_keys": {
      const keys = issue2.keys.map((k) => `"${k}"`).join(", ");
      message += `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${keys}`;
      break;
    }
    case "invalid_union": {
      const hasErrors = issue2.errors && issue2.errors.length > 0;
      message += "Invalid union value.";
      if (hasErrors) {
        issue2.errors.forEach((optionErrors) => {
          if (optionErrors.length > 0) {
            optionErrors.forEach((subIssue) => {
              message += "\n";
              message += indent;
              message += formatIssue(subIssue, level + 1);
            });
          }
        });
      }
      break;
    }
    case "invalid_key": {
      message += `Invalid ${issue2.origin} key`;
      if (issue2.issues && issue2.issues.length > 0) {
        issue2.issues.forEach((subIssue) => {
          message += "\n";
          message += indent;
          message += formatIssue(subIssue, level + 1);
        });
      }
      break;
    }
    case "invalid_element": {
      message += `Invalid ${issue2.origin} element at key "${issue2.key}"`;
      if (issue2.issues && issue2.issues.length > 0) {
        issue2.issues.forEach((subIssue) => {
          message += "\n";
          message += indent;
          message += formatIssue(subIssue, level + 1);
        });
      }
      break;
    }
    case "invalid_value": {
      const values = issue2.values.map((v) => JSON.stringify(v)).join(", ");
      if (issue2.values.length > 1)
        message += `Expected one of: ${values}`;
      else
        message += `Expected ${values}`;
      break;
    }
    case "custom": {
      message += issue2.message || "Custom validation failed";
      break;
    }
    default: {
      message += issue2.message || "Validation failed";
    }
  }
  return message;
}
function formatPath(path) {
  if (path.length === 0)
    return "";
  return "at `" + path.map((key, index) => {
    if (typeof key === "number")
      return `[${key}]`;
    if (typeof key === "symbol")
      return `[${key.toString()}]`;
    if (/^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key) && index > 0)
      return `.${key}`;
    if (index === 0 && /^[a-zA-Z_][a-zA-Z0-9_]*$/.test(key))
      return key;
    return `["${key}"]`;
  }).join("") + "`";
}
function formatReceivedType(issue2) {
  const value = issue2.input;
  if (value === void 0)
    return "undefined";
  if (value === null)
    return "null";
  const type = typeof value;
  if (type === "object") {
    if (Array.isArray(value))
      return "array";
    if (value instanceof Date)
      return "date";
    if (value instanceof Map)
      return "map";
    if (value instanceof Set)
      return "set";
    return "object";
  }
  return type;
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/relay/schema/permission.js
var CallPermission = object({
  /** The selector of the function this permission applies to. */
  selector: hex3(),
  /** The address of the contract this permission applies to. */
  to: address(),
  /** Permission type. */
  type: literal("call")
});
var SpendPermission = object({
  /** The maximum amount that can be spent in the given period. */
  limit: bigint4(),
  /** The period of the limit. */
  period: union([
    literal("minute"),
    literal("hour"),
    literal("day"),
    literal("week"),
    literal("month"),
    literal("year")
  ]),
  /** The token this permission applies to. If `None`, defaults to native token (ETH). */
  token: optional(union([address(), _null3()])),
  /** Permission type. */
  type: literal("spend")
});
var Permission = union([CallPermission, SpendPermission]);

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/relay/schema/key.js
var Key = object({
  /** The expiry of the key. */
  expiry: number4(),
  /** Whether the digest was prehashed. */
  prehash: optional(boolean2()),
  /** Public key. */
  publicKey: hex3(),
  /** Role. */
  role: union([literal("admin"), literal("normal")]),
  /** Key type. */
  type: union([
    literal("p256"),
    literal("secp256k1"),
    literal("webauthnp256")
  ])
});
var WithPermissions = object({
  ...Key.shape,
  /** Represents key permissions. */
  permissions: readonly(array(Permission))
});

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/relay/schema/capabilities.js
var assetDiffs;
(function(assetDiffs2) {
  assetDiffs2.AssetDiffAsset = union([
    object({
      address: optional(union([address(), _null3()])),
      decimals: optional(union([number2(), _null3()])),
      direction: union([literal("incoming"), literal("outgoing")]),
      fiat: optional(object({
        currency: string2(),
        value: codec(string2(), number2(), {
          decode: (value) => Number(value),
          encode: (value) => String(value)
        })
      })),
      name: optional(union([string2(), _null3()])),
      symbol: string2(),
      type: literal("erc20"),
      value: bigint4()
    }),
    object({
      address: optional(union([address(), _null3()])),
      direction: union([literal("incoming"), literal("outgoing")]),
      fiat: optional(object({
        currency: string2(),
        value: codec(string2(), number2(), {
          decode: (value) => Number(value),
          encode: (value) => String(value)
        })
      })),
      name: optional(union([string2(), _null3()])),
      symbol: string2(),
      type: literal("erc721"),
      uri: string2(),
      value: bigint4()
    }),
    object({
      address: _null3(),
      decimals: optional(union([number2(), _null3()])),
      direction: union([literal("incoming"), literal("outgoing")]),
      fiat: optional(object({
        currency: string2(),
        value: codec(string2(), number2(), {
          decode: (value) => Number(value),
          encode: (value) => String(value)
        })
      })),
      symbol: string2(),
      type: _null3(),
      value: bigint4()
    })
  ]);
  assetDiffs2.Response = record(hex3(), readonly(array(readonly(tuple([address(), readonly(array(assetDiffs2.AssetDiffAsset))])))));
})(assetDiffs || (assetDiffs = {}));
var authorizeKeys;
(function(authorizeKeys2) {
  authorizeKeys2.Request = readonly(array(WithPermissions));
  authorizeKeys2.Response = readonly(array(object({
    ...WithPermissions.shape,
    /** The hash of the authorized key. */
    hash: hex3()
  })));
})(authorizeKeys || (authorizeKeys = {}));
var feeTotals;
(function(feeTotals2) {
  feeTotals2.Response = record(hex3(), object({
    currency: string2(),
    value: string2()
  }));
})(feeTotals || (feeTotals = {}));
var meta3;
(function(meta4) {
  meta4.Request = object({
    /** The address of the fee payer. */
    feePayer: optional(address()),
    /** The token to pa  for the call bundle. If `None`, defaults to native token (ETH). */
    feeToken: optional(address()),
    /** The nonce for the bundle. */
    nonce: optional(bigint4())
  });
})(meta3 || (meta3 = {}));
var requiredFunds;
(function(requiredFunds3) {
  requiredFunds3.Request = readonly(array(object({
    address: address(),
    value: bigint4()
  })));
})(requiredFunds || (requiredFunds = {}));
var revokeKeys;
(function(revokeKeys2) {
  revokeKeys2.Request = readonly(array(object({
    /** The hash of the key to revoke. */
    hash: hex3()
  })));
  revokeKeys2.Response = readonly(array(object({
    /** The hash of the revoked key. */
    hash: hex3()
  })));
})(revokeKeys || (revokeKeys = {}));

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/relay/schema/preCall.js
var PreCall = object({
  /**
   * The user's address.
   *
   * This can be set to `address(0)`, which allows it to be
   * coalesced to the parent Intent's EOA.
   */
  eoa: address(),
  /**
   * An encoded array of calls, using ERC7579 batch execution encoding.
   *
   * `abi.encode(calls)`, where `calls` is of type `Call[]`.
   * This allows for more efficient safe forwarding to the EOA.
   */
  executionData: hex3(),
  /**
   * Per delegated EOA. Same logic as the `nonce` in Intent.
   *
   * A nonce of `type(uint256).max` skips the check, incrementing,
   * and the emission of the {IntentExecuted} event.
   */
  nonce: hex3(),
  /**
   * The wrapped signature.
   *
   * `abi.encodePacked(innerSignature, keyHash, prehash)`.
   */
  signature: hex3()
});
var Context = object({
  ...PreCall.shape,
  chainId: number4()
});

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/relay/schema/intent.js
var Intent = union([
  object({
    combinedGas: bigint4(),
    encodedFundTransfers: readonly(array(hex3())),
    encodedPreCalls: readonly(array(hex3())),
    eoa: address(),
    executionData: hex3(),
    expiry: bigint4(),
    funder: address(),
    funderSignature: hex3(),
    isMultichain: boolean2(),
    nonce: bigint4(),
    payer: address(),
    paymentAmount: bigint4(),
    paymentMaxAmount: bigint4(),
    paymentRecipient: address(),
    paymentSignature: hex3(),
    paymentToken: address(),
    settler: address(),
    settlerContext: hex3(),
    signature: hex3(),
    supportedAccountImplementation: address()
  }),
  object({
    /** The combined gas limit for payment, verification, and calling the EOA. */
    combinedGas: bigint4(),
    /** Only relevant for multi chain intents. */
    encodedFundTransfers: readonly(array(hex3())),
    /**
     * Optional array of encoded Intents that will be verified and executed
     * before the validation of the overall Intent.
     *
     * A PreCall will NOT have its gas limit or payment applied.
     * The overall Intent's gas limit and payment will be applied, encompassing all its PreCalls.
     * The execution of a PreCall will check and increment the nonce in the PreCall.
     * If at any point, any PreCall cannot be verified to be correct, or fails in execution,
     * the overall Intent will revert before validation, and execute will return a non-zero error.
     * A PreCall can contain PreCalls, forming a tree structure.
     * The `executionData` tree will be executed in post-order (i.e. left -> right -> current).
     * The `encodedPreCalls` are included in the EIP712 signature, which enables execution order
     * to be enforced on-the-fly even if the nonces are from different sequences.
     */
    encodedPreCalls: readonly(array(hex3())),
    /** Users address. */
    eoa: address(),
    /**
     * An encoded array of calls, using ERC7579 batch execution encoding.
     *
     * The format is `abi.encode(calls)`, where `calls` is an array of type `Call[]`.
     * This allows for more efficient safe forwarding to the EOA.
     */
    executionData: hex3(),
    /** The expiration time of the intent. */
    expiry: bigint4(),
    /** The funder address. */
    funder: address(),
    /** The funder's signature. */
    funderSignature: hex3(),
    /** Whether the intent is a multi-chain intent. */
    isMultichain: boolean2(),
    /** Per delegated EOA.
     *
     * # Memory layout
     *
     * Each nonce has the following memory layout:
     *
     *      ,----------------------------------------------------.
     * bits | 0-191 (192 bits)                | 192-255 (64 bits)|
     *      |---------------------------------|------------------|
     * desc | sequence key                    | sequential nonce |
     *      `----------------.----------------|------------------'
     *                       |
     *                       v
     *      ,-------------------------------------.
     * bits | 0-15 (16 bits)  | 16-191 (176 bits) |
     *      |-------------------------------------|
     * desc | multichain flag | remainder         |
     *      `-------------------------------------'
     *
     * If the upper 16 bits of the sequence key is `0xc1d0`, then the EIP-712 has
     * of the Intent will exlude the chain ID.
     *
     * # Ordering
     *
     * Ordering matters within a sequence key, but not between sequence keys.
     *
     * This means that users who do not care about the order of specific intents
     * can sign their intents using a random sequence key. On the other hand, if
     * they do care about ordering, they would use the same sequence key.
     */
    nonce: bigint4(),
    /**
     * The account paying the payment token.
     * If this is `address(0)`, it defaults to the `eoa`.
     */
    payer: address(),
    /**
     * The payment recipient for the ERC20 token.
     *
     * Excluded from signature. The filler can replace this with their own address.
     *
     * This enables multiple fillers, allowing for competitive filling, better uptime.
     * If `address(0)`, the payment will be accrued by the entry point.
     */
    paymentRecipient: address(),
    /**
     * Optional payment signature to be passed into the `compensate` function
     * on the `payer`. This signature is NOT included in the EIP712 signature.
     */
    paymentSignature: hex3(),
    /** The ERC20 or native token used to pay for gas. */
    paymentToken: address(),
    /**
     * The actual pre payment amount, requested by the filler.
     * MUST be less than or equal to `prePaymentMaxAmount`.
     */
    prePaymentAmount: bigint4(),
    /**
     * The amount of the token to pay, before the call batch is executed.
     * This will be required to be less than `totalPaymentMaxAmount`.
     */
    prePaymentMaxAmount: bigint4(),
    /**
     * The address of the settler.
     */
    settler: address(),
    /**
     * Context data passed to the settler for processing attestations.
     *
     * This data is ABI-encoded and contains information needed by the settler
     * to process the multichain intent (e.g., list of chain IDs).
     */
    settlerContext: hex3(),
    /**
     * The actual total payment amount, requested by the filler.
     * MUST be less than or equal to `totalPaymentMaxAmount`
     */
    signature: hex3(),
    /**
     * Optional. If non-zero, the EOA must use `supportedAccountImplementation`.
     * Otherwise, if left as `address(0)`, any EOA implementation will be supported.
     * This field is NOT included in the EIP712 signature.
     */
    supportedAccountImplementation: address(),
    /**
     * The wrapped signature.
     *
     * The format is `abi.encodePacked(innerSignature, keyHash, prehash)` for most signatures,
     * except if it is signed by the EOA root key, in which case `abi.encodePacked(r, s, v)` is valid as well.
     */
    totalPaymentAmount: bigint4(),
    /**
     * The maximum amount of the token to pay.
     */
    totalPaymentMaxAmount: bigint4()
  })
]);
var Partial = object({
  eoa: address(),
  executionData: hex3(),
  nonce: bigint4()
});

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/relay/schema/quotes.js
var AssetDeficit = external_exports.object({
  /** Asset address. null represents the native token. */
  address: external_exports.union([address(), external_exports.null()]),
  /** Token decimals. */
  decimals: external_exports.optional(external_exports.number()),
  /** Deficit for the asset. */
  deficit: bigint4(),
  /** Fiat value of the deficit. */
  fiat: external_exports.optional(external_exports.object({ currency: external_exports.string(), value: external_exports.string() })),
  /** Token name. */
  name: external_exports.optional(external_exports.string()),
  /** Required amount for the asset. */
  required: bigint4(),
  /** Token symbol. */
  symbol: external_exports.optional(external_exports.string())
});
var Quote = external_exports.object({
  /** An optional additional authorization address, which would be used to delegate the feepayer */
  additionalAuthorization: external_exports.nullish(external_exports.object({
    address: address(),
    chainId: number4(),
    nonce: number4(),
    r: hex3(),
    s: hex3(),
    yParity: number4()
  })),
  /** Assets missing for the intent to execute. */
  assetDeficits: external_exports.optional(external_exports.array(AssetDeficit)),
  /**
   * An optional unsigned authorization item.
   * The account in `eoa` will be delegated to this address.
   */
  authorizationAddress: external_exports.optional(external_exports.union([address(), external_exports.null()])),
  /** Chain ID the quote is for. */
  chainId: number4(),
  /** The price (in wei) of ETH in the payment token. */
  ethPrice: bigint4(),
  /** Extra payment for e.g L1 DA fee that is paid on top of the execution gas. */
  extraPayment: bigint4(),
  /** The deficit of the fee token. */
  feeTokenDeficit: bigint4(),
  /** The fee estimate for the bundle in the destination chains native token. */
  intent: Intent,
  /** The `Intent` the quote is for. */
  nativeFeeEstimate: external_exports.object({
    /** The maximum fee per gas for the bundle. */
    maxFeePerGas: bigint4(),
    /** The maximum priority fee per gas for the bundle. */
    maxPriorityFeePerGas: bigint4()
  }),
  /** The orchestrator for the quote. */
  orchestrator: address(),
  /** The decimals of the payment token. */
  paymentTokenDecimals: external_exports.number(),
  /** The recommended gas limit for the bundle. */
  txGas: bigint4()
});
var Quotes = external_exports.object({
  /** Merkle root if it's a multichain workflow. */
  multiChainRoot: external_exports.optional(external_exports.union([hex3(), external_exports.null()])),
  /**
   * A quote for each intent.
   *
   * - For a single-chain workflow, this will have exactly one item, the output intent.
   * - For a multi-chain workflow, this will have multiple items, where the last one is the output
   *   intent.
   */
  quotes: external_exports.readonly(external_exports.array(Quote)).check(external_exports.minLength(1)),
  /** The time-to-live (UNIX timestamp) of the quotes. */
  ttl: external_exports.number()
});
var Signed = external_exports.object({
  ...Quotes.shape,
  hash: hex3(),
  r: hex3(),
  s: hex3(),
  v: external_exports.optional(hex3()),
  yParity: external_exports.optional(hex3())
});

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/relay/schema/token.js
var Token = object({
  address: address(),
  decimals: number2(),
  feeToken: optional(boolean2()),
  interop: optional(boolean2()),
  nativeRate: optional(bigint4()),
  symbol: string2(),
  uid: string2()
});
var Symbol2 = string2().check(_regex(/^[A-Z0-9]+$/));

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/relay/schema/rpc.js
var Authorization = object({
  address: address(),
  chainId: number4(),
  nonce: number4()
});
var SignedAuthorization = object({
  ...Authorization.shape,
  r: hex3(),
  s: hex3(),
  yParity: number4()
});
var Call = object({
  data: optional(hex3()),
  to: address(),
  value: optional(bigint4())
});
var account_getOnrampContactInfo;
(function(account_getOnrampContactInfo3) {
  account_getOnrampContactInfo3.Parameters = object({
    /** Address to get onramp status for. */
    address: address(),
    secret: string2()
  });
  account_getOnrampContactInfo3.Request = object({
    method: literal("account_getOnrampContactInfo"),
    params: readonly(tuple([account_getOnrampContactInfo3.Parameters]))
  });
  account_getOnrampContactInfo3.Response = object({
    email: optional(string2()),
    phone: optional(string2()),
    phoneVerifiedAt: optional(number2())
  });
})(account_getOnrampContactInfo || (account_getOnrampContactInfo = {}));
var account_onrampStatus;
(function(account_onrampStatus3) {
  account_onrampStatus3.Parameters = object({
    /** Address to get onramp status for. */
    address: address()
  });
  account_onrampStatus3.Request = object({
    method: literal("account_onrampStatus"),
    params: readonly(tuple([account_onrampStatus3.Parameters]))
  });
  account_onrampStatus3.Response = object({
    email: optional(number2()),
    phone: optional(number2())
  });
})(account_onrampStatus || (account_onrampStatus = {}));
var account_resendVerifyPhone;
(function(account_resendVerifyPhone3) {
  account_resendVerifyPhone3.Parameters = object({
    /** Phone to set for wallet address. */
    phone: string2(),
    /** Address to set phone. */
    walletAddress: address()
  });
  account_resendVerifyPhone3.Request = object({
    method: literal("account_resendVerifyPhone"),
    params: readonly(tuple([account_resendVerifyPhone3.Parameters]))
  });
  account_resendVerifyPhone3.Response = _null3();
})(account_resendVerifyPhone || (account_resendVerifyPhone = {}));
var account_setEmail;
(function(account_setEmail3) {
  account_setEmail3.Parameters = object({
    /** Email to set for wallet address. */
    email: string2().check(_regex(/^.*@.*$/)),
    /** Address to set email. */
    walletAddress: address()
  });
  account_setEmail3.Request = object({
    method: literal("account_setEmail"),
    params: readonly(tuple([account_setEmail3.Parameters]))
  });
  account_setEmail3.Response = _null3();
})(account_setEmail || (account_setEmail = {}));
var account_setPhone;
(function(account_setPhone3) {
  account_setPhone3.Parameters = object({
    /** Phone to set for wallet address. */
    phone: string2(),
    /** Address to set phone. */
    walletAddress: address()
  });
  account_setPhone3.Request = object({
    method: literal("account_setPhone"),
    params: readonly(tuple([account_setPhone3.Parameters]))
  });
  account_setPhone3.Response = _null3();
})(account_setPhone || (account_setPhone = {}));
var account_verifyEmail;
(function(account_verifyEmail3) {
  account_verifyEmail3.Parameters = object({
    chainId: number4(),
    email: string2(),
    signature: hex3(),
    token: string2(),
    walletAddress: address()
  });
  account_verifyEmail3.Request = object({
    method: literal("account_verifyEmail"),
    params: readonly(tuple([account_verifyEmail3.Parameters]))
  });
  account_verifyEmail3.Response = _null3();
})(account_verifyEmail || (account_verifyEmail = {}));
var account_verifyPhone;
(function(account_verifyPhone3) {
  account_verifyPhone3.Parameters = object({
    code: string2(),
    phone: string2(),
    walletAddress: address()
  });
  account_verifyPhone3.Request = object({
    method: literal("account_verifyPhone"),
    params: readonly(tuple([account_verifyPhone3.Parameters]))
  });
  account_verifyPhone3.Response = _null3();
})(account_verifyPhone || (account_verifyPhone = {}));
var health;
(function(health3) {
  health3.Request = object({
    method: literal("health"),
    params: _undefined3()
  });
  health3.Response = object({
    quoteSigner: address(),
    status: string2(),
    version: string2()
  });
})(health || (health = {}));
var wallet_addFaucetFunds;
(function(wallet_addFaucetFunds2) {
  wallet_addFaucetFunds2.Parameters = object({
    address: address(),
    chainId: number4(),
    tokenAddress: address(),
    value: bigint4()
  });
  wallet_addFaucetFunds2.Request = object({
    method: literal("wallet_addFaucetFunds"),
    params: readonly(tuple([wallet_addFaucetFunds2.Parameters]))
  });
  wallet_addFaucetFunds2.Response = object({
    message: optional(string2()),
    transactionHash: hex3()
  });
})(wallet_addFaucetFunds || (wallet_addFaucetFunds = {}));
var wallet_getAccounts;
(function(wallet_getAccounts2) {
  wallet_getAccounts2.Parameters = object({
    /** Target chain ID. */
    chainId: number4(),
    /** Key identifier. */
    id: hex3()
  });
  wallet_getAccounts2.Request = object({
    method: literal("wallet_getAccounts"),
    params: readonly(tuple([wallet_getAccounts2.Parameters]))
  });
  wallet_getAccounts2.Response = readonly(array(object({
    /** Account address. */
    address: address(),
    /** Keys authorized on the account. */
    keys: authorizeKeys.Response
  })));
})(wallet_getAccounts || (wallet_getAccounts = {}));
var wallet_getAuthorization;
(function(wallet_getAuthorization2) {
  wallet_getAuthorization2.Parameters = object({
    address: address()
  });
  wallet_getAuthorization2.Request = object({
    method: literal("wallet_getAuthorization"),
    params: readonly(tuple([wallet_getAuthorization2.Parameters]))
  });
  wallet_getAuthorization2.Response = object({
    authorization: SignedAuthorization,
    data: hex3(),
    to: address()
  });
})(wallet_getAuthorization || (wallet_getAuthorization = {}));
var wallet_getCapabilities;
(function(wallet_getCapabilities3) {
  wallet_getCapabilities3.Request = object({
    method: literal("wallet_getCapabilities"),
    params: optional(tuple([readonly(array(number2()))]))
  });
  const VersionedContract = object({
    address: address(),
    version: optional(union([string2(), _null3()]))
  });
  wallet_getCapabilities3.Response = record(hex3(), object({
    contracts: object({
      /** Account implementation address. */
      accountImplementation: VersionedContract,
      /** Account proxy address. */
      accountProxy: VersionedContract,
      /** Legacy account implementation address. */
      legacyAccountImplementations: readonly(array(VersionedContract)),
      /** Legacy orchestrator address. */
      legacyOrchestrators: readonly(array(union([
        object({
          orchestrator: VersionedContract,
          simulator: VersionedContract
        }),
        VersionedContract
      ]))),
      /** Orchestrator address. */
      orchestrator: VersionedContract,
      /** Simulator address. */
      simulator: VersionedContract
    }),
    fees: object({
      /** Fee recipient address. */
      quoteConfig: object({
        /** Sets a constant rate for the price oracle. Used for testing. */
        constantRate: optional(union([number2(), _null3()])),
        /** Gas estimate configuration. */
        gas: optional(object({
          /** Extra buffer added to Intent gas estimates. */
          intentBuffer: optional(number2()),
          /** Extra buffer added to transaction gas estimates. */
          txBuffer: optional(number2())
        })),
        /** The lifetime of a price rate. */
        rateTtl: number2(),
        /** The lifetime of a fee quote. */
        ttl: number2()
      }),
      /** Quote configuration. */
      recipient: address(),
      /** Tokens the fees can be paid in. */
      tokens: readonly(array(Token))
    })
  }));
})(wallet_getCapabilities || (wallet_getCapabilities = {}));
var wallet_getAssets;
(function(wallet_getAssets3) {
  const AssetType = union([
    literal("native"),
    literal("erc20"),
    literal("erc721"),
    string2()
  ]);
  wallet_getAssets3.Parameters = object({
    account: address(),
    assetFilter: optional(record(hex3(), readonly(array(object({
      address: union([address(), literal("native")]),
      type: AssetType
    }))))),
    assetTypeFilter: optional(readonly(array(AssetType))),
    chainFilter: optional(readonly(array(number4())))
  });
  wallet_getAssets3.Request = object({
    method: literal("wallet_getAssets"),
    params: readonly(tuple([wallet_getAssets3.Parameters]))
  });
  wallet_getAssets3.Price = object({
    currency: string2(),
    value: codec(string2(), number2(), {
      decode: (value) => Number(value),
      encode: (value) => String(value)
    })
  });
  wallet_getAssets3.Response = record(string2(), readonly(array(oneOf([
    object({
      address: address(),
      balance: bigint4(),
      metadata: nullable(object({
        decimals: number2(),
        fiat: nullish2(wallet_getAssets3.Price),
        name: string2(),
        symbol: string2()
      })),
      type: literal("erc20")
    }),
    object({
      address: nullable(literal("native")),
      balance: bigint4(),
      metadata: nullable(object({
        decimals: number2(),
        fiat: nullish2(wallet_getAssets3.Price),
        name: optional(string2()),
        symbol: optional(string2())
      })),
      type: literal("native")
    })
  ]))));
})(wallet_getAssets || (wallet_getAssets = {}));
var wallet_getCallsStatus;
(function(wallet_getCallsStatus3) {
  wallet_getCallsStatus3.Request = object({
    method: literal("wallet_getCallsStatus"),
    params: readonly(tuple([hex3()]))
  });
  wallet_getCallsStatus3.Response = object({
    id: string2(),
    receipts: optional(readonly(array(object({
      blockHash: hex3(),
      blockNumber: number4(),
      chainId: number4(),
      gasUsed: number4(),
      logs: readonly(array(object({
        address: address(),
        data: hex3(),
        topics: readonly(array(hex3()))
      }))),
      status: hex3(),
      transactionHash: hex3()
    })))),
    status: number2()
  });
})(wallet_getCallsStatus || (wallet_getCallsStatus = {}));
var wallet_getKeys;
(function(wallet_getKeys3) {
  wallet_getKeys3.Parameters = object({
    /** The address to get the keys for. */
    address: address(),
    /** Target chain IDs. */
    chainIds: optional(readonly(array(number4())))
  });
  wallet_getKeys3.Request = object({
    method: literal("wallet_getKeys"),
    params: readonly(tuple([wallet_getKeys3.Parameters]))
  });
  wallet_getKeys3.Response = record(hex3(), authorizeKeys.Response);
})(wallet_getKeys || (wallet_getKeys = {}));
var wallet_prepareCalls;
(function(wallet_prepareCalls3) {
  wallet_prepareCalls3.Capabilities = object({
    /** Keys to authorize on the account. */
    authorizeKeys: optional(authorizeKeys.Request),
    /** Metadata for the call bundle. */
    meta: meta3.Request,
    /** Whether the call bundle is to be considered a preCall. */
    preCall: optional(boolean2()),
    /** Optional preCalls to execute before signature verification. */
    preCalls: optional(readonly(array(PreCall))),
    /** Required funds on the target chain. */
    requiredFunds: optional(requiredFunds.Request),
    /** Keys to revoke on the account. */
    revokeKeys: optional(revokeKeys.Request)
  });
  wallet_prepareCalls3.ResponseCapabilities = object({
    /** Asset diff. */
    assetDiffs: optional(assetDiffs.Response),
    /** Keys authorized on the account. */
    authorizeKeys: nullish2(authorizeKeys.Response),
    /** Digest for the fee payer. */
    feePayerDigest: optional(hex3()),
    /** Fee signature. */
    feeSignature: optional(hex3()),
    /** Fee totals. */
    feeTotals: optional(feeTotals.Response),
    /** Keys revoked on the account. */
    revokeKeys: nullish2(revokeKeys.Response)
  });
  wallet_prepareCalls3.Parameters = object({
    /** Capabilities for the account. */
    calls: readonly(array(Call)),
    /** The calls to prepare. */
    capabilities: wallet_prepareCalls3.Capabilities,
    /** The chain ID of the call bundle. */
    chainId: number4(),
    /** The address of the account to prepare the calls for. */
    from: optional(address()),
    /** Key that will be used to sign the call bundle. */
    key: optional(object({
      prehash: boolean2(),
      publicKey: hex3(),
      type: Key.shape.type
    }))
  });
  wallet_prepareCalls3.Request = object({
    method: literal("wallet_prepareCalls"),
    params: readonly(tuple([wallet_prepareCalls3.Parameters]))
  });
  wallet_prepareCalls3.Response = object({
    /** Capabilities. */
    capabilities: wallet_prepareCalls3.ResponseCapabilities,
    /** Quote for the call bundle. */
    context: object({
      /** Quote for the call bundle. */
      preCall: optional(partial2(Context)),
      /** The call bundle. */
      quote: optional(partial2(Signed))
    }),
    /** Digest to sign over. */
    digest: hex3(),
    /** Key that will be used to sign the call bundle. */
    key: nullish2(object({
      prehash: boolean2(),
      publicKey: hex3(),
      type: Key.shape.type
    })),
    /** Signature of the response for verifying the integrity of Relay response. */
    signature: hex3(),
    /** EIP-712 typed data digest. */
    typedData: object({
      domain: union([
        object({
          chainId: union([number4(), number2()]),
          name: string2(),
          verifyingContract: address(),
          version: string2()
        }),
        object({})
      ]),
      message: record(string2(), unknown()),
      primaryType: string2(),
      types: record(string2(), unknown())
    })
  });
})(wallet_prepareCalls || (wallet_prepareCalls = {}));
var wallet_prepareUpgradeAccount;
(function(wallet_prepareUpgradeAccount3) {
  wallet_prepareUpgradeAccount3.Capabilities = object({
    /** Keys to authorize on the account. */
    authorizeKeys: authorizeKeys.Request
  });
  wallet_prepareUpgradeAccount3.Parameters = object({
    /** Address of the EOA to upgrade. */
    address: address(),
    /** Chain ID to initialize the account on. */
    // TODO: `u.number()`
    capabilities: wallet_prepareUpgradeAccount3.Capabilities,
    /** Capabilities. */
    chainId: optional(number2()),
    /** Contract address to delegate to. */
    delegation: address()
  });
  wallet_prepareUpgradeAccount3.Request = object({
    method: literal("wallet_prepareUpgradeAccount"),
    params: readonly(tuple([wallet_prepareUpgradeAccount3.Parameters]))
  });
  wallet_prepareUpgradeAccount3.Response = object({
    /** Capabilities. */
    capabilities: wallet_prepareUpgradeAccount3.Capabilities,
    /** Chain ID to initialize the account on. */
    chainId: number4(),
    /** Context. */
    context: object({
      /** Address of the EOA to upgrade. */
      address: address(),
      /** Unsigned authorization object to be signed by the EOA root key. */
      authorization: Authorization,
      /** Chain ID to initialize the account on. */
      chainId: number4(),
      /** Unsigned pre-call to be signed by the EOA root key. */
      preCall: PreCall
    }),
    /** Digests to sign over. */
    digests: object({
      /** Digest of the authorization object. */
      auth: hex3(),
      /** Digest of the pre-call. */
      exec: hex3()
    }),
    /** EIP-712 typed data digest. */
    typedData: object({
      domain: union([
        object({
          chainId: union([number4(), number2()]),
          name: string2(),
          verifyingContract: address(),
          version: string2()
        }),
        object({})
      ]),
      message: record(string2(), unknown()),
      primaryType: string2(),
      types: record(string2(), unknown())
    })
  });
})(wallet_prepareUpgradeAccount || (wallet_prepareUpgradeAccount = {}));
var wallet_feeTokens;
(function(wallet_feeTokens2) {
  wallet_feeTokens2.Request = object({
    method: literal("wallet_feeTokens"),
    params: optional(_undefined3())
  });
  wallet_feeTokens2.Response = record(hex3(), readonly(array(object({
    address: address(),
    decimals: number2(),
    nativeRate: optional(bigint4()),
    symbol: string2()
  }))));
})(wallet_feeTokens || (wallet_feeTokens = {}));
var wallet_sendPreparedCalls;
(function(wallet_sendPreparedCalls3) {
  wallet_sendPreparedCalls3.Parameters = object({
    /** Capabilities. */
    capabilities: optional(object({
      /** Fee signature. */
      feeSignature: optional(hex3())
    })),
    /** Quote for the call bundle. */
    context: object({
      /** The call bundle. */
      preCall: optional(partial2(Context)),
      /** Quote for the call bundle. */
      quote: optional(partial2(Signed))
    }),
    /** Key that was used to sign the call bundle. */
    key: optional(object({
      prehash: boolean2(),
      publicKey: hex3(),
      type: Key.shape.type
    })),
    /** Signature. */
    signature: hex3()
  });
  wallet_sendPreparedCalls3.Request = object({
    method: literal("wallet_sendPreparedCalls"),
    params: readonly(tuple([wallet_sendPreparedCalls3.Parameters]))
  });
  wallet_sendPreparedCalls3.Response = object({
    /** The ID of the call bundle. */
    id: hex3()
  });
})(wallet_sendPreparedCalls || (wallet_sendPreparedCalls = {}));
var wallet_upgradeAccount;
(function(wallet_upgradeAccount3) {
  wallet_upgradeAccount3.Parameters = object({
    /** Context. */
    context: object({
      /** Address of the EOA to upgrade. */
      address: address(),
      /** Unsigned authorization object to be signed by the EOA root key. */
      authorization: Authorization,
      /** Chain ID to initialize the account on. */
      chainId: number4(),
      /** Unsigned pre-call to be signed by the EOA root key. */
      preCall: PreCall
    }),
    /** Signatures of the `wallet_prepareUpgradeAccount` digests. */
    signatures: object({
      auth: hex3(),
      exec: hex3()
    })
  });
  wallet_upgradeAccount3.Request = object({
    method: literal("wallet_upgradeAccount"),
    params: readonly(tuple([wallet_upgradeAccount3.Parameters]))
  });
  wallet_upgradeAccount3.Response = _undefined3();
})(wallet_upgradeAccount || (wallet_upgradeAccount = {}));
var wallet_verifySignature;
(function(wallet_verifySignature3) {
  wallet_verifySignature3.Parameters = object({
    /** Account address. */
    address: hex3(),
    /** Chain ID of the account with the given key configured. */
    chainId: number4(),
    /** Digest of the message to verify. */
    digest: hex3(),
    /** Signature to verify. */
    signature: hex3()
  });
  wallet_verifySignature3.Request = object({
    method: literal("wallet_verifySignature"),
    params: readonly(tuple([wallet_verifySignature3.Parameters]))
  });
  wallet_verifySignature3.Response = object({
    /** Proof that can be used to verify the signature. */
    proof: nullish2(object({
      /** Address of an account (either delegated or stored) that the signature was verified against. */
      account: address(),
      /** Initialization precall. Provided, if account is a stored account which has not been delegated. */
      initPreCall: nullish2(PreCall),
      /** The key hash that signed the digest. */
      keyHash: hex3()
    })),
    /** Whether the signature is valid. */
    valid: boolean2()
  });
})(wallet_verifySignature || (wallet_verifySignature = {}));

// node_modules/@wagmi/connectors/node_modules/porto/dist/viem/internal/relayActions.js
async function getAuthorization(client, parameters) {
  try {
    const method = "wallet_getAuthorization";
    const result = await withCache(() => client.request({
      method,
      params: [
        encode2(wallet_getAuthorization.Parameters, parameters)
      ]
    }), { cacheKey: `${client.uid}.${method}.${parameters.address}` });
    return decode(wallet_getAuthorization.Response, result);
  } catch (error46) {
    parseSchemaError(error46);
    throw error46;
  }
}
async function getCapabilities(client, options = {}) {
  const chainIds = (() => {
    if (options.chainId)
      return [options.chainId];
    if (options.chainIds === "all")
      return void 0;
    if (options.chainIds)
      return options.chainIds;
    return [client.chain.id];
  })();
  try {
    const method = "wallet_getCapabilities";
    const result = await withCache(() => client.request({
      method,
      params: chainIds ? [chainIds] : void 0
    }, {
      retryCount: 0
    }), {
      cacheKey: `${client.uid}.${method}.${chainIds == null ? void 0 : chainIds.join(",")}`
    });
    const parsed = (() => {
      if (options.raw)
        return result;
      return decode(wallet_getCapabilities.Response, result);
    })();
    if (options.chainIds)
      return parsed;
    return Object.values(parsed)[0];
  } catch (error46) {
    parseSchemaError(error46);
    throw error46;
  }
}
async function getAssets(client, parameters) {
  var _a2;
  const { account, assetFilter, assetTypeFilter, chainFilter } = parameters;
  try {
    const method = "wallet_getAssets";
    const result = await client.request({
      method,
      params: [
        encode2(wallet_getAssets.Parameters, {
          account,
          assetFilter,
          assetTypeFilter,
          chainFilter
        })
      ]
    });
    const value = decode(wallet_getAssets.Response, result);
    const decoded = Object.entries(value).reduce((acc, [key, value2]) => {
      acc[toNumber(key)] = value2;
      return acc;
    }, {});
    const aggregated = {};
    for (const value2 of Object.values(decoded)) {
      for (const item of value2) {
        const key = JSON.stringify(item.metadata);
        aggregated[key] = {
          ...item,
          balance: item.balance + (((_a2 = aggregated[key]) == null ? void 0 : _a2.balance) ?? 0n)
        };
      }
    }
    return {
      ...decoded,
      "0": Object.values(aggregated)
    };
  } catch (error46) {
    parseSchemaError(error46);
    throw error46;
  }
}
async function addFaucetFunds(client, parameters) {
  const { address: address2, chain = client.chain, tokenAddress, value } = parameters;
  try {
    const method = "wallet_addFaucetFunds";
    const result = await client.request({
      method,
      params: [
        encode2(wallet_addFaucetFunds.Parameters, {
          address: address2,
          chainId: chain == null ? void 0 : chain.id,
          tokenAddress,
          value
        })
      ]
    }, {
      retryCount: 0
    });
    await new Promise((resolve) => setTimeout(resolve, 2e3));
    return result;
  } catch (error46) {
    parseSchemaError(error46);
    throw error46;
  }
}
async function getCallsStatus(client, parameters) {
  const { id } = parameters;
  try {
    const method = "wallet_getCallsStatus";
    const result = await client.request({
      method,
      params: [id]
    });
    return decode(wallet_getCallsStatus.Response, result);
  } catch (error46) {
    parseSchemaError(error46);
    throw error46;
  }
}
async function getKeys(client, parameters) {
  const { address: address2, chainIds } = parameters;
  try {
    const method = "wallet_getKeys";
    const result = await client.request({
      method,
      params: [
        encode2(wallet_getKeys.Parameters, {
          address: address2,
          chainIds
        })
      ]
    });
    return decode(wallet_getKeys.Response, result);
  } catch (error46) {
    parseSchemaError(error46);
    throw error46;
  }
}
async function health2(client) {
  const method = "health";
  const result = await withCache(() => client.request({
    method
  }), { cacheKey: `${client.uid}.${method}` });
  return decode(health.Response, result);
}
async function prepareCalls(client, parameters) {
  const { address: address2, capabilities, chain = client.chain, key } = parameters;
  const calls = parameters.calls.map((call2) => {
    return {
      data: call2.abi ? encodeData(fromAbi(call2.abi, call2.functionName), call2.args) : call2.data ?? "0x",
      to: call2.to,
      value: call2.value ?? 0n
    };
  });
  try {
    const method = "wallet_prepareCalls";
    const result = await client.request({
      method,
      params: [
        encode2(wallet_prepareCalls.Parameters, {
          calls,
          capabilities: {
            ...capabilities,
            meta: {
              ...capabilities == null ? void 0 : capabilities.meta
            }
          },
          chainId: chain == null ? void 0 : chain.id,
          from: address2,
          key: key ? {
            prehash: key.prehash,
            publicKey: key.publicKey,
            type: key.type
          } : void 0
        })
      ]
    }, {
      retryCount: 0
    });
    return Object.assign(decode(wallet_prepareCalls.Response, result), { _raw: result });
  } catch (error46) {
    parseSchemaError(error46);
    parseExecutionError(error46, { calls: parameters.calls });
    throw error46;
  }
}
async function prepareUpgradeAccount(client, parameters) {
  const { address: address2, chain = client.chain, delegation, ...capabilities } = parameters;
  try {
    const method = "wallet_prepareUpgradeAccount";
    const result = await client.request({
      method,
      params: [
        encode2(wallet_prepareUpgradeAccount.Parameters, normalizeValue({
          address: address2,
          capabilities,
          chainId: chain == null ? void 0 : chain.id,
          delegation
        }))
      ]
    }, {
      retryCount: 0
    });
    return decode(wallet_prepareUpgradeAccount.Response, result);
  } catch (error46) {
    parseSchemaError(error46);
    parseExecutionError(error46);
    throw error46;
  }
}
async function sendPreparedCalls(client, parameters) {
  const { capabilities, context, key, signature } = parameters;
  try {
    const method = "wallet_sendPreparedCalls";
    const result = await client.request({
      method,
      params: [
        encode2(wallet_sendPreparedCalls.Parameters, {
          capabilities,
          context: {
            preCall: context.preCall,
            quote: context.quote
          },
          key: key ? {
            prehash: key.prehash,
            publicKey: key.publicKey,
            type: key.type
          } : void 0,
          signature
        })
      ]
    }, {
      retryCount: 0
    });
    return decode(wallet_sendPreparedCalls.Response, result);
  } catch (error46) {
    parseSchemaError(error46);
    parseExecutionError(error46);
    throw error46;
  }
}
async function getOnrampContactInfo(client, parameters) {
  const { address: address2, secret } = parameters;
  try {
    const method = "account_getOnrampContactInfo";
    const result = await client.request({
      method,
      params: [
        encode2(account_getOnrampContactInfo.Parameters, {
          address: address2,
          secret
        })
      ]
    }, {
      retryCount: 0
    });
    return decode(account_getOnrampContactInfo.Response, result);
  } catch (error46) {
    parseSchemaError(error46);
    parseExecutionError(error46);
    throw error46;
  }
}
async function onrampStatus(client, parameters) {
  const { address: address2 } = parameters;
  try {
    const method = "account_onrampStatus";
    const result = await client.request({
      method,
      params: [
        encode2(account_onrampStatus.Parameters, {
          address: address2
        })
      ]
    }, {
      retryCount: 0
    });
    return decode(account_onrampStatus.Response, result);
  } catch (error46) {
    parseSchemaError(error46);
    parseExecutionError(error46);
    throw error46;
  }
}
async function resendVerifyPhone(client, parameters) {
  const { phone, walletAddress } = parameters;
  try {
    const method = "account_resendVerifyPhone";
    const result = await client.request({
      method,
      params: [
        encode2(account_resendVerifyPhone.Parameters, {
          phone,
          walletAddress
        })
      ]
    }, {
      retryCount: 0
    });
    return decode(account_resendVerifyPhone.Response, result);
  } catch (error46) {
    parseSchemaError(error46);
    parseExecutionError(error46);
    throw error46;
  }
}
async function setEmail(client, parameters) {
  const { email: email3, walletAddress } = parameters;
  try {
    const method = "account_setEmail";
    const result = await client.request({
      method,
      params: [
        encode2(account_setEmail.Parameters, {
          email: email3,
          walletAddress
        })
      ]
    }, {
      retryCount: 0
    });
    return decode(account_setEmail.Response, result);
  } catch (error46) {
    parseSchemaError(error46);
    parseExecutionError(error46);
    throw error46;
  }
}
async function setPhone(client, parameters) {
  const { phone, walletAddress } = parameters;
  try {
    const method = "account_setPhone";
    const result = await client.request({
      method,
      params: [
        encode2(account_setPhone.Parameters, {
          phone,
          walletAddress
        })
      ]
    }, {
      retryCount: 0
    });
    return decode(account_setPhone.Response, result);
  } catch (error46) {
    parseSchemaError(error46);
    parseExecutionError(error46);
    throw error46;
  }
}
async function upgradeAccount(client, parameters) {
  const { context, signatures } = parameters;
  try {
    const method = "wallet_upgradeAccount";
    await client.request({
      method,
      params: [
        encode2(wallet_upgradeAccount.Parameters, {
          context,
          signatures
        })
      ]
    }, {
      retryCount: 0
    });
  } catch (error46) {
    parseSchemaError(error46);
    parseExecutionError(error46);
    throw error46;
  }
}
async function verifyEmail(client, parameters) {
  const { chainId, email: email3, signature, token, walletAddress } = parameters;
  try {
    const method = "account_verifyEmail";
    const result = await client.request({
      method,
      params: [
        encode2(account_verifyEmail.Parameters, {
          chainId,
          email: email3,
          signature,
          token,
          walletAddress
        })
      ]
    }, {
      retryCount: 0
    });
    return decode(account_verifyEmail.Response, result);
  } catch (error46) {
    parseSchemaError(error46);
    parseExecutionError(error46);
    throw error46;
  }
}
async function verifyPhone(client, parameters) {
  const { code: code2, phone, walletAddress } = parameters;
  try {
    const method = "account_verifyPhone";
    const result = await client.request({
      method,
      params: [
        encode2(account_verifyPhone.Parameters, {
          code: code2,
          phone,
          walletAddress
        })
      ]
    }, {
      retryCount: 0
    });
    return decode(account_verifyPhone.Response, result);
  } catch (error46) {
    parseSchemaError(error46);
    parseExecutionError(error46);
    throw error46;
  }
}
async function verifyPrepareCallsResponse(client, parameters) {
  const { signature } = parameters;
  const { signature: _, capabilities: { feeSignature: __, ...capabilities }, ...response } = parameters.response;
  const sorted = sortKeys({ capabilities, ...response });
  const payload = keccak256(fromString2(JSON.stringify(sorted)));
  const address2 = recoverAddress({
    payload,
    signature: fromHex2(signature)
  });
  const { quoteSigner } = await health2(client);
  return address2 === quoteSigner;
}
async function verifySignature(client, parameters) {
  const { address: address2, chain = client.chain, digest, signature } = parameters;
  try {
    async function fallback2() {
      const valid = await verifyHash(client, {
        address: address2,
        hash: digest,
        signature
      });
      return {
        proof: null,
        valid
      };
    }
    const method = "wallet_verifySignature";
    const result = await (async () => {
      const result2 = await client.request({
        method,
        params: [
          encode2(wallet_verifySignature.Parameters, {
            address: address2,
            chainId: chain == null ? void 0 : chain.id,
            digest,
            signature
          })
        ]
      }, {
        retryCount: 0
      }).catch(fallback2);
      if (result2.valid)
        return result2;
      return fallback2();
    })();
    return decode(wallet_verifySignature.Response, result);
  } catch (error46) {
    parseSchemaError(error46);
    throw error46;
  }
}
function parseExecutionError(e, { calls } = {}) {
  if (!(e instanceof BaseError))
    return;
  const getAbiError = (error47) => {
    try {
      if (error47.name === "ContractFunctionExecutionError") {
        const data2 = error47.cause.name === "ContractFunctionRevertedError" ? error47.cause.data : void 0;
        if (data2)
          return fromAbi2([data2.abiItem], data2.errorName);
      }
      const cause = error47.walk((e2) => !(e2 instanceof Error) && e2.code === 3);
      if (!cause)
        return void 0;
      const { data, message } = cause;
      if (data === "0xd0d5039b")
        return from6("error Unauthorized()");
      return {
        inputs: [],
        name: (message ?? data).split("(")[0],
        type: "error"
      };
    } catch {
      return void 0;
    }
  };
  const error46 = getExecuteError(e, {
    calls: calls ?? []
  });
  const abiError = getAbiError(error46);
  if (error46 === e && !abiError)
    return;
  throw new ExecutionError(Object.assign(error46, { abiError }));
}
function sortKeys(value) {
  if (typeof value === "object" && value !== null) {
    if (Array.isArray(value))
      return value.map(sortKeys);
    const result = {};
    for (const key of Object.keys(value).sort())
      result[key] = sortKeys(value[key]);
    return result;
  }
  return value;
}
function parseSchemaError(e) {
  if (e.name === "$ZodError")
    throw toValidationError(e);
}
var ExecutionError = class extends BaseError2 {
  constructor(cause) {
    super("An error occurred while executing calls.", {
      cause,
      metaMessages: [cause.abiError && "Reason: " + cause.abiError.name].filter(Boolean)
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Rpc.ExecutionError"
    });
    Object.defineProperty(this, "abiError", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abiError = cause.abiError;
  }
};

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/Transport.js
var Transport_exports = {};
__export(Transport_exports, {
  fallback: () => fallback,
  http: () => http,
  relayProxy: () => relayProxy,
  relayUrls: () => relayUrls,
  webSocket: () => webSocket
});
var relayUrls = {
  anvil: { http: "http://localhost:9119" },
  prod: { http: "https://rpc.porto.sh" },
  stg: { http: "https://stg-rpc.porto.sh" }
};
function relayProxy(transports) {
  return (config2) => {
    const transport_public = transports.public(config2);
    const transport_relay = transports.relay(config2);
    return createTransport({
      key: relayProxy.type,
      name: "Relay Proxy",
      async request({ method, params }, options) {
        if (isRelay(method))
          return transport_relay.request({ method, params }, options);
        return transport_public.request({ method, params }, options);
      },
      type: relayProxy.type
    });
  };
}
(function(relayProxy2) {
  relayProxy2.type = "relayProxy";
})(relayProxy || (relayProxy = {}));
function isRelay(method) {
  if (method.startsWith("wallet_"))
    return true;
  if (method.startsWith("account_"))
    return true;
  if (method === "health")
    return true;
  return false;
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/viem/RelayClient.js
var clientCache = /* @__PURE__ */ new Map();
function fromPorto(porto, config2 = {}) {
  const { config: config_, id, store } = porto._internal;
  const { chains, relay: relay2 } = config_;
  const state = store.getState();
  const chainId = config2.chainId ?? state.chainIds[0];
  const chain = chains.find((chain2) => chain2.id === chainId);
  if (!chain)
    throw new Error([
      "Could not find a compatible Porto chain on the given chain configuration.",
      "",
      `Provided chains: [${chains.map((chain2) => `${chain2.name} (id: ${chain2.id})`).join(", ")}]`,
      `Needed chain (id): ${chainId}`,
      "Please add this chain (id) to your chain configuration."
    ].join("\n"));
  const transport = relayProxy({
    public: config_.transports[chain.id] ?? fallback(chain.rpcUrls.default.http.map((url2) => http(url2))),
    relay: relay2
  });
  const key = [id, stringify(chain)].filter(Boolean).join(":");
  if (clientCache.has(key))
    return clientCache.get(key);
  const client = createClient({
    ...config2,
    chain,
    pollingInterval: 1e3,
    transport
  });
  clientCache.set(key, client);
  return client;
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/schema/key.js
var Base = object({
  /** Chain ID the key belongs to. If not provided, the key is valid on all chains. */
  chainId: optional(number4()),
  /** The expiry of the key. */
  expiry: number4(),
  /** The hash of the key. */
  hash: hex3(),
  /** The id of the key. */
  id: hex3(),
  /** Whether digests should be prehashed. */
  prehash: optional(boolean2()),
  /** Public key. */
  publicKey: hex3(),
  /** Role. */
  role: union([literal("admin"), literal("session")]),
  /** Key type. */
  type: union([
    literal("address"),
    literal("p256"),
    literal("secp256k1"),
    literal("webauthn-p256")
  ])
});
var CallPermissions = readonly(array(oneOf([
  object({
    signature: string2(),
    to: address()
  }),
  object({
    signature: string2()
  }),
  object({
    to: address()
  })
])).check(_minLength(1)));
var FeeToken = object({
  limit: union([
    templateLiteral([number2(), ".", number2()]),
    templateLiteral([number2()])
  ]).check(_regex(/^\d+(\.\d+)?$/)),
  symbol: optional(union([literal("native"), Symbol2]))
});
var SignatureVerificationPermission = object({
  addresses: readonly(array(address()))
});
var SpendPermissions = readonly(array(object({
  limit: bigint4(),
  period: union([
    literal("minute"),
    literal("hour"),
    literal("day"),
    literal("week"),
    literal("month"),
    literal("year")
  ]),
  token: optional(address())
})));
var Permissions = object({
  calls: optional(CallPermissions),
  signatureVerification: optional(SignatureVerificationPermission),
  spend: optional(SpendPermissions)
});
var WithPermissions2 = object({
  ...Base.shape,
  feeToken: optional(nullable(FeeToken)),
  permissions: optional(Permissions)
});

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/schema/permissions.js
var Permissions2 = object({
  address: address(),
  chainId: optional(number4()),
  expiry: number2(),
  id: hex3(),
  key: pick2(Base, { publicKey: true, type: true }),
  permissions: object({
    calls: CallPermissions,
    signatureVerification: optional(SignatureVerificationPermission),
    spend: optional(SpendPermissions)
  })
});
var Request = object({
  address: optional(address()),
  chainId: optional(number4()),
  expiry: number2().check(_gte(1)),
  feeToken: nullable(FeeToken),
  key: optional(pick2(Base, { publicKey: true, type: true })),
  permissions: object({
    calls: CallPermissions,
    signatureVerification: optional(SignatureVerificationPermission),
    spend: optional(SpendPermissions)
  })
});

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/permissions.js
var Schema = Permissions2;
function fromKey(key, options) {
  const { chainId, expiry, permissions: permissions2, id, publicKey, type } = key;
  const { address: address2 } = options;
  return {
    address: address2,
    chainId,
    expiry,
    id,
    key: {
      publicKey,
      type
    },
    permissions: permissions2 ?? {}
  };
}
function toKey(permissions2) {
  const { chainId, expiry, key } = permissions2;
  return from11({
    chainId,
    expiry,
    permissions: permissions2.permissions ?? {},
    publicKey: key.publicKey,
    role: "session",
    type: key.type
  });
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/schema/capabilities.js
var atomic;
(function(atomic2) {
  atomic2.GetCapabilitiesResponse = object({
    status: union([literal("supported"), literal("unsupported")])
  });
})(atomic || (atomic = {}));
var createAccount;
(function(createAccount3) {
  createAccount3.Request = union([
    boolean2(),
    object({
      chainId: optional(number4()),
      label: optional(string2())
    })
  ]);
})(createAccount || (createAccount = {}));
var signInWithEthereum;
(function(signInWithEthereum2) {
  signInWithEthereum2.Request = oneOf([
    /** Standard EIP-4361 request object. */
    object({
      chainId: optional(number2()),
      domain: optional(string2()),
      expirationTime: optional(date2()),
      issuedAt: optional(date2()),
      nonce: string2(),
      notBefore: optional(date2()),
      requestId: optional(string2()),
      resources: optional(readonly(array(string2()))),
      scheme: optional(string2()),
      statement: optional(string2()),
      uri: optional(string2()),
      version: optional(literal("1"))
    }),
    /**
     * EIP-4361 request object with an additional `authUrl` field, used
     * to fetch and infer the `nonce`.
     */
    object({
      authUrl: union([
        string2(),
        object({
          logout: string2(),
          nonce: string2(),
          verify: string2()
        })
      ]),
      chainId: optional(number4()),
      domain: optional(string2()),
      expirationTime: optional(date2()),
      issuedAt: optional(date2()),
      notBefore: optional(date2()),
      requestId: optional(string2()),
      resources: optional(readonly(array(string2()))),
      scheme: optional(string2()),
      statement: optional(string2()),
      uri: optional(string2()),
      version: optional(literal("1"))
    })
  ]);
  signInWithEthereum2.Response = object({
    message: string2(),
    signature: hex3(),
    token: optional(string2())
  });
})(signInWithEthereum || (signInWithEthereum = {}));
var feeToken;
(function(feeToken2) {
  feeToken2.GetCapabilitiesResponse = object({
    supported: boolean2(),
    tokens: readonly(array(Token))
  });
  feeToken2.Request = union([Symbol2, address()]);
})(feeToken || (feeToken = {}));
var grantPermissions;
(function(grantPermissions2) {
  grantPermissions2.Request = Request;
})(grantPermissions || (grantPermissions = {}));
var merchant;
(function(merchant2) {
  merchant2.GetCapabilitiesResponse = object({
    supported: boolean2()
  });
})(merchant || (merchant = {}));
var permissions;
(function(permissions2) {
  permissions2.GetCapabilitiesResponse = object({
    supported: boolean2()
  });
  permissions2.Request = object({
    id: optional(union([hex3(), _null3()]))
  });
  permissions2.Response = readonly(array(Permissions2));
})(permissions || (permissions = {}));
var preCalls;
(function(preCalls2) {
  preCalls2.Request = readonly(array(object({
    context: unknown(),
    signature: hex3()
  })));
  preCalls2.Response = preCalls2.Request;
})(preCalls || (preCalls = {}));
var merchantUrl;
(function(merchantUrl2) {
  merchantUrl2.Request = string2();
})(merchantUrl || (merchantUrl = {}));
var requiredFunds2;
(function(requiredFunds3) {
  requiredFunds3.GetCapabilitiesResponse = object({
    supported: boolean2(),
    tokens: readonly(array(Token))
  });
  requiredFunds3.Request = readonly(array(oneOf([
    object({
      address: address(),
      value: bigint4()
    }),
    object({
      symbol: Symbol2,
      value: union([
        templateLiteral([number2(), ".", number2()]),
        templateLiteral([number2()])
      ]).check(_regex(/^\d+(\.\d+)?$/))
    })
  ])));
})(requiredFunds2 || (requiredFunds2 = {}));

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/schema/rpc.js
var KeyWithCredentialId = object({
  ...pick2(Base, { id: true, publicKey: true, type: true }).shape,
  credentialId: optional(string2()),
  privateKey: optional(any())
});
var account_getOnrampContactInfo2;
(function(account_getOnrampContactInfo3) {
  account_getOnrampContactInfo3.Parameters = object({
    address: address(),
    secret: string2()
  });
  account_getOnrampContactInfo3.Request = object({
    method: literal("account_getOnrampContactInfo"),
    params: readonly(tuple([account_getOnrampContactInfo3.Parameters]))
  });
  account_getOnrampContactInfo3.Response = object({
    email: optional(string2()),
    phone: optional(string2()),
    phoneVerifiedAt: optional(number2())
  });
})(account_getOnrampContactInfo2 || (account_getOnrampContactInfo2 = {}));
var account_onrampStatus2;
(function(account_onrampStatus3) {
  account_onrampStatus3.Parameters = object({
    address: address()
  });
  account_onrampStatus3.Request = object({
    method: literal("account_onrampStatus"),
    params: readonly(tuple([account_onrampStatus3.Parameters]))
  });
  account_onrampStatus3.Response = object({
    email: optional(number2()),
    phone: optional(number2())
  });
})(account_onrampStatus2 || (account_onrampStatus2 = {}));
var account_resendVerifyPhone2;
(function(account_resendVerifyPhone3) {
  account_resendVerifyPhone3.Parameters = object({
    email: string2(),
    walletAddress: address()
  });
  account_resendVerifyPhone3.Request = object({
    method: literal("account_resendVerifyPhone"),
    params: readonly(tuple([account_resendVerifyPhone3.Parameters]))
  });
  account_resendVerifyPhone3.Response = _null3();
})(account_resendVerifyPhone2 || (account_resendVerifyPhone2 = {}));
var account_setEmail2;
(function(account_setEmail3) {
  account_setEmail3.Parameters = object({
    email: string2(),
    walletAddress: address()
  });
  account_setEmail3.Request = object({
    method: literal("account_setEmail"),
    params: readonly(tuple([account_setEmail3.Parameters]))
  });
  account_setEmail3.Response = _null3();
})(account_setEmail2 || (account_setEmail2 = {}));
var account_setPhone2;
(function(account_setPhone3) {
  account_setPhone3.Parameters = object({
    email: string2(),
    walletAddress: address()
  });
  account_setPhone3.Request = object({
    method: literal("account_setPhone"),
    params: readonly(tuple([account_setPhone3.Parameters]))
  });
  account_setPhone3.Response = _null3();
})(account_setPhone2 || (account_setPhone2 = {}));
var account_verifyEmail2;
(function(account_verifyEmail3) {
  account_verifyEmail3.Parameters = object({
    chainId: number4(),
    email: string2(),
    token: string2(),
    walletAddress: address()
  });
  account_verifyEmail3.Request = object({
    method: literal("account_verifyEmail"),
    params: readonly(tuple([account_verifyEmail3.Parameters]))
  });
  account_verifyEmail3.Response = _null3();
})(account_verifyEmail2 || (account_verifyEmail2 = {}));
var account_verifyPhone2;
(function(account_verifyPhone3) {
  account_verifyPhone3.Parameters = object({
    code: string2(),
    phone: string2(),
    walletAddress: address()
  });
  account_verifyPhone3.Request = object({
    method: literal("account_verifyPhone"),
    params: readonly(tuple([account_verifyPhone3.Parameters]))
  });
  account_verifyPhone3.Response = _null3();
})(account_verifyPhone2 || (account_verifyPhone2 = {}));
var wallet_addFunds;
(function(wallet_addFunds2) {
  wallet_addFunds2.Parameters = object({
    address: optional(address()),
    chainId: optional(number4()),
    token: optional(address()),
    value: optional(string2())
  });
  wallet_addFunds2.Request = object({
    method: literal("wallet_addFunds"),
    params: readonly(tuple([wallet_addFunds2.Parameters]))
  });
  wallet_addFunds2.Response = object({
    id: hex3()
  });
})(wallet_addFunds || (wallet_addFunds = {}));
var eth_accounts;
(function(eth_accounts2) {
  eth_accounts2.Request = object({
    method: literal("eth_accounts"),
    params: optional(unknown())
  });
  eth_accounts2.Response = readonly(array(address()));
})(eth_accounts || (eth_accounts = {}));
var eth_chainId;
(function(eth_chainId2) {
  eth_chainId2.Request = object({
    method: literal("eth_chainId"),
    params: optional(unknown())
  });
  eth_chainId2.Response = hex3();
})(eth_chainId || (eth_chainId = {}));
var eth_requestAccounts;
(function(eth_requestAccounts2) {
  eth_requestAccounts2.Request = object({
    method: literal("eth_requestAccounts"),
    params: optional(unknown())
  });
  eth_requestAccounts2.Response = readonly(array(address()));
})(eth_requestAccounts || (eth_requestAccounts = {}));
var eth_sendTransaction;
(function(eth_sendTransaction2) {
  eth_sendTransaction2.Request = object({
    method: literal("eth_sendTransaction"),
    params: readonly(tuple([
      object({
        capabilities: optional(object({
          feeToken: optional(feeToken.Request),
          merchantUrl: optional(merchantUrl.Request),
          preCalls: optional(preCalls.Request)
        })),
        chainId: optional(number4()),
        data: optional(hex3()),
        from: optional(address()),
        to: address(),
        value: optional(bigint4())
      })
    ]))
  });
  eth_sendTransaction2.Response = hex3();
})(eth_sendTransaction || (eth_sendTransaction = {}));
var eth_signTypedData_v4;
(function(eth_signTypedData_v42) {
  eth_signTypedData_v42.Request = object({
    method: literal("eth_signTypedData_v4"),
    params: readonly(tuple([address(), string2()]))
  });
  eth_signTypedData_v42.Response = hex3();
})(eth_signTypedData_v4 || (eth_signTypedData_v4 = {}));
var wallet_getAdmins;
(function(wallet_getAdmins2) {
  wallet_getAdmins2.Parameters = object({
    address: optional(address()),
    chainId: optional(number4())
  });
  wallet_getAdmins2.Request = object({
    method: literal("wallet_getAdmins"),
    params: optional(readonly(tuple([wallet_getAdmins2.Parameters])))
  });
  wallet_getAdmins2.Key = KeyWithCredentialId;
  wallet_getAdmins2.Response = object({
    address: address(),
    chainId: number4(),
    keys: readonly(array(wallet_getAdmins2.Key))
  });
})(wallet_getAdmins || (wallet_getAdmins = {}));
var wallet_grantAdmin;
(function(wallet_grantAdmin2) {
  wallet_grantAdmin2.Capabilities = object({
    feeToken: optional(feeToken.Request)
  });
  wallet_grantAdmin2.Parameters = object({
    /** Address of the account to authorize the admin for. */
    address: optional(address()),
    /** Capabilities. */
    capabilities: optional(wallet_grantAdmin2.Capabilities),
    /** Chain ID. */
    chainId: optional(number4()),
    /** Admin Key to authorize. */
    key: pick2(Base, { publicKey: true, type: true })
  });
  wallet_grantAdmin2.Request = object({
    method: literal("wallet_grantAdmin"),
    params: readonly(tuple([wallet_grantAdmin2.Parameters]))
  });
  wallet_grantAdmin2.Response = object({
    address: address(),
    chainId: number4(),
    key: wallet_getAdmins.Key
  });
})(wallet_grantAdmin || (wallet_grantAdmin = {}));
var wallet_grantPermissions;
(function(wallet_grantPermissions2) {
  wallet_grantPermissions2.Parameters = Request;
  wallet_grantPermissions2.Request = object({
    method: literal("wallet_grantPermissions"),
    params: readonly(tuple([wallet_grantPermissions2.Parameters]))
  });
  wallet_grantPermissions2.ResponseCapabilities = object({
    preCalls: optional(preCalls.Response)
  });
  wallet_grantPermissions2.Response = object({
    ...Permissions2.shape,
    capabilities: optional(any())
  });
})(wallet_grantPermissions || (wallet_grantPermissions = {}));
var wallet_getAccountVersion;
(function(wallet_getAccountVersion2) {
  wallet_getAccountVersion2.Parameters = object({
    address: optional(address())
  });
  wallet_getAccountVersion2.Request = object({
    method: literal("wallet_getAccountVersion"),
    params: optional(readonly(tuple([wallet_getAccountVersion2.Parameters])))
  });
  wallet_getAccountVersion2.Response = object({
    current: string2(),
    latest: string2()
  });
})(wallet_getAccountVersion || (wallet_getAccountVersion = {}));
var wallet_getPermissions;
(function(wallet_getPermissions2) {
  wallet_getPermissions2.Parameters = object({
    address: optional(address()),
    chainIds: optional(readonly(array(number4())))
  });
  wallet_getPermissions2.Request = object({
    method: literal("wallet_getPermissions"),
    params: optional(readonly(tuple([wallet_getPermissions2.Parameters])))
  });
  wallet_getPermissions2.Response = permissions.Response;
})(wallet_getPermissions || (wallet_getPermissions = {}));
var wallet_revokeAdmin;
(function(wallet_revokeAdmin2) {
  wallet_revokeAdmin2.Capabilities = object({
    feeToken: optional(feeToken.Request)
  });
  wallet_revokeAdmin2.Parameters = object({
    address: optional(address()),
    capabilities: optional(wallet_revokeAdmin2.Capabilities),
    chainId: optional(number4()),
    id: hex3()
  });
  wallet_revokeAdmin2.Request = object({
    method: literal("wallet_revokeAdmin"),
    params: readonly(tuple([wallet_revokeAdmin2.Parameters]))
  });
  wallet_revokeAdmin2.Response = void 0;
})(wallet_revokeAdmin || (wallet_revokeAdmin = {}));
var wallet_revokePermissions;
(function(wallet_revokePermissions2) {
  wallet_revokePermissions2.Capabilities = object({
    feeToken: optional(feeToken.Request)
  });
  wallet_revokePermissions2.Parameters = object({
    address: optional(address()),
    capabilities: optional(wallet_revokePermissions2.Capabilities),
    id: hex3()
  });
  wallet_revokePermissions2.Request = object({
    method: literal("wallet_revokePermissions"),
    params: readonly(tuple([wallet_revokePermissions2.Parameters]))
  });
  wallet_revokePermissions2.Response = void 0;
})(wallet_revokePermissions || (wallet_revokePermissions = {}));
var wallet_switchEthereumChain;
(function(wallet_switchEthereumChain2) {
  wallet_switchEthereumChain2.Request = object({
    method: literal("wallet_switchEthereumChain"),
    params: readonly(tuple([
      object({
        chainId: hex3()
      })
    ]))
  });
})(wallet_switchEthereumChain || (wallet_switchEthereumChain = {}));
var wallet_upgradeAccount2;
(function(wallet_upgradeAccount3) {
  wallet_upgradeAccount3.Parameters = object({
    context: unknown(),
    signatures: object({
      auth: hex3(),
      exec: hex3()
    })
  });
  wallet_upgradeAccount3.Request = object({
    method: literal("wallet_upgradeAccount"),
    params: readonly(tuple([wallet_upgradeAccount3.Parameters]))
  });
  wallet_upgradeAccount3.ResponseCapabilities = object({
    admins: optional(readonly(array(wallet_getAdmins.Key))),
    permissions: optional(permissions.Response)
  });
  wallet_upgradeAccount3.Response = object({
    address: address(),
    capabilities: optional(wallet_upgradeAccount3.ResponseCapabilities)
  });
})(wallet_upgradeAccount2 || (wallet_upgradeAccount2 = {}));
var personal_sign;
(function(personal_sign2) {
  personal_sign2.Request = object({
    method: literal("personal_sign"),
    params: readonly(tuple([hex3(), address()]))
  });
  personal_sign2.Response = hex3();
})(personal_sign || (personal_sign = {}));
var porto_ping;
(function(porto_ping2) {
  porto_ping2.Request = object({
    method: literal("porto_ping"),
    params: optional(_undefined3())
  });
  porto_ping2.Response = literal("pong");
})(porto_ping || (porto_ping = {}));
var wallet_connect;
(function(wallet_connect2) {
  wallet_connect2.Capabilities = object({
    createAccount: optional(createAccount.Request),
    email: optional(boolean2()),
    grantAdmins: optional(readonly(array(pick2(Base, { publicKey: true, type: true })))),
    grantPermissions: optional(grantPermissions.Request),
    preCalls: optional(preCalls.Request),
    selectAccount: optional(union([
      boolean2(),
      object({
        address: address(),
        key: optional(object({
          credentialId: optional(string2()),
          publicKey: hex3()
        }))
      })
    ])),
    signInWithEthereum: optional(signInWithEthereum.Request)
  });
  wallet_connect2.Parameters = object({
    capabilities: optional(wallet_connect2.Capabilities),
    chainIds: optional(readonly(array(number4())))
  });
  wallet_connect2.Request = object({
    method: literal("wallet_connect"),
    params: optional(readonly(tuple([wallet_connect2.Parameters])))
  });
  wallet_connect2.ResponseCapabilities = object({
    admins: optional(readonly(array(object({
      ...pick2(Base, { id: true, publicKey: true, type: true }).shape,
      credentialId: optional(string2())
    })))),
    permissions: optional(permissions.Response),
    preCalls: optional(preCalls.Response),
    signInWithEthereum: optional(signInWithEthereum.Response)
  });
  wallet_connect2.Response = object({
    accounts: readonly(array(object({
      address: address(),
      capabilities: optional(wallet_connect2.ResponseCapabilities)
    }))),
    chainIds: readonly(array(number4()))
  });
})(wallet_connect || (wallet_connect = {}));
var wallet_disconnect;
(function(wallet_disconnect2) {
  wallet_disconnect2.Request = object({
    method: literal("wallet_disconnect"),
    params: optional(unknown())
  });
  wallet_disconnect2.Response = void 0;
})(wallet_disconnect || (wallet_disconnect = {}));
var wallet_getAssets2;
(function(wallet_getAssets3) {
  wallet_getAssets3.Parameters = wallet_getAssets.Parameters;
  wallet_getAssets3.Request = wallet_getAssets.Request;
  wallet_getAssets3.Response = wallet_getAssets.Response;
})(wallet_getAssets2 || (wallet_getAssets2 = {}));
var wallet_getCallsStatus2;
(function(wallet_getCallsStatus3) {
  wallet_getCallsStatus3.Request = object({
    method: literal("wallet_getCallsStatus"),
    params: tuple([hex3()])
  });
  wallet_getCallsStatus3.Response = object({
    atomic: boolean2(),
    chainId: number4(),
    id: string2(),
    receipts: optional(readonly(array(object({
      blockHash: hex3(),
      blockNumber: hex3(),
      gasUsed: hex3(),
      logs: readonly(array(object({
        address: address(),
        data: hex3(),
        topics: readonly(array(hex3()))
      }))),
      status: hex3(),
      transactionHash: hex3()
    })))),
    status: number2(),
    version: string2()
  });
})(wallet_getCallsStatus2 || (wallet_getCallsStatus2 = {}));
var wallet_getCapabilities2;
(function(wallet_getCapabilities3) {
  wallet_getCapabilities3.Request = object({
    method: literal("wallet_getCapabilities"),
    params: optional(union([
      readonly(tuple([union([hex3(), _undefined3()])])),
      readonly(tuple([
        union([hex3(), _undefined3()]),
        readonly(array(number4()))
      ]))
    ]))
  });
  wallet_getCapabilities3.Response = record(hex3(), object({
    atomic: atomic.GetCapabilitiesResponse,
    feeToken: feeToken.GetCapabilitiesResponse,
    merchant: merchant.GetCapabilitiesResponse,
    permissions: permissions.GetCapabilitiesResponse,
    requiredFunds: requiredFunds2.GetCapabilitiesResponse
  }));
})(wallet_getCapabilities2 || (wallet_getCapabilities2 = {}));
var wallet_getKeys2;
(function(wallet_getKeys3) {
  wallet_getKeys3.Parameters = object({
    address: address(),
    chainIds: optional(readonly(array(number4())))
  });
  wallet_getKeys3.Request = object({
    method: literal("wallet_getKeys"),
    params: readonly(tuple([wallet_getKeys3.Parameters]))
  });
  wallet_getKeys3.Response = readonly(array(WithPermissions2));
})(wallet_getKeys2 || (wallet_getKeys2 = {}));
var wallet_prepareCalls2;
(function(wallet_prepareCalls3) {
  wallet_prepareCalls3.Capabilities = object({
    feeToken: optional(feeToken.Request),
    merchantUrl: optional(merchantUrl.Request),
    permissions: optional(permissions.Request),
    preCalls: optional(preCalls.Request),
    requiredFunds: optional(requiredFunds2.Request)
  });
  wallet_prepareCalls3.Parameters = object({
    calls: readonly(array(object({
      data: optional(hex3()),
      to: address(),
      value: optional(bigint4())
    }))),
    capabilities: optional(wallet_prepareCalls3.Capabilities),
    chainId: optional(number4()),
    from: optional(address()),
    key: optional(pick2(Base, { prehash: true, publicKey: true, type: true })),
    version: optional(string2())
  });
  wallet_prepareCalls3.Request = object({
    method: literal("wallet_prepareCalls"),
    params: readonly(tuple([wallet_prepareCalls3.Parameters]))
  });
  wallet_prepareCalls3.Response = object({
    capabilities: optional(object({
      ...wallet_prepareCalls.ResponseCapabilities.shape,
      quote: optional(Signed)
    })),
    chainId: hex3(),
    context: object({
      account: object({
        address: address()
      }),
      calls: wallet_prepareCalls3.Parameters.shape.calls,
      nonce: bigint4(),
      quote: optional(partial2(Signed))
    }),
    digest: hex3(),
    key: pick2(Base, { prehash: true, publicKey: true, type: true }),
    typedData: object({
      domain: union([
        object({
          chainId: number4(),
          name: string2(),
          verifyingContract: address(),
          version: string2()
        }),
        object({})
      ]),
      message: record(string2(), unknown()),
      primaryType: string2(),
      types: record(string2(), unknown())
    })
  });
})(wallet_prepareCalls2 || (wallet_prepareCalls2 = {}));
var wallet_prepareUpgradeAccount2;
(function(wallet_prepareUpgradeAccount3) {
  wallet_prepareUpgradeAccount3.Capabilities = object({
    ...wallet_connect.Capabilities.shape,
    label: optional(string2())
  });
  wallet_prepareUpgradeAccount3.Parameters = object({
    address: address(),
    capabilities: optional(wallet_prepareUpgradeAccount3.Capabilities),
    chainId: optional(number4())
  });
  wallet_prepareUpgradeAccount3.Request = object({
    method: literal("wallet_prepareUpgradeAccount"),
    params: readonly(tuple([wallet_prepareUpgradeAccount3.Parameters]))
  });
  wallet_prepareUpgradeAccount3.Response = object({
    context: unknown(),
    digests: object({
      auth: hex3(),
      exec: hex3()
    })
  });
})(wallet_prepareUpgradeAccount2 || (wallet_prepareUpgradeAccount2 = {}));
var wallet_sendCalls;
(function(wallet_sendCalls2) {
  wallet_sendCalls2.Capabilities = wallet_prepareCalls2.Capabilities;
  wallet_sendCalls2.Request = object({
    method: literal("wallet_sendCalls"),
    params: readonly(tuple([omit2(wallet_prepareCalls2.Parameters, { key: true })]))
  });
  wallet_sendCalls2.Response = object({
    id: hex3()
  });
})(wallet_sendCalls || (wallet_sendCalls = {}));
var wallet_sendPreparedCalls2;
(function(wallet_sendPreparedCalls3) {
  wallet_sendPreparedCalls3.Parameters = object({
    capabilities: wallet_prepareCalls2.Response.shape.capabilities,
    chainId: hex3(),
    context: wallet_prepareCalls2.Response.shape.context,
    key: wallet_prepareCalls2.Response.shape.key,
    signature: hex3()
  });
  wallet_sendPreparedCalls3.Request = object({
    method: literal("wallet_sendPreparedCalls"),
    params: readonly(tuple([wallet_sendPreparedCalls3.Parameters]))
  });
  wallet_sendPreparedCalls3.Response = readonly(array(object({
    capabilities: optional(record(string2(), unknown())),
    id: hex3()
  })));
})(wallet_sendPreparedCalls2 || (wallet_sendPreparedCalls2 = {}));
var wallet_verifySignature2;
(function(wallet_verifySignature3) {
  wallet_verifySignature3.Parameters = object({
    /** Address of the account. */
    address: address(),
    /** Chain ID. */
    chainId: optional(number4()),
    /** Digest to verify. */
    digest: hex3(),
    /** Signature to verify. */
    signature: hex3()
  });
  wallet_verifySignature3.Request = object({
    method: literal("wallet_verifySignature"),
    params: readonly(tuple([wallet_verifySignature3.Parameters]))
  });
  wallet_verifySignature3.Response = object({
    /** Address of the account. */
    address: address(),
    /** Chain ID. */
    chainId: number4(),
    /** Proof that can be used to verify the signature. */
    proof: optional(unknown()),
    /** Whether the signature is valid. */
    valid: boolean2()
  });
})(wallet_verifySignature2 || (wallet_verifySignature2 = {}));

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/schema/request.js
var Request2 = discriminatedUnion("method", [
  account_verifyEmail2.Request,
  wallet_addFunds.Request,
  eth_accounts.Request,
  eth_chainId.Request,
  eth_requestAccounts.Request,
  eth_sendTransaction.Request,
  eth_signTypedData_v4.Request,
  wallet_getAccountVersion.Request,
  wallet_getAdmins.Request,
  wallet_getPermissions.Request,
  wallet_grantAdmin.Request,
  wallet_grantPermissions.Request,
  wallet_prepareUpgradeAccount2.Request,
  wallet_revokeAdmin.Request,
  wallet_revokePermissions.Request,
  wallet_upgradeAccount2.Request,
  personal_sign.Request,
  porto_ping.Request,
  wallet_connect.Request,
  wallet_disconnect.Request,
  wallet_getAssets2.Request,
  wallet_getCallsStatus2.Request,
  wallet_getCapabilities2.Request,
  wallet_getKeys2.Request,
  wallet_prepareCalls2.Request,
  wallet_sendCalls.Request,
  wallet_sendPreparedCalls2.Request,
  wallet_switchEthereumChain.Request,
  wallet_verifySignature2.Request
]);
function validate3(schema, value) {
  const result = safeParse(schema, value);
  if (result.error) {
    const issue2 = result.error.issues.at(0);
    if ((issue2 == null ? void 0 : issue2.code) === "invalid_union" && issue2.note === "No matching discriminator")
      throw new MethodNotSupportedError();
    throw new InvalidParamsError(toValidationError(result.error));
  }
  return {
    ...value,
    _decoded: result.data
  };
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/store.js
async function waitForHydration(store) {
  if (store.persist.hasHydrated())
    return;
  await new Promise((resolve) => {
    store.persist.onFinishHydration(() => resolve(true));
    setTimeout(() => resolve(true), 100);
  });
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/urlString.js
function toAbsolute(url2) {
  if (!url2)
    return void 0;
  if (url2.startsWith("/"))
    return `${window.location.origin}${url2}`;
  return url2;
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/provider.js
function from13(parameters) {
  const { config: config2, getMode, id, store } = parameters;
  const { announceProvider: announceProvider2 } = config2;
  function getCapabilities2(parameters2 = {}) {
    var _a2;
    const client = getClient();
    const request = parameters2.request ?? validate3(Request2, {
      method: "wallet_getCapabilities",
      params: parameters2.chainIds ? [void 0, parameters2.chainIds] : void 0
    });
    return withCache(() => getMode().actions.getCapabilities({
      chainIds: parameters2.chainIds,
      internal: {
        client,
        config: config2,
        request,
        store
      }
    }), { cacheKey: `getCapabilities.${id}.${(_a2 = parameters2.chainIds) == null ? void 0 : _a2.join(",")}` });
  }
  function getClient(chainId_) {
    const chainId = typeof chainId_ === "string" ? toNumber(chainId_) : chainId_;
    return fromPorto({ _internal: parameters }, { chainId });
  }
  const lock = /* @__PURE__ */ new Map();
  const preparedAccounts_internal = [];
  const emitter = createEmitter();
  const provider = from7({
    ...emitter,
    async request(request_) {
      await waitForHydration(store);
      const shouldDedupe = [
        "eth_accounts",
        "eth_chainId",
        "eth_requestAccounts",
        "wallet_getAssets",
        "wallet_getCapabilities",
        "wallet_getKeys",
        "wallet_getPermissions",
        "wallet_getAccountVersion",
        "wallet_connect"
      ].includes(request_.method);
      return withDedupe(async () => {
        var _a2, _b, _c, _d, _e, _f, _g, _h;
        let request;
        try {
          request = validate3(Request2, request_);
        } catch (e) {
          const error46 = e;
          if (!(error46 instanceof MethodNotSupportedError))
            throw error46;
          if (request_.method.startsWith("wallet_"))
            throw new UnsupportedMethodError();
          return getClient().request(request_);
        }
        const state = store.getState();
        switch (request.method) {
          case "account_verifyEmail": {
            if (state.accounts.length === 0)
              throw new DisconnectedError();
            const [parameters2] = request._decoded.params;
            const { chainId, email: email3, token, walletAddress } = parameters2;
            const client = getClient(chainId);
            if (chainId && chainId !== client.chain.id)
              throw new ChainDisconnectedError();
            const account = walletAddress ? state.accounts.find((account2) => isEqual(account2.address, walletAddress)) : state.accounts[0];
            if (!account)
              throw new UnauthorizedError();
            return await getMode().actions.verifyEmail({
              account,
              chainId,
              email: email3,
              internal: {
                client,
                config: config2,
                request,
                store
              },
              token,
              walletAddress
            });
          }
          case "wallet_addFunds": {
            if (state.accounts.length === 0)
              throw new DisconnectedError();
            const { address: address2, value, token } = request.params[0] ?? {};
            const account = address2 ? state.accounts.find((account2) => isEqual(account2.address, address2)) : state.accounts[0];
            if (!account)
              throw new UnauthorizedError();
            const client = getClient();
            const result = await getMode().actions.addFunds({
              address: account.address,
              internal: {
                client,
                config: config2,
                request,
                store
              },
              token,
              value
            });
            emitter.emit("message", {
              data: null,
              type: "assetsChanged"
            });
            return result;
          }
          case "eth_accounts": {
            if (state.accounts.length === 0)
              throw new DisconnectedError();
            return state.accounts.map(getAccountAddress);
          }
          case "eth_chainId": {
            return fromNumber(state.chainIds[0]);
          }
          case "eth_requestAccounts": {
            if (state.accounts.length > 0 && lock.get("eth_requestAccounts"))
              return state.accounts.map(getAccountAddress);
            const client = getClient();
            const { accounts } = await getMode().actions.loadAccounts({
              internal: {
                client,
                config: config2,
                request,
                store
              }
            });
            store.setState((x) => ({ ...x, accounts }));
            emitter.emit("connect", {
              chainId: fromNumber(client.chain.id)
            });
            lock.set("eth_requestAccounts", true);
            setTimeout(() => lock.delete("eth_requestAccounts"), 1e3);
            return accounts.map(getAccountAddress);
          }
          case "eth_sendTransaction": {
            if (state.accounts.length === 0)
              throw new DisconnectedError();
            const [{ capabilities, chainId, data = "0x", from: from19, to, value }] = request._decoded.params;
            const client = getClient(chainId);
            if (chainId && chainId !== client.chain.id)
              throw new ChainDisconnectedError();
            const account = from19 ? state.accounts.find((account2) => isEqual(account2.address, from19)) : state.accounts[0];
            if (!account)
              throw new UnauthorizedError();
            const { id: id2 } = await getMode().actions.sendCalls({
              account,
              asTxHash: true,
              calls: [
                {
                  data,
                  to,
                  value
                }
              ],
              chainId: client.chain.id,
              internal: {
                client,
                config: config2,
                request,
                store
              },
              merchantUrl: toAbsolute(config2.merchantUrl ?? (capabilities == null ? void 0 : capabilities.merchantUrl))
            });
            return id2;
          }
          case "eth_signTypedData_v4": {
            if (state.accounts.length === 0)
              throw new DisconnectedError();
            const [address2, data] = request._decoded.params;
            const account = state.accounts.find((account2) => isEqual(account2.address, address2));
            if (!account)
              throw new UnauthorizedError();
            const client = getClient();
            const signature = await getMode().actions.signTypedData({
              account,
              data,
              internal: {
                client,
                config: config2,
                request,
                store
              }
            });
            return signature;
          }
          case "wallet_grantAdmin": {
            if (state.accounts.length === 0)
              throw new DisconnectedError();
            const [{ address: address2, capabilities, chainId, key: keyToAuthorize }] = request._decoded.params ?? [{}];
            const account = address2 ? state.accounts.find((account2) => isEqual(account2.address, address2)) : state.accounts[0];
            if (!account)
              throw new UnauthorizedError();
            const client = getClient(chainId);
            const keyExists = (_a2 = getAdmins([...account.keys ?? []])) == null ? void 0 : _a2.some((key2) => {
              var _a3;
              return ((_a3 = key2.publicKey) == null ? void 0 : _a3.toLowerCase()) === keyToAuthorize.publicKey.toLowerCase();
            });
            if (keyExists)
              throw new InvalidParamsError({
                message: "Key already granted as admin."
              });
            const { key } = await getMode().actions.grantAdmin({
              account,
              feeToken: capabilities == null ? void 0 : capabilities.feeToken,
              internal: {
                client,
                config: config2,
                request,
                store
              },
              key: keyToAuthorize
            });
            store.setState((x) => {
              const index = x.accounts.findIndex((x2) => account ? isEqual(x2.address, account.address) : true);
              if (index === -1)
                return x;
              return {
                ...x,
                accounts: x.accounts.map((account2, i) => i === index ? { ...account2, keys: [...account2.keys ?? [], key] } : account2)
              };
            });
            const admins = getAdmins([...account.keys ?? [], key]);
            emitter.emit("message", {
              data: null,
              type: "adminsChanged"
            });
            return encode2(wallet_grantAdmin.Response, {
              address: account.address,
              chainId: client.chain.id,
              key: admins.at(-1)
            });
          }
          case "wallet_grantPermissions": {
            if (state.accounts.length === 0)
              throw new DisconnectedError();
            const [{ address: address2, chainId, ...permissions2 }] = request._decoded.params ?? [{}];
            const account = address2 ? state.accounts.find((account2) => isEqual(account2.address, address2)) : state.accounts[0];
            if (!account)
              throw new UnauthorizedError();
            const client = getClient(chainId);
            const { key } = await getMode().actions.grantPermissions({
              account,
              internal: {
                client,
                config: config2,
                request,
                store
              },
              permissions: permissions2
            });
            store.setState((x) => {
              const index = x.accounts.findIndex((x2) => account ? isEqual(x2.address, account.address) : true);
              if (index === -1)
                return x;
              return {
                ...x,
                accounts: x.accounts.map((account2, i) => i === index ? { ...account2, keys: [...account2.keys ?? [], key] } : account2)
              };
            });
            emitter.emit("message", {
              data: null,
              type: "permissionsChanged"
            });
            return encode2(wallet_grantPermissions.Response, {
              ...fromKey(key, {
                address: account.address
              })
            });
          }
          case "wallet_getAdmins": {
            if (state.accounts.length === 0)
              throw new DisconnectedError();
            const [{ address: address2, chainId }] = request._decoded.params ?? [{}];
            const account = address2 ? state.accounts.find((account2) => isEqual(account2.address, address2)) : state.accounts[0];
            if (!account)
              throw new UnauthorizedError();
            const client = getClient(chainId);
            const keys = await getMode().actions.getKeys({
              account,
              internal: {
                client,
                config: config2,
                request,
                store
              }
            });
            const admins = getAdmins(keys);
            return encode2(wallet_getAdmins.Response, {
              address: account.address,
              chainId: client.chain.id,
              keys: admins
            });
          }
          case "wallet_prepareUpgradeAccount": {
            const [{ address: address2, capabilities, chainId }] = request._decoded.params ?? [{}];
            const { email: email3, label, grantPermissions: permissions2 } = capabilities ?? {};
            const client = getClient(chainId);
            const { context, digests } = await getMode().actions.prepareUpgradeAccount({
              address: address2,
              email: email3,
              internal: {
                client,
                config: config2,
                request,
                store
              },
              label,
              permissions: permissions2
            });
            preparedAccounts_internal.push(context.account);
            return {
              context,
              digests
            };
          }
          case "wallet_getAccountVersion": {
            if (state.accounts.length === 0)
              throw new DisconnectedError();
            const [{ address: address2 }] = request._decoded.params ?? [{}];
            const account = address2 ? state.accounts.find((account2) => isEqual(account2.address, address2)) : state.accounts[0];
            if (!account)
              throw new UnauthorizedError();
            const client = getClient();
            const { current, latest } = await getMode().actions.getAccountVersion({
              address: account.address,
              internal: {
                client,
                config: config2,
                request,
                store
              }
            });
            return {
              current,
              latest
            };
          }
          case "wallet_getKeys": {
            if (state.accounts.length === 0)
              throw new DisconnectedError();
            const [{ address: address2, chainIds }] = request._decoded.params ?? [{}];
            const account = state.accounts.find((account2) => isEqual(account2.address, address2));
            if (!account)
              throw new UnauthorizedError();
            const client = getClient();
            const keys = await getMode().actions.getKeys({
              account,
              chainIds,
              internal: { client, config: config2, request, store }
            });
            return encode2(wallet_getKeys2.Response, keys);
          }
          case "wallet_getPermissions": {
            if (state.accounts.length === 0)
              throw new DisconnectedError();
            const [{ address: address2, chainIds }] = request._decoded.params ?? [{}];
            const account = address2 ? state.accounts.find((account2) => isEqual(account2.address, address2)) : state.accounts[0];
            if (!account)
              throw new UnauthorizedError();
            const client = getClient();
            const keys = await getMode().actions.getKeys({
              account,
              chainIds,
              internal: {
                client,
                config: config2,
                request,
                store
              }
            });
            const permissions2 = getActivePermissions(keys, {
              address: account.address
            });
            return permissions2;
          }
          case "wallet_revokeAdmin": {
            if (state.accounts.length === 0)
              throw new DisconnectedError();
            const [{ address: address2, capabilities, id: id2 }] = request._decoded.params;
            const account = address2 ? state.accounts.find((account2) => isEqual(account2.address, address2)) : state.accounts[0];
            if (!account)
              throw new UnauthorizedError();
            const client = getClient();
            await getMode().actions.revokeAdmin({
              account,
              feeToken: capabilities == null ? void 0 : capabilities.feeToken,
              id: id2,
              internal: {
                client,
                config: config2,
                request,
                store
              }
            });
            const keys = (_b = account.keys) == null ? void 0 : _b.filter((key) => key.id.toLowerCase() !== id2.toLowerCase());
            store.setState((x) => ({
              ...x,
              accounts: x.accounts.map((x2) => isEqual(x2.address, account.address) ? {
                ...x2,
                keys
              } : x2)
            }));
            emitter.emit("message", {
              data: null,
              type: "adminsChanged"
            });
            return;
          }
          case "wallet_revokePermissions": {
            if (state.accounts.length === 0)
              throw new DisconnectedError();
            const [{ address: address2, capabilities, id: id2 }] = request._decoded.params;
            const account = address2 ? state.accounts.find((account2) => isEqual(account2.address, address2)) : state.accounts[0];
            if (!account)
              throw new UnauthorizedError();
            const client = getClient();
            await getMode().actions.revokePermissions({
              account,
              feeToken: capabilities == null ? void 0 : capabilities.feeToken,
              id: id2,
              internal: {
                client,
                config: config2,
                request,
                store
              }
            });
            const keys = (_c = account.keys) == null ? void 0 : _c.filter((key) => key.id.toLowerCase() !== id2.toLowerCase());
            store.setState((x) => ({
              ...x,
              accounts: x.accounts.map((x2) => isEqual(x2.address, account.address) ? {
                ...x2,
                keys
              } : x2)
            }));
            emitter.emit("message", {
              data: null,
              type: "permissionsChanged"
            });
            return;
          }
          case "wallet_upgradeAccount": {
            const [{ context, signatures }] = request._decoded.params ?? [{}];
            const client = getClient();
            const account_ = preparedAccounts_internal.find((account2) => isEqual(account2.address, context.account.address));
            if (!account_)
              throw new UnauthorizedError();
            const { account } = await getMode().actions.upgradeAccount({
              account: account_,
              context,
              internal: {
                client,
                config: config2,
                request,
                store
              },
              signatures
            });
            const admins = getAdmins(account.keys ?? []);
            const permissions2 = getActivePermissions(account.keys ?? [], {
              address: account.address
            });
            store.setState((x) => ({ ...x, accounts: [account] }));
            emitter.emit("connect", {
              chainId: fromNumber(client.chain.id)
            });
            return {
              address: account.address,
              capabilities: {
                admins,
                ...permissions2.length > 0 ? { permissions: permissions2 } : {}
              }
            };
          }
          case "porto_ping": {
            return "pong";
          }
          case "personal_sign": {
            if (state.accounts.length === 0)
              throw new DisconnectedError();
            const [data, address2] = request._decoded.params;
            const account = state.accounts.find((account2) => isEqual(account2.address, address2));
            if (!account)
              throw new UnauthorizedError();
            const client = getClient();
            const signature = await getMode().actions.signPersonalMessage({
              account,
              data,
              internal: {
                client,
                config: config2,
                request,
                store
              }
            });
            return signature;
          }
          case "wallet_connect": {
            const [{ capabilities, chainIds }] = request._decoded.params ?? [
              {}
            ];
            const client = getClient(chainIds == null ? void 0 : chainIds[0]);
            const chainId = client.chain.id;
            const { createAccount: createAccount3, email: email3, grantAdmins: admins, grantPermissions: permissions2, selectAccount, signInWithEthereum: signInWithEthereum2 } = capabilities ?? {};
            const internal = {
              client,
              config: config2,
              request,
              store
            };
            const { accounts } = await (async () => {
              if (email3 || createAccount3) {
                const { label = void 0 } = typeof createAccount3 === "object" ? createAccount3 : {};
                const { account: account2 } = await getMode().actions.createAccount({
                  admins,
                  email: email3,
                  internal,
                  label,
                  permissions: permissions2,
                  signInWithEthereum: signInWithEthereum2
                });
                return { accounts: [account2] };
              }
              const account = state.accounts[0];
              const { address: address2, key } = (() => {
                var _a3, _b2;
                if (selectAccount) {
                  if (typeof selectAccount === "object")
                    return selectAccount;
                  return {
                    address: void 0,
                    key: void 0
                  };
                }
                for (const key2 of (account == null ? void 0 : account.keys) ?? []) {
                  if (key2.type === "webauthn-p256" && key2.role === "admin")
                    return {
                      address: account == null ? void 0 : account.address,
                      key: {
                        credentialId: key2.credentialId ?? ((_b2 = (_a3 = key2.privateKey) == null ? void 0 : _a3.credential) == null ? void 0 : _b2.id),
                        publicKey: key2.publicKey
                      }
                    };
                }
                return {
                  address: void 0,
                  key: void 0
                };
              })();
              const loadAccountsParams = {
                internal,
                permissions: permissions2,
                signInWithEthereum: signInWithEthereum2
              };
              try {
                return await getMode().actions.loadAccounts({
                  address: address2,
                  key,
                  ...loadAccountsParams
                });
              } catch (error46) {
                if (error46 instanceof UserRejectedRequestError)
                  throw error46;
                if (address2 && key)
                  return await getMode().actions.loadAccounts(loadAccountsParams);
                throw error46;
              }
            })();
            store.setState((x) => ({ ...x, accounts }));
            const chainIds_response = [
              chainId,
              ...store.getState().chainIds.filter((id2) => id2 !== chainId)
            ];
            emitter.emit("connect", {
              chainId: fromNumber(chainIds_response[0])
            });
            return {
              accounts: accounts.map((account) => ({
                address: getAccountAddress(account),
                capabilities: {
                  admins: account.keys ? getAdmins(account.keys) : [],
                  permissions: account.keys ? getActivePermissions(account.keys, {
                    address: account.address
                  }) : [],
                  ...account.signInWithEthereum && {
                    signInWithEthereum: account.signInWithEthereum
                  }
                }
              })),
              chainIds: chainIds_response.map((chainId2) => fromNumber(chainId2))
            };
          }
          case "wallet_disconnect": {
            const client = getClient();
            await ((_e = (_d = getMode().actions).disconnect) == null ? void 0 : _e.call(_d, {
              internal: {
                client,
                config: config2,
                request,
                store
              }
            }));
            store.setState((x) => ({ ...x, accounts: [] }));
            emitter.emit("disconnect", new DisconnectedError());
            return;
          }
          case "wallet_getAssets": {
            const [parameters2] = request._decoded.params ?? [];
            const { account, chainFilter, assetFilter, assetTypeFilter } = parameters2;
            const client = getClient();
            const response = await getMode().actions.getAssets({
              account,
              assetFilter,
              assetTypeFilter,
              chainFilter,
              internal: {
                client,
                config: config2,
                request,
                store
              }
            });
            const value = Object.entries(response).reduce((acc, [key, value2]) => {
              acc[fromNumber(Number(key))] = value2;
              return acc;
            }, {});
            return encode2(wallet_getAssets2.Response, value);
          }
          case "wallet_getCallsStatus": {
            const [id2] = request._decoded.params ?? [];
            const client = getClient();
            const response = await getMode().actions.getCallsStatus({
              id: id2,
              internal: {
                client,
                config: config2,
                request,
                store
              }
            });
            return response;
          }
          case "wallet_getCapabilities": {
            const [_, chainIds] = request.params ?? [];
            const capabilities = await getCapabilities2({
              chainIds,
              request
            });
            return capabilities;
          }
          case "wallet_prepareCalls": {
            const [parameters2] = request._decoded.params;
            const { calls, capabilities, chainId, key, from: from19 } = parameters2;
            const client = getClient(chainId);
            const account = from19 ?? state.accounts[0];
            if (!account)
              throw new UnauthorizedError();
            if (chainId && chainId !== client.chain.id)
              throw new ChainDisconnectedError();
            const { digest, ...rest } = await getMode().actions.prepareCalls({
              account: from12(account),
              calls,
              feeToken: capabilities == null ? void 0 : capabilities.feeToken,
              internal: {
                client,
                config: config2,
                request,
                store
              },
              key,
              merchantUrl: toAbsolute(config2.merchantUrl ?? (capabilities == null ? void 0 : capabilities.merchantUrl)),
              requiredFunds: capabilities == null ? void 0 : capabilities.requiredFunds
            });
            return encode2(wallet_prepareCalls2.Response, {
              capabilities: rest.capabilities,
              chainId: fromNumber(rest.chainId ?? client.chain.id),
              context: {
                ...rest.context,
                account: {
                  address: rest.account.address
                },
                calls: rest.context.calls ?? [],
                nonce: rest.context.nonce ?? 0n
              },
              digest,
              key: rest.key,
              typedData: rest.typedData
            });
          }
          case "wallet_sendPreparedCalls": {
            const [parameters2] = request._decoded.params;
            const { chainId, context, key, signature } = parameters2;
            const { account } = parameters2.context;
            const client = getClient(chainId);
            if (chainId && toNumber(chainId) !== client.chain.id)
              throw new ChainDisconnectedError();
            const hash3 = await getMode().actions.sendPreparedCalls({
              account: from12(account),
              context,
              internal: {
                client,
                config: config2,
                request,
                store
              },
              key,
              signature
            });
            return [{ id: hash3 }];
          }
          case "wallet_sendCalls": {
            if (state.accounts.length === 0)
              throw new DisconnectedError();
            const [parameters2] = request._decoded.params;
            const { calls, capabilities, chainId, from: from19 } = parameters2;
            const client = getClient(chainId);
            if (chainId && chainId !== client.chain.id)
              throw new ChainDisconnectedError();
            const account = from19 ? state.accounts.find((account2) => isEqual(account2.address, from19)) : state.accounts[0];
            if (!account)
              throw new UnauthorizedError();
            const { id: id2 } = await getMode().actions.sendCalls({
              account,
              calls,
              chainId: client.chain.id,
              feeToken: capabilities == null ? void 0 : capabilities.feeToken,
              internal: {
                client,
                config: config2,
                request,
                store
              },
              merchantUrl: toAbsolute(config2.merchantUrl ?? (capabilities == null ? void 0 : capabilities.merchantUrl)),
              permissionsId: (_f = capabilities == null ? void 0 : capabilities.permissions) == null ? void 0 : _f.id,
              requiredFunds: capabilities == null ? void 0 : capabilities.requiredFunds
            });
            return { id: id2 };
          }
          case "wallet_switchEthereumChain": {
            const [parameters2] = request._decoded.params;
            const { chainId } = parameters2;
            const chainId_number = toNumber(chainId);
            const chain = config2.chains.find((chain2) => chain2.id === chainId_number);
            if (!chain)
              throw new UnsupportedChainIdError();
            const client = getClient(chainId);
            await ((_h = (_g = getMode().actions).switchChain) == null ? void 0 : _h.call(_g, {
              chainId: client.chain.id,
              internal: {
                client,
                config: config2,
                request,
                store
              }
            }));
            store.setState((state2) => ({
              ...state2,
              chainIds: [
                chainId_number,
                ...state2.chainIds.filter((id2) => id2 !== chainId_number)
              ]
            }));
            return void 0;
          }
          case "wallet_verifySignature": {
            const [parameters2] = request._decoded.params;
            const { address: address2, chainId, digest, signature } = parameters2;
            const client = getClient(chainId);
            const result = await verifySignature(client, {
              address: address2,
              digest,
              signature
            });
            return {
              ...result,
              address: address2,
              chainId: fromNumber(client.chain.id)
            };
          }
        }
      }, {
        enabled: shouldDedupe,
        id: stringify(request_)
      });
    }
  });
  function setup() {
    let unsubscribe_accounts = () => {
    };
    let unsubscribe_chain = () => {
    };
    void waitForHydration(store).then(() => {
      getCapabilities2().catch(() => {
      });
      unsubscribe_accounts();
      unsubscribe_accounts = store.subscribe((state) => state.accounts, (accounts) => {
        emitter.emit("accountsChanged", accounts.map(getAccountAddress));
      }, {
        equalityFn: (a, b) => a.every((a2, index) => {
          var _a2;
          return a2.address === ((_a2 = b[index]) == null ? void 0 : _a2.address);
        })
      });
      unsubscribe_chain();
      unsubscribe_chain = store.subscribe((state) => state.chainIds[0], (chainId, previousChainId) => {
        if (chainId === previousChainId)
          return;
        emitter.emit("chainChanged", fromNumber(chainId));
      });
    });
    const unannounce = announce(provider, announceProvider2);
    return () => {
      unsubscribe_accounts();
      unsubscribe_chain();
      unannounce();
    };
  }
  const destroy = setup();
  return Object.assign(provider, {
    _internal: {
      destroy
    }
  });
}
function announce(provider, info) {
  if (!info)
    return () => {
    };
  if (typeof window === "undefined" || !window.dispatchEvent)
    return () => {
    };
  const { icon = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNDIyIiBoZWlnaHQ9IjQyMiIgdmlld0JveD0iMCAwIDQyMiA0MjIiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSI0MjIiIGhlaWdodD0iNDIyIiBmaWxsPSJibGFjayIvPgo8ZyBjbGlwLXBhdGg9InVybCgjY2xpcDBfMV8xNSkiPgo8cGF0aCBkPSJNODEgMjg2LjM2NkM4MSAyODAuODkzIDg1LjQ1MDUgMjc2LjQ1NSA5MC45NDA0IDI3Ni40NTVIMzI5LjUxMUMzMzUuMDAxIDI3Ni40NTUgMzM5LjQ1MiAyODAuODkzIDMzOS40NTIgMjg2LjM2NlYzMDYuMTg4QzMzOS40NTIgMzExLjY2MiAzMzUuMDAxIDMxNi4wOTkgMzI5LjUxMSAzMTYuMDk5SDkwLjk0MDRDODUuNDUwNSAzMTYuMDk5IDgxIDMxMS42NjIgODEgMzA2LjE4OFYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAyMzQuODI4Qzg1LjQ1MDUgMjM0LjgyOCA4MSAyMzkuMjY2IDgxIDI0NC43MzlWMjcxLjUzMUM4My44NDMyIDI2OS42MzMgODcuMjYyMiAyNjguNTI2IDkwLjk0MDQgMjY4LjUyNkgzMjkuNTExQzMzMy4xODggMjY4LjUyNiAzMzYuNjA4IDI2OS42MzMgMzM5LjQ1MiAyNzEuNTMxVjI0NC43MzlDMzM5LjQ1MiAyMzkuMjY2IDMzNS4wMDEgMjM0LjgyOCAzMjkuNTExIDIzNC44MjhIOTAuOTQwNFpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgwLjg5MyAzMzUuMDAxIDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTlDODEgMzExLjY2NCA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2NCAzMzkuNDUyIDMwNi4xOVYyODYuMzY2WiIgZmlsbD0id2hpdGUiIGZpbGwtb3BhY2l0eT0iMC41Ii8+CjxwYXRoIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTAuOTQwNCAxOTMuMjAxQzg1LjQ1MDUgMTkzLjIwMSA4MSAxOTcuNjM4IDgxIDIwMy4xMTJWMjI5LjkwM0M4My44NDMyIDIyOC4wMDYgODcuMjYyMiAyMjYuODk5IDkwLjk0MDQgMjI2Ljg5OUgzMjkuNTExQzMzMy4xODggMjI2Ljg5OSAzMzYuNjA4IDIyOC4wMDYgMzM5LjQ1MiAyMjkuOTAzVjIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNFpNMzM5LjQ1MiAyNDQuNzM5QzMzOS40NTIgMjM5LjI2NSAzMzUuMDAxIDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNDODEuMjE3NSAyNzEuMzg1IDgxLjQzODMgMjcxLjI0NSA4MS42NjI0IDI3MS4xMDlDODMuODMyNSAyNjkuNzk0IDg2LjMwNTQgMjY4LjkyNyA4OC45NTIzIDI2OC42MzVDODkuNjA1MSAyNjguNTYzIDkwLjI2ODQgMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMzAuMTgzIDI2OC41MjYgMzMwLjg0NiAyNjguNTYzIDMzMS40OTggMjY4LjYzNUMzMzQuNDE5IDI2OC45NTcgMzM3LjEyOCAyNjkuOTggMzM5LjQ1MiAyNzEuNTNWMjQ0LjczOVpNMzM5LjQ1MiAyODYuMzY2QzMzOS40NTIgMjgxLjAyMSAzMzUuMjA2IDI3Ni42NjMgMzI5Ljg5MyAyNzYuNDYyQzMyOS43NjcgMjc2LjQ1NyAzMjkuNjQgMjc2LjQ1NSAzMjkuNTExIDI3Ni40NTVIOTAuOTQwNEM4NS40NTA1IDI3Ni40NTUgODEgMjgwLjg5MyA4MSAyODYuMzY2VjMwNi4xODhDODEgMzExLjY2MiA4NS40NTA1IDMxNi4xMDEgOTAuOTQwNCAzMTYuMTAxSDMyOS41MTFDMzM1LjAwMSAzMTYuMTAxIDMzOS40NTIgMzExLjY2MiAzMzkuNDUyIDMwNi4xODhWMjg2LjM2NloiIGZpbGw9IndoaXRlIiBmaWxsLW9wYWNpdHk9IjAuNSIvPgo8cGF0aCBvcGFjaXR5PSIwLjMiIGZpbGwtcnVsZT0iZXZlbm9kZCIgY2xpcC1ydWxlPSJldmVub2RkIiBkPSJNOTguMDE0NiAxMDRDODguNjE3NyAxMDQgODEgMTExLjU5NSA4MSAxMjAuOTY1VjE4OC4yNzZDODMuODQzMiAxODYuMzc5IDg3LjI2MjIgMTg1LjI3MiA5MC45NDA0IDE4NS4yNzJIMzI5LjUxMUMzMzMuMTg4IDE4NS4yNzIgMzM2LjYwOCAxODYuMzc5IDMzOS40NTIgMTg4LjI3NlYxMjAuOTY1QzMzOS40NTIgMTExLjU5NSAzMzEuODMzIDEwNCAzMjIuNDM3IDEwNEg5OC4wMTQ2Wk0zMzkuNDUyIDIwMy4xMTJDMzM5LjQ1MiAxOTcuNjM4IDMzNS4wMDEgMTkzLjIwMSAzMjkuNTExIDE5My4yMDFIOTAuOTQwNEM4NS40NTA1IDE5My4yMDEgODEgMTk3LjYzOCA4MSAyMDMuMTEyVjIyOS45MDNDODEuMjE3NSAyMjkuNzU4IDgxLjQzODMgMjI5LjYxOCA4MS42NjI0IDIyOS40ODJDODMuODMyNSAyMjguMTY3IDg2LjMwNTQgMjI3LjMgODguOTUyMyAyMjcuMDA4Qzg5LjYwNTEgMjI2LjkzNiA5MC4yNjg0IDIyNi44OTkgOTAuOTQwNCAyMjYuODk5SDMyOS41MTFDMzMwLjE4MyAyMjYuODk5IDMzMC44NDYgMjI2LjkzNiAzMzEuNDk4IDIyNy4wMDhDMzM0LjQxOSAyMjcuMzMgMzM3LjEyOCAyMjguMzUyIDMzOS40NTIgMjI5LjkwM1YyMDMuMTEyWk0zMzkuNDUyIDI0NC43MzlDMzM5LjQ1MiAyMzkuMzkzIDMzNS4yMDYgMjM1LjAzNiAzMjkuODkzIDIzNC44MzVDMzI5Ljc2NyAyMzQuODMgMzI5LjY0IDIzNC44MjggMzI5LjUxMSAyMzQuODI4SDkwLjk0MDRDODUuNDUwNSAyMzQuODI4IDgxIDIzOS4yNjUgODEgMjQ0LjczOVYyNzEuNTNMODEuMDcwNyAyNzEuNDgzQzgxLjI2NTMgMjcxLjM1NSA4MS40NjI1IDI3MS4yMyA4MS42NjI0IDI3MS4xMDlDODEuOTA4MyAyNzAuOTYgODIuMTU4MSAyNzAuODE3IDgyLjQxMTcgMjcwLjY3OUM4NC4zOTUzIDI2OS42MDUgODYuNjA1NCAyNjguODk0IDg4Ljk1MjMgMjY4LjYzNUM4OS4wMDUyIDI2OC42MjkgODkuMDU4IDI2OC42MjQgODkuMTExIDI2OC42MThDODkuNzEyNSAyNjguNTU3IDkwLjMyMjggMjY4LjUyNiA5MC45NDA0IDI2OC41MjZIMzI5LjUxMUMzMjkuNzM4IDI2OC41MjYgMzI5Ljk2NSAyNjguNTMgMzMwLjE5MiAyNjguNTM5QzMzMC42MzEgMjY4LjU1NSAzMzEuMDY3IDI2OC41ODcgMzMxLjQ5OCAyNjguNjM1QzMzNC40MTkgMjY4Ljk1NyAzMzcuMTI4IDI2OS45OCAzMzkuNDUyIDI3MS41M1YyNDQuNzM5Wk0zMzkuNDUyIDI4Ni4zNjZDMzM5LjQ1MiAyODEuMDIxIDMzNS4yMDYgMjc2LjY2MyAzMjkuODkzIDI3Ni40NjJMMzI5Ljg2NSAyNzYuNDYxQzMyOS43NDggMjc2LjQ1NyAzMjkuNjI5IDI3Ni40NTUgMzI5LjUxMSAyNzYuNDU1SDkwLjk0MDRDODUuNDUwNSAyNzYuNDU1IDgxIDI4MC44OTMgODEgMjg2LjM2NlYzMDYuMTg4QzgxIDMxMS42NjIgODUuNDUwNSAzMTYuMTAxIDkwLjk0MDQgMzE2LjEwMUgzMjkuNTExQzMzNS4wMDEgMzE2LjEwMSAzMzkuNDUyIDMxMS42NjIgMzM5LjQ1MiAzMDYuMTg4VjI4Ni4zNjZaIiBmaWxsPSJ3aGl0ZSIvPgo8cGF0aCBkPSJNMjY5Ljg2OCAxMzEuNzUyQzI2OS44NjggMTI2LjI3OCAyNzQuMzE4IDEyMS44NCAyNzkuODA4IDEyMS44NEgzMTEuNjE4QzMxNy4xMDggMTIxLjg0IDMyMS41NTggMTI2LjI3OCAzMjEuNTU4IDEzMS43NTJWMTYxLjQ4NUMzMjEuNTU4IDE2Ni45NTkgMzE3LjEwOCAxNzEuMzk2IDMxMS42MTggMTcxLjM5NkgyNzkuODA4QzI3NC4zMTggMTcxLjM5NiAyNjkuODY4IDE2Ni45NTkgMjY5Ljg2OCAxNjEuNDg1VjEzMS43NTJaIiBmaWxsPSJ3aGl0ZSIvPgo8L2c+CjxkZWZzPgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzFfMTUiPgo8cmVjdCB3aWR0aD0iMjU5IiBoZWlnaHQ9IjIxMyIgZmlsbD0id2hpdGUiIHRyYW5zZm9ybT0idHJhbnNsYXRlKDgxIDEwNCkiLz4KPC9jbGlwUGF0aD4KPC9kZWZzPgo8L3N2Zz4K", name = "Porto", rdns = "xyz.ithaca.porto" } = typeof info === "object" ? info : {};
  return announceProvider({
    info: {
      icon,
      name,
      rdns,
      uuid: uuidv4()
    },
    provider
  });
}
function getAdmins(keys) {
  return keys.map((key) => {
    var _a2, _b, _c, _d, _e;
    if (key.role !== "admin")
      return void 0;
    try {
      return encode2(wallet_getAdmins.Key, {
        id: key.id ?? key.publicKey,
        publicKey: key.publicKey,
        type: key.type,
        ...key.type === "webauthn-p256" ? {
          credentialId: (_b = (_a2 = key.privateKey) == null ? void 0 : _a2.credential) == null ? void 0 : _b.id,
          privateKey: {
            credential: {
              id: (_d = (_c = key.privateKey) == null ? void 0 : _c.credential) == null ? void 0 : _d.id
            },
            rpId: (_e = key.privateKey) == null ? void 0 : _e.rpId
          }
        } : {}
      });
    } catch {
      return void 0;
    }
  }).filter(Boolean);
}
function getActivePermissions(keys, { address: address2 }) {
  return keys.map((key) => {
    if (!key.chainId)
      return void 0;
    if (key.role !== "session")
      return void 0;
    if (key.expiry > 0 && key.expiry < BigInt(Math.floor(Date.now() / 1e3)))
      return void 0;
    try {
      return encode2(Schema, fromKey(key, { address: address2 }));
    } catch {
      return void 0;
    }
  }).filter(Boolean);
}
function getAccountAddress(account) {
  return getAddress(account.address);
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/Mode.js
var Mode_exports = {};
__export(Mode_exports, {
  _internal_types: () => types_exports,
  dialog: () => dialog,
  from: () => from14,
  reactNative: () => reactNative2,
  relay: () => relay
});

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/mode.js
function from14(mode) {
  return {
    ...mode,
    setup: mode.setup ?? (() => () => {
    })
  };
}
async function getAuthorizedExecuteKey(parameters) {
  var _a2, _b, _c;
  const { account, calls, permissionsId } = parameters;
  if (typeof permissionsId !== "undefined") {
    if (permissionsId === null)
      return void 0;
    const key = (_a2 = account.keys) == null ? void 0 : _a2.find((key2) => key2.publicKey === permissionsId && key2.privateKey);
    if (!key)
      throw new Error(`permission (id: ${permissionsId}) does not exist.`);
    return key;
  }
  const sessionKey = (_b = account.keys) == null ? void 0 : _b.find((key) => {
    if (!key.privateKey)
      return false;
    if (key.role !== "session")
      return false;
    if (key.expiry < BigInt(Math.floor(Date.now() / 1e3)))
      return false;
    const hasValidScope = calls.every((call2) => {
      var _a3, _b2;
      return (_b2 = (_a3 = key.permissions) == null ? void 0 : _a3.calls) == null ? void 0 : _b2.some((scope) => {
        if (scope.to && scope.to !== call2.to)
          return false;
        if (scope.signature) {
          if (!call2.data)
            return false;
          const selector = slice2(call2.data, 0, 4);
          if (validate(scope.signature))
            return scope.signature === selector;
          if (getSelector(scope.signature) !== selector)
            return false;
        }
        return true;
      });
    });
    if (hasValidScope)
      return true;
    return false;
  });
  const adminKey = (_c = account.keys) == null ? void 0 : _c.find((key) => key.role === "admin" && key.privateKey);
  return sessionKey ?? adminKey;
}

// node_modules/ox/_esm/core/RpcRequest.js
function createStore3(options = {}) {
  let id = options.id ?? 0;
  return {
    prepare(options2) {
      return from15({
        id: id++,
        ...options2
      });
    },
    get id() {
      return id;
    }
  };
}
function from15(options) {
  return {
    ...options,
    jsonrpc: "2.0"
  };
}

// node_modules/ox/_esm/core/RpcSchema.js
function from16() {
  return null;
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/RpcSchema.js
var RpcSchema_exports = {};
__export(RpcSchema_exports, {
  account_getOnrampContactInfo: () => account_getOnrampContactInfo2,
  account_onrampStatus: () => account_onrampStatus2,
  account_resendVerifyPhone: () => account_resendVerifyPhone2,
  account_setEmail: () => account_setEmail2,
  account_setPhone: () => account_setPhone2,
  account_verifyEmail: () => account_verifyEmail2,
  account_verifyPhone: () => account_verifyPhone2,
  eth_accounts: () => eth_accounts,
  eth_chainId: () => eth_chainId,
  eth_requestAccounts: () => eth_requestAccounts,
  eth_sendTransaction: () => eth_sendTransaction,
  eth_signTypedData_v4: () => eth_signTypedData_v4,
  personal_sign: () => personal_sign,
  porto_ping: () => porto_ping,
  wallet_addFunds: () => wallet_addFunds,
  wallet_connect: () => wallet_connect,
  wallet_disconnect: () => wallet_disconnect,
  wallet_getAccountVersion: () => wallet_getAccountVersion,
  wallet_getAdmins: () => wallet_getAdmins,
  wallet_getAssets: () => wallet_getAssets2,
  wallet_getCallsStatus: () => wallet_getCallsStatus2,
  wallet_getCapabilities: () => wallet_getCapabilities2,
  wallet_getKeys: () => wallet_getKeys2,
  wallet_getPermissions: () => wallet_getPermissions,
  wallet_grantAdmin: () => wallet_grantAdmin,
  wallet_grantPermissions: () => wallet_grantPermissions,
  wallet_prepareCalls: () => wallet_prepareCalls2,
  wallet_prepareUpgradeAccount: () => wallet_prepareUpgradeAccount2,
  wallet_revokeAdmin: () => wallet_revokeAdmin,
  wallet_revokePermissions: () => wallet_revokePermissions,
  wallet_sendCalls: () => wallet_sendCalls,
  wallet_sendPreparedCalls: () => wallet_sendPreparedCalls2,
  wallet_switchEthereumChain: () => wallet_switchEthereumChain,
  wallet_upgradeAccount: () => wallet_upgradeAccount2,
  wallet_verifySignature: () => wallet_verifySignature2
});

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/permissionsRequest.js
var Schema2 = Request;
function fromKey2(key) {
  const { expiry, feeToken: feeToken2, permissions: permissions2, publicKey, type } = key;
  return {
    expiry,
    feeToken: feeToken2 ?? null,
    key: {
      publicKey,
      type
    },
    permissions: permissions2 ?? {}
  };
}
async function toKey2(request, options = {}) {
  var _a2, _b;
  if (!request)
    return void 0;
  const chainId = options.chainId ?? request.chainId;
  const expiry = request.expiry ?? 0;
  const feeToken2 = request.feeToken;
  const permissions2 = resolvePermissions(request, {
    feeTokens: options.feeTokens
  });
  const baseParameters = {
    chainId,
    expiry,
    feeToken: feeToken2,
    permissions: permissions2,
    role: "session"
  };
  if (request == null ? void 0 : request.key)
    return from11({
      ...baseParameters,
      publicKey: request.key.publicKey,
      type: request.key.type ?? "secp256k1"
    });
  const hasWebCryptoSubtle = typeof ((_b = (_a2 = globalThis.crypto) == null ? void 0 : _a2.subtle) == null ? void 0 : _b.generateKey) === "function";
  if (hasWebCryptoSubtle)
    try {
      return await createWebCryptoP256(baseParameters);
    } catch (error46) {
      if (!isWebCryptoUnavailable(error46))
        throw error46;
    }
  return createP256(baseParameters);
}
function isWebCryptoUnavailable(error46) {
  var _a2;
  if (!(error46 instanceof Error))
    return false;
  const message = ((_a2 = error46.message) == null ? void 0 : _a2.toLowerCase()) ?? "";
  return error46.name === "TypeError" || error46.name === "ReferenceError" || message.includes("subtle") || message.includes("generatekey");
}

// node_modules/ox/_esm/core/Siwe.js
var domainRegex = /^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}(:[0-9]{1,5})?$/;
var ipRegex = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(:[0-9]{1,5})?$/;
var localhostRegex = /^localhost(:[0-9]{1,5})?$/;
var nonceRegex = /^[a-zA-Z0-9]{8,}$/;
var schemeRegex = /^([a-zA-Z][a-zA-Z0-9+-.]*)$/;
var prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/;
var suffixRegex = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;
function createMessage(value) {
  const { chainId, domain: domain2, expirationTime, issuedAt = /* @__PURE__ */ new Date(), nonce, notBefore, requestId, resources, scheme, uri, version: version2 } = value;
  {
    if (chainId !== Math.floor(chainId))
      throw new InvalidMessageFieldError({
        field: "chainId",
        metaMessages: [
          "- Chain ID must be a EIP-155 chain ID.",
          "- See https://eips.ethereum.org/EIPS/eip-155",
          "",
          `Provided value: ${chainId}`
        ]
      });
    if (!(domainRegex.test(domain2) || ipRegex.test(domain2) || localhostRegex.test(domain2)))
      throw new InvalidMessageFieldError({
        field: "domain",
        metaMessages: [
          "- Domain must be an RFC 3986 authority.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${domain2}`
        ]
      });
    if (!nonceRegex.test(nonce))
      throw new InvalidMessageFieldError({
        field: "nonce",
        metaMessages: [
          "- Nonce must be at least 8 characters.",
          "- Nonce must be alphanumeric.",
          "",
          `Provided value: ${nonce}`
        ]
      });
    if (!isUri(uri))
      throw new InvalidMessageFieldError({
        field: "uri",
        metaMessages: [
          "- URI must be a RFC 3986 URI referring to the resource that is the subject of the signing.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${uri}`
        ]
      });
    if (version2 !== "1")
      throw new InvalidMessageFieldError({
        field: "version",
        metaMessages: [
          "- Version must be '1'.",
          "",
          `Provided value: ${version2}`
        ]
      });
    if (scheme && !schemeRegex.test(scheme))
      throw new InvalidMessageFieldError({
        field: "scheme",
        metaMessages: [
          "- Scheme must be an RFC 3986 URI scheme.",
          "- See https://www.rfc-editor.org/rfc/rfc3986#section-3.1",
          "",
          `Provided value: ${scheme}`
        ]
      });
    const statement2 = value.statement;
    if (statement2 == null ? void 0 : statement2.includes("\n"))
      throw new InvalidMessageFieldError({
        field: "statement",
        metaMessages: [
          "- Statement must not include '\\n'.",
          "",
          `Provided value: ${statement2}`
        ]
      });
  }
  const address2 = from4(value.address, { checksum: true });
  const origin = (() => {
    if (scheme)
      return `${scheme}://${domain2}`;
    return domain2;
  })();
  const statement = (() => {
    if (!value.statement)
      return "";
    return `${value.statement}
`;
  })();
  const prefix = `${origin} wants you to sign in with your Ethereum account:
${address2}

${statement}`;
  let suffix = `URI: ${uri}
Version: ${version2}
Chain ID: ${chainId}
Nonce: ${nonce}
Issued At: ${issuedAt.toISOString()}`;
  if (expirationTime)
    suffix += `
Expiration Time: ${expirationTime.toISOString()}`;
  if (notBefore)
    suffix += `
Not Before: ${notBefore.toISOString()}`;
  if (requestId)
    suffix += `
Request ID: ${requestId}`;
  if (resources) {
    let content = "\nResources:";
    for (const resource of resources) {
      if (!isUri(resource))
        throw new InvalidMessageFieldError({
          field: "resources",
          metaMessages: [
            "- Every resource must be a RFC 3986 URI.",
            "- See https://www.rfc-editor.org/rfc/rfc3986",
            "",
            `Provided value: ${resource}`
          ]
        });
      content += `
- ${resource}`;
    }
    suffix += content;
  }
  return `${prefix}
${suffix}`;
}
function isUri(value) {
  if (/[^a-z0-9:/?#[\]@!$&'()*+,;=.\-_~%]/i.test(value))
    return false;
  if (/%[^0-9a-f]/i.test(value))
    return false;
  if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value))
    return false;
  const splitted = splitUri(value);
  const scheme = splitted[1];
  const authority = splitted[2];
  const path = splitted[3];
  const query = splitted[4];
  const fragment = splitted[5];
  if (!((scheme == null ? void 0 : scheme.length) && path && path.length >= 0))
    return false;
  if (authority == null ? void 0 : authority.length) {
    if (!(path.length === 0 || /^\//.test(path)))
      return false;
  } else {
    if (/^\/\//.test(path))
      return false;
  }
  if (!/^[a-z][a-z0-9+\-.]*$/.test(scheme.toLowerCase()))
    return false;
  let out = "";
  out += `${scheme}:`;
  if (authority == null ? void 0 : authority.length)
    out += `//${authority}`;
  out += path;
  if (query == null ? void 0 : query.length)
    out += `?${query}`;
  if (fragment == null ? void 0 : fragment.length)
    out += `#${fragment}`;
  return out;
}
function splitUri(value) {
  return value.match(/(?:([^:/?#]+):)?(?:\/\/([^/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
}
function parseMessage(message) {
  var _a2, _b, _c;
  const { scheme, statement, ...prefix } = ((_a2 = message.match(prefixRegex)) == null ? void 0 : _a2.groups) ?? {};
  const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = ((_b = message.match(suffixRegex)) == null ? void 0 : _b.groups) ?? {};
  const resources = (_c = message.split("Resources:")[1]) == null ? void 0 : _c.split("\n- ").slice(1);
  return {
    ...prefix,
    ...suffix,
    ...chainId ? { chainId: Number(chainId) } : {},
    ...expirationTime ? { expirationTime: new Date(expirationTime) } : {},
    ...issuedAt ? { issuedAt: new Date(issuedAt) } : {},
    ...notBefore ? { notBefore: new Date(notBefore) } : {},
    ...requestId ? { requestId } : {},
    ...resources ? { resources } : {},
    ...scheme ? { scheme } : {},
    ...statement ? { statement } : {}
  };
}
var InvalidMessageFieldError = class extends BaseError2 {
  constructor(parameters) {
    const { field, metaMessages } = parameters;
    super(`Invalid Sign-In with Ethereum message field "${field}".`, {
      metaMessages
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Siwe.InvalidMessageFieldError"
    });
  }
};

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/siwe.js
async function authenticate(parameters) {
  const { address: address2, authUrl, message, signature, publicKey } = parameters;
  const { chainId } = parseMessage(message);
  return await fetch(authUrl.verify, {
    body: JSON.stringify({
      address: address2,
      chainId,
      message,
      signature,
      walletAddress: address2,
      ...publicKey && { publicKey }
    }),
    credentials: "include",
    headers: {
      "Content-Type": "application/json"
    },
    method: "POST"
  }).then((res) => res.json());
}
async function buildMessage(client, siwe, options) {
  var _a2;
  const { chainId = (_a2 = client.chain) == null ? void 0 : _a2.id, domain: domain2, uri, resources, version: version2 = "1" } = siwe;
  const { address: address2 } = options;
  const authUrl = siwe.authUrl ? resolveAuthUrl(siwe.authUrl) : void 0;
  if (!chainId)
    throw new Error("`chainId` is required.");
  if (!domain2)
    throw new Error("`domain` is required.");
  if (!siwe.nonce && !(authUrl == null ? void 0 : authUrl.nonce))
    throw new Error("`nonce` or `authUrl.nonce` is required.");
  if (!uri)
    throw new Error("`uri` is required.");
  const nonce = await (async () => {
    if (siwe.nonce)
      return siwe.nonce;
    if (!(authUrl == null ? void 0 : authUrl.nonce))
      throw new Error("`nonce` or `authUrl.nonce` is required.");
    const response = await fetch(authUrl.nonce, {
      body: JSON.stringify({
        address: address2,
        chainId,
        walletAddress: address2
      }),
      headers: {
        "Content-Type": "application/json"
      },
      method: "POST"
    });
    const res = await response.json().catch(() => void 0);
    if (!(res == null ? void 0 : res.nonce))
      throw new Error("`nonce` or `authUrl.nonce` is required.");
    return res.nonce;
  })();
  const message = createMessage({
    ...siwe,
    address: options.address,
    chainId,
    domain: domain2,
    nonce,
    resources,
    uri,
    version: version2
  });
  return message;
}
function resolveAuthUrl(authUrl, origin = "") {
  if (!authUrl)
    return void 0;
  const urls = (() => {
    if (typeof authUrl === "string") {
      const url2 = authUrl.replace(/\/$/, "");
      return {
        logout: url2 + "/logout",
        nonce: url2 + "/nonce",
        verify: url2 + "/verify"
      };
    }
    return authUrl;
  })();
  return {
    logout: resolveUrl(urls.logout, origin),
    nonce: resolveUrl(urls.nonce, origin),
    verify: resolveUrl(urls.verify, origin)
  };
}
function resolveUrl(url2, origin) {
  if (!origin)
    return url2;
  if (!url2.startsWith("/"))
    return url2;
  return origin + url2;
}

// node_modules/ox/_esm/core/PersonalMessage.js
function encode3(data) {
  const message = from2(data);
  return concat(
    // Personal Sign Format: `0x19  "Ethereum Signed Message:\n"  message.length  message`
    "0x19",
    fromString2("Ethereum Signed Message:\n" + size(message)),
    message
  );
}
function getSignPayload3(data) {
  return keccak256(encode3(data));
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/viem/ContractActions.js
async function getEip712Domain2(client, parameters) {
  const { account = client.account } = parameters;
  const account_ = account ? from12(account) : void 0;
  if (!account_)
    throw new Error("account is required.");
  const { domain: { name, version: version2 } } = await getEip712Domain(client, {
    address: account_.address
  });
  if (!client.chain)
    throw new Error("client.chain is required");
  return {
    chainId: client.chain.id,
    name,
    verifyingContract: account_.address,
    version: version2
  };
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/viem/RelayActions.js
var RelayActions_exports = {};
__export(RelayActions_exports, {
  addFaucetFunds: () => addFaucetFunds,
  createAccount: () => createAccount2,
  decorator: () => decorator,
  getAssets: () => getAssets,
  getAuthorization: () => getAuthorization,
  getCallsStatus: () => getCallsStatus,
  getCapabilities: () => getCapabilities,
  getKeys: () => getKeys2,
  getOnrampContactInfo: () => getOnrampContactInfo2,
  health: () => health2,
  onrampStatus: () => onrampStatus2,
  prepareCalls: () => prepareCalls2,
  prepareUpgradeAccount: () => prepareUpgradeAccount2,
  resendVerifyPhone: () => resendVerifyPhone2,
  sendCalls: () => sendCalls,
  sendPreparedCalls: () => sendPreparedCalls2,
  setEmail: () => setEmail2,
  setPhone: () => setPhone2,
  signCalls: () => signCalls,
  upgradeAccount: () => upgradeAccount2,
  verifyEmail: () => verifyEmail2,
  verifyPhone: () => verifyPhone2,
  verifySignature: () => verifySignature
});
async function createAccount2(client, parameters) {
  const account = fromPrivateKey(randomPrivateKey(), {
    keys: parameters.authorizeKeys
  });
  return await upgradeAccount2(client, {
    ...parameters,
    account
  });
}
async function getKeys2(client, parameters) {
  const { account = client.account, chainIds } = parameters;
  const account_ = account ? from12(account) : void 0;
  if (!account_)
    throw new Error("account is required.");
  const keys = await getKeys(client, {
    address: account_.address,
    chainIds
  });
  return Object.entries(keys).flatMap(([chainId, keys2]) => keys2.map((key) => fromRelay(key, { chainId: Number(chainId) })));
}
async function getOnrampContactInfo2(client, parameters) {
  const { address: address2, secret } = parameters;
  return await getOnrampContactInfo(client, {
    address: address2,
    secret
  });
}
async function onrampStatus2(client, parameters) {
  const { address: address2 } = parameters;
  return await onrampStatus(client, {
    address: address2
  });
}
async function prepareCalls2(client, parameters) {
  var _a2;
  const { account = client.account, calls, chain = client.chain, feePayer, merchantUrl: merchantUrl2, nonce, preCalls: preCalls2, requiredFunds: requiredFunds3, revokeKeys: revokeKeys2 } = parameters;
  const account_ = account ? from12(account) : void 0;
  const key = parameters.key ?? (account_ ? getKey(account_, { role: "admin" }) : void 0);
  const hasSessionKey = (_a2 = parameters.authorizeKeys) == null ? void 0 : _a2.some((x) => x.role === "session");
  const { contracts, fees: { tokens } } = await getCapabilities(client, { chainId: chain == null ? void 0 : chain.id });
  const orchestrator = hasSessionKey ? contracts.orchestrator.address : void 0;
  const authorizeKeys2 = (parameters.authorizeKeys ?? []).map((key2) => toRelay(key2, { feeTokens: tokens, orchestrator }));
  const feeToken2 = (() => {
    var _a3, _b, _c;
    if (parameters.feeToken)
      return parameters.feeToken;
    return (_c = (_b = (_a3 = key == null ? void 0 : key.permissions) == null ? void 0 : _a3.spend) == null ? void 0 : _b[0]) == null ? void 0 : _c.token;
  })();
  const preCall = typeof preCalls2 === "boolean" ? preCalls2 : false;
  const signedPreCalls = typeof preCalls2 === "object" ? preCalls2.map(({ context: context2, signature: signature2 }) => ({
    ...context2.preCall,
    signature: signature2
  })) : void 0;
  const args = {
    address: account_ == null ? void 0 : account_.address,
    calls: calls ?? [],
    capabilities: {
      authorizeKeys: authorizeKeys2,
      meta: {
        feePayer,
        feeToken: feeToken2,
        nonce
      },
      preCall,
      preCalls: signedPreCalls,
      requiredFunds: requiredFunds3,
      revokeKeys: revokeKeys2 == null ? void 0 : revokeKeys2.map((key2) => ({
        hash: key2.hash
      }))
    },
    chain,
    key: key ? toRelay(key, { feeTokens: tokens }) : void 0
  };
  const result = await (async () => {
    if (merchantUrl2) {
      const client_ = createClient({
        chain: client.chain,
        transport: http(merchantUrl2)
      });
      return await prepareCalls(client_, args).catch((e) => {
        console.error(e);
        return prepareCalls(client, args);
      });
    }
    return await prepareCalls(client, args);
  })();
  const { capabilities, context, digest, signature, typedData } = result;
  if (merchantUrl2) {
    const isValid = await verifyPrepareCallsResponse(client, {
      response: result._raw,
      signature
    });
    if (!isValid)
      throw new Error(`cannot verify integrity of \`wallet_prepareCalls\` response from ${merchantUrl2}`);
  }
  return {
    capabilities: { ...capabilities, quote: context.quote },
    context,
    digest,
    key,
    typedData
  };
}
async function prepareUpgradeAccount2(client, parameters) {
  const { address: address2, authorizeKeys: keys, chain = client.chain } = parameters;
  if (!chain)
    throw new Error("chain is required.");
  const { contracts, fees: { tokens } } = await getCapabilities(client, { chainId: chain.id });
  const delegation = parameters.delegation ?? contracts.accountProxy.address;
  const hasSessionKey = keys.some((x) => x.role === "session");
  const orchestrator = hasSessionKey ? contracts.orchestrator.address : void 0;
  const authorizeKeys2 = keys.map((key) => {
    const permissions2 = key.role === "session" ? key.permissions : {};
    return toRelay({ ...key, permissions: permissions2 }, { feeTokens: tokens, orchestrator });
  });
  const { capabilities, chainId, context, digests, typedData } = await prepareUpgradeAccount(client, {
    address: address2,
    authorizeKeys: authorizeKeys2,
    chain,
    delegation
  });
  const account = from12({
    address: address2,
    keys
  });
  return {
    capabilities,
    chainId,
    context: {
      ...context,
      account
    },
    digests,
    typedData
  };
}
async function resendVerifyPhone2(client, parameters) {
  const { phone, walletAddress } = parameters;
  return await resendVerifyPhone(client, {
    phone,
    walletAddress
  });
}
async function sendCalls(client, parameters) {
  const { account = client.account, chain = client.chain, webAuthn } = parameters;
  if (!chain)
    throw new Error("`chain` is required.");
  const account_ = account ? from12(account) : void 0;
  if (!account_)
    throw new Error("`account` is required.");
  const key = parameters.key ?? getKey(account_, parameters);
  if (!key && !account_.sign)
    throw new Error("`key` or `account` with `sign` is required");
  const preCalls2 = await Promise.all((parameters.preCalls ?? []).map(async (pre) => {
    if (pre.signature)
      return pre;
    const { authorizeKeys: authorizeKeys2, key: key2, calls, revokeKeys: revokeKeys2 } = pre;
    const { context: context2, digest: digest2 } = await prepareCalls2(client, {
      account: account_,
      authorizeKeys: authorizeKeys2,
      calls,
      chain,
      feeToken: parameters.feeToken,
      key: key2,
      preCalls: true,
      revokeKeys: revokeKeys2
    });
    const signature2 = await sign5(key2, {
      address: null,
      payload: digest2,
      webAuthn
    });
    return { context: context2, signature: signature2 };
  }));
  const { capabilities, context, digest } = await prepareCalls2(client, {
    ...parameters,
    account: account_,
    chain,
    key,
    preCalls: preCalls2
  });
  const signature = await (async () => {
    if (key)
      return await sign5(key, {
        address: null,
        payload: digest,
        webAuthn,
        wrap: false
      });
    return await account_.sign({
      hash: digest
    });
  })();
  return await sendPreparedCalls2(client, {
    capabilities: capabilities.feeSignature ? {
      feeSignature: capabilities.feeSignature
    } : void 0,
    context,
    key,
    signature
  });
}
async function signCalls(request, options) {
  var _a2;
  const isPrecall = Boolean(request.context.preCall);
  const { account, key } = options;
  if (account) {
    const keyIndex = (_a2 = account.keys) == null ? void 0 : _a2.findIndex((k) => {
      var _a3;
      return k.publicKey === ((_a3 = request.key) == null ? void 0 : _a3.publicKey);
    });
    if (keyIndex === -1)
      throw new Error("key not found");
    return await sign6(account, {
      key: keyIndex,
      payload: request.digest,
      replaySafe: false,
      wrap: isPrecall
    });
  }
  if (key)
    return await sign5(key, {
      address: null,
      payload: request.digest,
      wrap: isPrecall
    });
  throw new Error("no key or account provided");
}
async function sendPreparedCalls2(client, parameters) {
  const { capabilities, context, key, signature } = parameters;
  return await sendPreparedCalls(client, {
    capabilities,
    context,
    key: key ? toRelay(key) : void 0,
    signature
  });
}
async function setEmail2(client, parameters) {
  const { email: email3, walletAddress } = parameters;
  return await setEmail(client, {
    email: email3,
    walletAddress
  });
}
async function setPhone2(client, parameters) {
  const { phone, walletAddress } = parameters;
  return await setPhone(client, {
    phone,
    walletAddress
  });
}
async function upgradeAccount2(client, parameters) {
  if (parameters.account) {
    const { account: account2 } = parameters;
    const authorizeKeys2 = [
      ...account2.keys ?? [],
      ...parameters.authorizeKeys ?? []
    ].filter((key, index, array2) => array2.findIndex((k) => k.id === key.id) === index);
    const { digests, ...request } = await prepareUpgradeAccount2(client, {
      ...parameters,
      address: account2.address,
      authorizeKeys: authorizeKeys2
    });
    const signatures2 = {
      auth: await account2.sign({ hash: digests.auth }),
      exec: await account2.sign({ hash: digests.exec })
    };
    return await upgradeAccount2(client, {
      ...request,
      signatures: signatures2
    });
  }
  const { context, signatures } = parameters;
  const account = from12(context.account);
  await upgradeAccount(client, {
    context,
    signatures
  });
  return account;
}
async function verifyEmail2(client, parameters) {
  const { chainId, email: email3, signature, token, walletAddress } = parameters;
  return await verifyEmail(client, {
    chainId,
    email: email3,
    signature,
    token,
    walletAddress
  });
}
async function verifyPhone2(client, parameters) {
  const { code: code2, phone, walletAddress } = parameters;
  return await verifyPhone(client, {
    code: code2,
    phone,
    walletAddress
  });
}
function decorator(client) {
  return {
    createAccount: (parameters) => createAccount2(client, parameters),
    getCallsStatus: (parameters) => getCallsStatus(client, parameters),
    getCapabilities: () => getCapabilities(client),
    getKeys: (parameters) => getKeys2(client, parameters),
    health: () => health2(client),
    prepareCalls: (parameters) => prepareCalls2(client, parameters),
    prepareUpgradeAccount: (parameters) => prepareUpgradeAccount2(client, parameters),
    sendCalls: (parameters) => sendCalls(client, parameters),
    sendPreparedCalls: (parameters) => sendPreparedCalls2(client, parameters),
    upgradeAccount: (parameters) => upgradeAccount2(client, parameters),
    verifySignature: (parameters) => verifySignature(client, parameters)
  };
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/erc8010.js
async function wrap2(client, parameters) {
  const { address: address2 } = parameters;
  const { authorization, data, to } = await getAuthorization(client, {
    address: address2
  });
  return wrap({
    authorization: {
      ...authorization,
      nonce: BigInt(authorization.nonce),
      r: BigInt(authorization.r),
      s: BigInt(authorization.s)
    },
    data,
    signature: parameters.signature,
    to
  });
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/requiredFunds.js
function toRelay2(requiredFunds3, options) {
  const { tokens } = options;
  const interopTokens = tokens.filter((token) => token.interop);
  return requiredFunds3.map((requiredFund) => {
    if (requiredFund.address)
      return requiredFund;
    const interopToken = interopTokens.find((token) => token.symbol === requiredFund.symbol);
    if (!interopToken)
      throw new Error(`interop token not found: ${requiredFund.symbol}`);
    return {
      address: interopToken.address,
      value: from10(requiredFund.value, interopToken.decimals)
    };
  });
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/tokens.js
async function getTokens(client, parameters) {
  const { chain = client.chain } = parameters ?? {};
  const tokens = await getCapabilities(client, {
    chainId: chain == null ? void 0 : chain.id
  }).then((capabilities) => capabilities.fees.tokens);
  return tokens;
}
async function getToken(client, parameters) {
  const { addressOrSymbol } = parameters;
  const tokens = await getTokens(client, parameters);
  return tokens.find(getToken.predicate(addressOrSymbol));
}
(function(getToken2) {
  function predicate(addressOrSymbol) {
    return (token) => {
      if (!addressOrSymbol)
        return false;
      if (validate2(addressOrSymbol))
        return isEqual(token.address, addressOrSymbol);
      if (addressOrSymbol === "native")
        return token.address === zeroAddress;
      return addressOrSymbol === token.symbol;
    };
  }
  getToken2.predicate = predicate;
})(getToken || (getToken = {}));
async function resolveFeeToken(client, parameters) {
  const { chain = client.chain, store } = parameters ?? {};
  const state = (store == null ? void 0 : store.getState()) ?? {};
  const addressOrSymbol = (parameters == null ? void 0 : parameters.addressOrSymbol) ?? state.feeToken;
  const feeTokens = await getTokens(client, { chain }).then((tokens) => tokens.filter((token) => token.feeToken));
  const feeToken2 = feeTokens == null ? void 0 : feeTokens.find((feeToken3) => {
    if (!addressOrSymbol)
      return false;
    if (addressOrSymbol === "native" && feeToken3.address === zeroAddress)
      return true;
    if (validate2(addressOrSymbol) && isEqual(feeToken3.address, addressOrSymbol))
      return true;
    return addressOrSymbol === feeToken3.symbol;
  });
  return feeToken2;
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/modes/relay.js
function relay(parameters = {}) {
  const config2 = parameters;
  const { mock, multichain = true, webAuthn } = config2;
  let address_internal;
  let email_internal;
  const keystoreHost = (() => {
    var _a2;
    if (config2.keystoreHost === "self")
      return void 0;
    if (typeof window !== "undefined" && ((_a2 = window.location) == null ? void 0 : _a2.hostname) === "localhost")
      return void 0;
    return config2.keystoreHost;
  })();
  return from14({
    actions: {
      async addFunds() {
        throw new UnsupportedMethodError();
      },
      async createAccount(parameters2) {
        const { admins, email: email3, label, permissions: permissions2, internal, signInWithEthereum: signInWithEthereum2 } = parameters2;
        const { client } = internal;
        const eoa = fromPrivateKey(randomPrivateKey());
        const feeTokens = await getTokens(client);
        const adminKey = !mock ? await createWebAuthnP256({
          createFn: webAuthn == null ? void 0 : webAuthn.createFn,
          label: label || `${eoa.address.slice(0, 8)}${eoa.address.slice(-6)}`,
          rpId: keystoreHost,
          userId: from(eoa.address)
        }) : createHeadlessWebAuthnP256();
        const sessionKey = await toKey2(permissions2, {
          chainId: client.chain.id,
          feeTokens
        });
        const adminKeys = admins == null ? void 0 : admins.map((admin) => from11(admin));
        const account = await upgradeAccount2(client, {
          account: eoa,
          authorizeKeys: [
            adminKey,
            ...adminKeys ?? [],
            ...sessionKey ? [sessionKey] : []
          ]
        });
        address_internal = eoa.address;
        if (email3 && label)
          await setEmail2(client, {
            email: label,
            walletAddress: account.address
          });
        const signInWithEthereum_response = await (async () => {
          if (!signInWithEthereum2)
            return void 0;
          const message = await buildMessage(client, signInWithEthereum2, {
            address: account.address
          });
          const signature = await sign6(eoa, {
            payload: getSignPayload3(fromString2(message))
          });
          const signature_erc8010 = await wrap2(client, {
            address: account.address,
            signature
          });
          return { message, signature: signature_erc8010 };
        })();
        return {
          account: {
            ...account,
            signInWithEthereum: signInWithEthereum_response
          }
        };
      },
      async getAccountVersion(parameters2) {
        const { address: address2, internal } = parameters2;
        const { client } = internal;
        const { contracts } = await getCapabilities(client);
        const { accountImplementation } = contracts;
        const latest = await getEip712Domain2(client, {
          account: from12(accountImplementation)
        }).then((x) => x.version);
        const current = await getEip712Domain2(client, {
          account: address2
        }).then((x) => x.version).catch(() => latest);
        if (!current || !latest)
          throw new Error("version not found.");
        return { current, latest };
      },
      async getAssets(parameters2) {
        const { account, chainFilter, assetFilter, assetTypeFilter, internal } = parameters2;
        const { client } = internal;
        const result = await getAssets(client, {
          account,
          assetFilter,
          assetTypeFilter,
          chainFilter
        });
        return result;
      },
      async getCallsStatus(parameters2) {
        var _a2;
        const { id, internal } = parameters2;
        const { client } = internal;
        const result = await getCallsStatus(client, {
          id
        });
        return {
          atomic: true,
          chainId: fromNumber(client.chain.id),
          id,
          receipts: (_a2 = result.receipts) == null ? void 0 : _a2.map((receipt) => ({
            blockHash: receipt.blockHash,
            blockNumber: fromNumber(receipt.blockNumber),
            gasUsed: fromNumber(receipt.gasUsed),
            logs: receipt.logs,
            status: receipt.status,
            transactionHash: receipt.transactionHash
          })),
          status: result.status,
          version: "1.0"
        };
      },
      async getCapabilities(parameters2) {
        const { chainIds, internal } = parameters2;
        const { client } = internal;
        const base2 = {
          atomic: {
            status: "supported"
          },
          atomicBatch: {
            supported: true
          },
          feeToken: {
            supported: true,
            tokens: []
          },
          merchant: {
            supported: true
          },
          permissions: {
            supported: true
          },
          requiredFunds: {
            supported: Boolean(multichain),
            tokens: []
          }
        };
        const capabilities = await getCapabilities(client, {
          chainIds: chainIds ? chainIds.map((id) => toNumber(id)) : "all",
          raw: true
        });
        return Object.entries(capabilities).reduce((acc, [chainId, capabilities2]) => ({
          // biome-ignore lint/performance/noAccumulatingSpread: _
          ...acc,
          [chainId]: {
            ...base2,
            ...capabilities2,
            feeToken: {
              supported: true,
              tokens: capabilities2.fees.tokens
            },
            requiredFunds: {
              supported: Boolean(multichain),
              tokens: multichain ? capabilities2.fees.tokens.filter((token) => token.interop) : []
            }
          }
        }), {});
      },
      async getKeys(parameters2) {
        const { account, chainIds, internal } = parameters2;
        const { client } = internal;
        const keys = await getKeys2(client, {
          account,
          chainIds
        });
        return uniqBy([...keys, ...account.keys ?? []], (key) => key.publicKey);
      },
      async grantAdmin(parameters2) {
        const { account, internal } = parameters2;
        const { client } = internal;
        const authorizeKey = from11(parameters2.key, {
          chainId: client.chain.id
        });
        const feeToken2 = await resolveFeeToken(client, {
          addressOrSymbol: parameters2.feeToken,
          store: internal.store
        });
        const { id } = await sendCalls(client, {
          account,
          authorizeKeys: [authorizeKey],
          feeToken: feeToken2 == null ? void 0 : feeToken2.address,
          webAuthn
        });
        await waitForCallsStatus(client, {
          id,
          pollingInterval: 500
        });
        return { key: authorizeKey };
      },
      async grantPermissions(parameters2) {
        var _a2;
        const { account, internal, permissions: permissions2 } = parameters2;
        const { client } = internal;
        const feeTokens = await getTokens(client);
        const authorizeKey = await toKey2(permissions2, {
          chainId: client.chain.id,
          feeTokens
        });
        if (!authorizeKey)
          throw new Error("key to authorize not found.");
        const adminKey = (_a2 = account.keys) == null ? void 0 : _a2.find((key) => key.role === "admin" && key.privateKey);
        if (!adminKey)
          throw new Error("admin key not found.");
        const { context, digest } = await prepareCalls2(client, {
          account,
          authorizeKeys: [authorizeKey],
          key: adminKey,
          preCalls: true
        });
        const signature = await sign5(adminKey, {
          address: null,
          payload: digest
        });
        await sendPreparedCalls2(client, {
          context,
          key: adminKey,
          signature
        });
        return { key: authorizeKey };
      },
      async loadAccounts(parameters2) {
        const { internal, permissions: permissions2, signInWithEthereum: signInWithEthereum2 } = parameters2;
        const { client } = internal;
        const feeTokens = await getTokens(client);
        const authorizeKey = await toKey2(permissions2, {
          chainId: client.chain.id,
          feeTokens
        });
        const { digest, digestType, message } = await (async () => {
          if (signInWithEthereum2 && parameters2.address) {
            const message2 = await buildMessage(client, signInWithEthereum2, {
              address: parameters2.address
            });
            return {
              context: void 0,
              digest: getSignPayload3(fromString2(message2)),
              digestType: "siwe",
              message: message2
            };
          }
          return {
            context: void 0,
            digest: "0x",
            message: void 0
          };
        })();
        const { address: address2, credentialId, webAuthnSignature } = await (async () => {
          if (mock) {
            if (!address_internal)
              throw new Error("address_internal not found.");
            return {
              address: address_internal,
              credentialId: void 0
            };
          }
          if (parameters2.address && parameters2.key)
            return {
              address: parameters2.address,
              credentialId: parameters2.key.credentialId
            };
          const webAuthnSignature2 = await sign3({
            challenge: digest,
            getFn: webAuthn == null ? void 0 : webAuthn.getFn,
            rpId: keystoreHost
          });
          const response = webAuthnSignature2.raw.response;
          const address3 = toHex(new Uint8Array(response.userHandle));
          const credentialId2 = webAuthnSignature2.raw.id;
          return { address: address3, credentialId: credentialId2, webAuthnSignature: webAuthnSignature2 };
        })();
        const keys = await getKeys2(client, {
          account: address2,
          chainIds: [client.chain.id]
        });
        const account = from12({
          address: address2,
          keys: [...keys, ...authorizeKey ? [authorizeKey] : []].map((key, i) => {
            if (i === 0) {
              if (key.type === "webauthn-p256")
                return fromWebAuthnP256({
                  ...key,
                  credential: {
                    id: credentialId,
                    publicKey: fromHex(key.publicKey)
                  },
                  id: address2,
                  rpId: keystoreHost
                });
            }
            return key;
          })
        });
        const adminKey = getKey(account, { role: "admin" });
        const signature = await (async () => {
          if (digest === "0x")
            return void 0;
          if (webAuthnSignature)
            return wrapSignature(serializeWebAuthnSignature(webAuthnSignature), {
              keyType: "webauthn-p256",
              publicKey: adminKey.publicKey
            });
          return await sign5(adminKey, {
            address: account.address,
            payload: digest
          });
        })();
        if (authorizeKey) {
          const { context, digest: digest2 } = await prepareCalls2(client, {
            account,
            authorizeKeys: [authorizeKey],
            preCalls: true
          });
          const signature2 = await sign5(adminKey, {
            address: null,
            payload: digest2
          });
          await sendPreparedCalls2(client, {
            context,
            key: adminKey,
            signature: signature2
          });
        }
        const signInWithEthereum_response = await (async () => {
          if (!signInWithEthereum2)
            return void 0;
          if (digestType === "siwe" && message && signature) {
            const signature_erc8010 = await wrap2(client, {
              address: account.address,
              signature
            });
            return { message, signature: signature_erc8010 };
          }
          {
            const message2 = await buildMessage(client, signInWithEthereum2, {
              address: account.address
            });
            const signature2 = await sign6(account, {
              payload: getSignPayload3(fromString2(message2)),
              role: "admin"
            });
            const signature_erc8010 = await wrap2(client, {
              address: account.address,
              signature: signature2
            });
            return {
              message: message2,
              signature: signature_erc8010
            };
          }
        })();
        return {
          accounts: [
            {
              ...account,
              signInWithEthereum: signInWithEthereum_response
            }
          ]
        };
      },
      async prepareCalls(parameters2) {
        var _a2;
        const { account, calls, internal, merchantUrl: merchantUrl2 } = parameters2;
        const { client } = internal;
        const key = parameters2.key ?? await getAuthorizedExecuteKey({
          account,
          calls
        });
        if (!key)
          throw new Error("cannot find authorized key to sign with.");
        const [tokens, feeToken2] = await Promise.all([
          getTokens(client),
          resolveFeeToken(client, {
            addressOrSymbol: parameters2.feeToken,
            store: internal.store
          })
        ]);
        const requiredFunds3 = toRelay2(parameters2.requiredFunds ?? [], {
          tokens
        });
        const { capabilities, context, digest, typedData } = await prepareCalls2(client, {
          account,
          calls,
          feeToken: feeToken2 == null ? void 0 : feeToken2.address,
          key,
          merchantUrl: merchantUrl2,
          requiredFunds: multichain ? requiredFunds3 : void 0
        });
        const quotes = ((_a2 = context.quote) == null ? void 0 : _a2.quotes) ?? [];
        const outputQuote = quotes[quotes.length - 1];
        return {
          account,
          capabilities: {
            ...capabilities,
            quote: context.quote
          },
          chainId: client.chain.id,
          context: {
            ...context,
            account,
            calls,
            nonce: outputQuote == null ? void 0 : outputQuote.intent.nonce
          },
          digest,
          key,
          typedData
        };
      },
      async prepareUpgradeAccount(parameters2) {
        const { address: address2, email: email3, label, internal, permissions: permissions2 } = parameters2;
        const { client } = internal;
        const [tokens, feeToken2] = await Promise.all([
          getTokens(client),
          resolveFeeToken(client, {
            store: internal.store
          })
        ]);
        const adminKey = !mock ? await createWebAuthnP256({
          createFn: webAuthn == null ? void 0 : webAuthn.createFn,
          label: label || `${address2.slice(0, 8)}${address2.slice(-6)}`,
          rpId: keystoreHost,
          userId: from(address2)
        }) : createHeadlessWebAuthnP256();
        const sessionKey = await toKey2(permissions2, {
          chainId: client.chain.id,
          feeTokens: tokens
        });
        const { context, digests } = await prepareUpgradeAccount2(client, {
          address: address2,
          authorizeKeys: [adminKey, ...sessionKey ? [sessionKey] : []],
          feeToken: feeToken2 == null ? void 0 : feeToken2.address
        });
        if (email3)
          email_internal = label;
        return {
          context,
          digests
        };
      },
      async revokeAdmin(parameters2) {
        var _a2, _b, _c;
        const { account, id, internal } = parameters2;
        const { client } = internal;
        const key = (_a2 = account.keys) == null ? void 0 : _a2.find((key2) => key2.id === id);
        if (!key)
          return;
        if (key.type === "webauthn-p256" && ((_b = account.keys) == null ? void 0 : _b.filter((key2) => key2.type === "webauthn-p256").length) === 1)
          throw new Error("revoke the only WebAuthn key left.");
        try {
          const feeToken2 = await resolveFeeToken(client, {
            addressOrSymbol: parameters2.feeToken,
            store: internal.store
          });
          const { id: id2 } = await sendCalls(client, {
            account,
            feeToken: feeToken2 == null ? void 0 : feeToken2.address,
            revokeKeys: [key],
            webAuthn
          });
          await waitForCallsStatus(client, {
            id: id2
          });
        } catch (e) {
          const error46 = e;
          if (error46.name === "Rpc.ExecutionError" && ((_c = error46.abiError) == null ? void 0 : _c.name) === "KeyDoesNotExist")
            return;
          throw e;
        }
      },
      async revokePermissions(parameters2) {
        var _a2, _b;
        const { account, id, internal } = parameters2;
        const { client } = internal;
        const key = (_a2 = account.keys) == null ? void 0 : _a2.find((key2) => key2.id === id);
        if (!key)
          return;
        if (key.role === "admin")
          throw new Error("cannot revoke admins.");
        try {
          const feeToken2 = await resolveFeeToken(client, {
            addressOrSymbol: parameters2.feeToken,
            store: internal.store
          });
          const { id: id2 } = await sendCalls(client, {
            account,
            feeToken: feeToken2 == null ? void 0 : feeToken2.address,
            revokeKeys: [key],
            webAuthn
          });
          await waitForCallsStatus(client, {
            id: id2
          });
        } catch (e) {
          const error46 = e;
          if (error46.name === "Rpc.ExecutionError" && ((_b = error46.abiError) == null ? void 0 : _b.name) === "KeyDoesNotExist")
            return;
          throw e;
        }
      },
      async sendCalls(parameters2) {
        const { account, asTxHash, calls, chainId, internal, merchantUrl: merchantUrl2 } = parameters2;
        const { client } = internal;
        const key = await getAuthorizedExecuteKey({
          account,
          calls,
          permissionsId: parameters2.permissionsId
        });
        const [tokens, feeToken2] = await Promise.all([
          getTokens(client),
          resolveFeeToken(client, {
            addressOrSymbol: parameters2.feeToken,
            store: internal.store
          })
        ]);
        const requiredFunds3 = toRelay2(parameters2.requiredFunds ?? [], {
          tokens
        });
        const result = await sendCalls(client, {
          account,
          calls,
          feeToken: feeToken2 == null ? void 0 : feeToken2.address,
          key,
          merchantUrl: merchantUrl2,
          requiredFunds: multichain ? requiredFunds3 : void 0,
          webAuthn,
          ...chainId ? { chain: { id: chainId } } : {}
        });
        if (asTxHash) {
          const { id, receipts, status } = await waitForCallsStatus(client, {
            id: result.id,
            pollingInterval: 500
          });
          if (!(receipts == null ? void 0 : receipts[0])) {
            if (status === "success")
              throw new UnknownBundleIdError({
                message: "Call bundle with id: " + id + " not found."
              });
            throw new TransactionRejectedError({
              message: "Transaction failed under call bundle id: " + id + "."
            });
          }
          return {
            id: receipts[0].transactionHash
          };
        }
        return result;
      },
      async sendPreparedCalls(parameters2) {
        const { context, key, internal, signature } = parameters2;
        const { client } = internal;
        const { id } = await sendPreparedCalls2(client, {
          context,
          key,
          signature
        });
        return id;
      },
      async signPersonalMessage(parameters2) {
        var _a2;
        const { account, data, internal } = parameters2;
        const { client } = internal;
        const key = (_a2 = account.keys) == null ? void 0 : _a2.find((key2) => key2.role === "admin" && key2.privateKey);
        if (!key)
          throw new Error("cannot find admin key to sign with.");
        const signature = await sign6(account, {
          key,
          payload: getSignPayload3(data),
          webAuthn
        });
        return wrap2(client, { address: account.address, signature });
      },
      async signTypedData(parameters2) {
        var _a2, _b;
        const { account, internal } = parameters2;
        const { client } = internal;
        const key = (_a2 = account.keys) == null ? void 0 : _a2.find((key2) => key2.role === "admin" && key2.privateKey);
        if (!key)
          throw new Error("cannot find admin key to sign with.");
        const data = parse(parameters2.data);
        const isOrchestrator = ((_b = data.domain) == null ? void 0 : _b.name) === "Orchestrator";
        const signature = await sign6(account, {
          key,
          payload: getSignPayload2(data),
          // If the domain is the Orchestrator, we don't need to replay-safe sign.
          replaySafe: !isOrchestrator,
          webAuthn
        });
        return isOrchestrator ? signature : wrap2(client, { address: account.address, signature });
      },
      async upgradeAccount(parameters2) {
        const { account, context, internal, signatures } = parameters2;
        const { client } = internal;
        await upgradeAccount2(client, {
          context,
          signatures
        });
        if (email_internal)
          await setEmail2(client, {
            email: email_internal,
            walletAddress: account.address
          });
        return { account };
      },
      async verifyEmail(parameters2) {
        var _a2;
        const { account, chainId, email: email3, token, internal, walletAddress } = parameters2;
        const { client } = internal;
        const key = (_a2 = account.keys) == null ? void 0 : _a2.find((key2) => key2.role === "admin" && key2.privateKey);
        if (!key)
          throw new Error("cannot find admin key to sign with.");
        const signature = await sign6(account, {
          key,
          payload: keccak256(fromString2(`${email3}${token}`)),
          webAuthn
        });
        return await verifyEmail2(client, {
          chainId,
          email: email3,
          signature,
          token,
          walletAddress
        });
      }
    },
    config: parameters,
    name: "rpc"
  });
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/modes/dialog.js
function dialog(parameters = {}) {
  const { fallback: fallback2 = relay(), host = hostUrls.prod, renderer = iframe(), theme, themeController } = parameters;
  const listeners = /* @__PURE__ */ new Set();
  const requestStore = createStore3();
  function getProvider(store) {
    return from7({
      async request(r) {
        const request = requestStore.prepare(r);
        store.setState((x) => {
          var _a2;
          const account = x.accounts[0];
          const adminKey = (_a2 = account == null ? void 0 : account.keys) == null ? void 0 : _a2.find((key) => key.role === "admin" && key.type === "webauthn-p256");
          return {
            ...x,
            requestQueue: [
              ...x.requestQueue,
              {
                account: account ? {
                  address: account.address,
                  key: adminKey ? {
                    credentialId: adminKey == null ? void 0 : adminKey.credentialId,
                    publicKey: adminKey.publicKey
                  } : void 0
                } : void 0,
                request,
                status: "pending"
              }
            ]
          };
        });
        return new Promise((resolve, reject) => {
          const listener = (requestQueue) => {
            const queued = requestQueue.find((x) => x.request.id === request.id);
            if (!queued && requestQueue.length === 0) {
              listeners.delete(listener);
              reject(new UserRejectedRequestError());
              return;
            }
            if (!queued)
              return;
            if (queued.status !== "success" && queued.status !== "error")
              return;
            listeners.delete(listener);
            if (queued.status === "success")
              resolve(queued.result);
            else
              reject(parseError2(queued.error));
            store.setState((x) => ({
              ...x,
              requestQueue: x.requestQueue.filter((x2) => x2.request.id !== request.id)
            }));
          };
          listeners.add(listener);
        });
      }
    }, { schema: from16() });
  }
  return from14({
    actions: {
      async addFunds(parameters2) {
        const { internal } = parameters2;
        const { request, store } = internal;
        if (request.method !== "wallet_addFunds")
          throw new Error("Cannot add funds for method: " + request.method);
        const provider = getProvider(store);
        return await provider.request(request);
      },
      async createAccount(parameters2) {
        const { internal } = parameters2;
        const { client, config: config2, request, store } = internal;
        const { storage } = config2;
        const provider = getProvider(store);
        const account = await (async () => {
          var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j;
          if (request.method === "wallet_connect") {
            const [{ capabilities, chainIds }] = request._decoded.params ?? [{}];
            const authUrl = getAuthUrl(((_a2 = capabilities == null ? void 0 : capabilities.signInWithEthereum) == null ? void 0 : _a2.authUrl) ?? config2.authUrl, { storage });
            const signInWithEthereum2 = (_d = (_c = (_b = request.params) == null ? void 0 : _b[0]) == null ? void 0 : _c.capabilities) == null ? void 0 : _d.signInWithEthereum;
            const key = await toKey2(capabilities == null ? void 0 : capabilities.grantPermissions, {
              chainId: client.chain.id
            });
            const permissionsRequest = key ? encode2(Schema2, fromKey2(key)) : void 0;
            const { accounts } = await provider.request({
              ...request,
              params: [
                {
                  capabilities: {
                    ...(_f = (_e = request.params) == null ? void 0 : _e[0]) == null ? void 0 : _f.capabilities,
                    grantPermissions: permissionsRequest,
                    signInWithEthereum: authUrl || signInWithEthereum2 ? {
                      ...signInWithEthereum2,
                      authUrl
                    } : void 0
                  },
                  chainIds: chainIds == null ? void 0 : chainIds.map((chainId) => fromNumber(chainId))
                }
              ]
            });
            const [account2] = accounts;
            if (!account2)
              throw new Error("no account found.");
            const adminKeys = (_h = (_g = account2.capabilities) == null ? void 0 : _g.admins) == null ? void 0 : _h.map((admin) => from11(admin, { chainId: client.chain.id })).filter(Boolean);
            const sessionKeys = (_j = (_i = account2.capabilities) == null ? void 0 : _i.permissions) == null ? void 0 : _j.map((permission) => {
              try {
                const key_permission = toKey(decode(Schema, permission));
                if (key_permission.id === (key == null ? void 0 : key.id))
                  return {
                    ...key_permission,
                    ...key,
                    permissions: key_permission.permissions
                  };
                return key_permission;
              } catch {
                return void 0;
              }
            }).filter(Boolean);
            const signInWithEthereum_response = await (async () => {
              var _a3, _b2, _c2, _d2;
              if (!((_a3 = account2.capabilities) == null ? void 0 : _a3.signInWithEthereum))
                return;
              const { message, signature } = account2.capabilities.signInWithEthereum;
              if (!authUrl)
                return {
                  message,
                  signature
                };
              const { token } = await authenticate({
                address: account2.address,
                authUrl,
                message,
                publicKey: (_d2 = (_c2 = (_b2 = account2.capabilities) == null ? void 0 : _b2.admins) == null ? void 0 : _c2[0]) == null ? void 0 : _d2.publicKey,
                signature
              });
              return {
                message,
                signature,
                token
              };
            })();
            return {
              ...from12({
                address: account2.address,
                keys: [...adminKeys ?? [], ...sessionKeys ?? []]
              }),
              signInWithEthereum: signInWithEthereum_response
            };
          }
          throw new Error(`Account creation not supported on method: ${request.method}`);
        })();
        return {
          account
        };
      },
      async disconnect(parameters2) {
        const { internal } = parameters2;
        const { config: config2 } = internal;
        const { storage } = config2;
        const authUrl_storage = await storage.getItem("porto.authUrl") || void 0;
        const authUrl = getAuthUrl(config2.authUrl ?? authUrl_storage, {
          storage
        });
        if (authUrl)
          await fetch(authUrl.logout, {
            credentials: "include",
            method: "POST"
          }).catch(() => {
          });
      },
      async getAccountVersion(parameters2) {
        const { internal } = parameters2;
        const { store, request } = internal;
        if (request.method !== "wallet_getAccountVersion")
          throw new Error("Cannot get version for method: " + request.method);
        if (!renderer.supportsHeadless)
          return fallback2.actions.getAccountVersion(parameters2);
        const provider = getProvider(store);
        const result = await provider.request(request);
        return result;
      },
      async getAssets(parameters2) {
        const { internal } = parameters2;
        const { store, request } = internal;
        if (request.method !== "wallet_getAssets")
          throw new Error("Cannot get assets for method: " + request.method);
        if (!renderer.supportsHeadless)
          return fallback2.actions.getAssets(parameters2);
        const provider = getProvider(store);
        const result = await provider.request(request);
        return decode(wallet_getAssets2.Response, result);
      },
      async getCallsStatus(parameters2) {
        const { internal } = parameters2;
        const { store, request } = internal;
        if (request.method !== "wallet_getCallsStatus")
          throw new Error("Cannot get status for method: " + request.method);
        if (!renderer.supportsHeadless)
          return fallback2.actions.getCallsStatus(parameters2);
        const provider = getProvider(store);
        const result = await provider.request(request);
        return result;
      },
      async getCapabilities(parameters2) {
        const { internal } = parameters2;
        const { store, request } = internal;
        if (request.method !== "wallet_getCapabilities")
          throw new Error("Cannot get capabilities for method: " + request.method);
        if (!renderer.supportsHeadless)
          return fallback2.actions.getCapabilities(parameters2);
        const provider = getProvider(store);
        const result = await provider.request(request);
        return result;
      },
      async getKeys(parameters2) {
        const { account, chainIds, internal } = parameters2;
        const { store } = internal;
        const keys = await (async () => {
          if (!renderer.supportsHeadless)
            return fallback2.actions.getKeys(parameters2);
          const provider = getProvider(store);
          const result = await provider.request({
            method: "wallet_getKeys",
            params: [
              encode2(wallet_getKeys2.Parameters, {
                address: account.address,
                chainIds
              })
            ]
          });
          return decode(wallet_getKeys2.Response, result);
        })();
        return uniqBy([...keys, ...account.keys ?? []], (key) => key.publicKey);
      },
      async grantAdmin(parameters2) {
        var _a2, _b, _c;
        const { internal } = parameters2;
        const { request, store } = internal;
        if (request.method !== "wallet_grantAdmin")
          throw new Error("Cannot authorize admin for method: " + request.method);
        const [params] = request._decoded.params;
        const key = from11(params.key);
        if (!key)
          throw new Error("no key found.");
        const feeToken2 = await resolveFeeToken2(internal, parameters2);
        const provider = getProvider(store);
        await provider.request({
          method: "wallet_grantAdmin",
          params: [
            {
              ...(_a2 = request.params) == null ? void 0 : _a2[0],
              capabilities: {
                ...(_c = (_b = request.params) == null ? void 0 : _b[0]) == null ? void 0 : _c.capabilities,
                feeToken: feeToken2
              }
            }
          ]
        });
        return { key };
      },
      async grantPermissions(parameters2) {
        const { internal } = parameters2;
        const { client, request, store } = internal;
        if (request.method !== "wallet_grantPermissions")
          throw new Error("Cannot grant permissions for method: " + request.method);
        const [{ address: address2, ...permissions2 }] = request._decoded.params;
        const key = await toKey2(permissions2, {
          chainId: client.chain.id
        });
        if (!key)
          throw new Error("no key found.");
        const permissionsRequest = encode2(Schema2, fromKey2(key));
        const provider = getProvider(store);
        await provider.request({
          method: "wallet_grantPermissions",
          params: [permissionsRequest]
        });
        return { key };
      },
      async loadAccounts(parameters2) {
        const { internal } = parameters2;
        const { client, config: config2, store } = internal;
        const { storage } = config2;
        const provider = getProvider(store);
        const request = internal.request;
        if (request.method !== "wallet_connect" && request.method !== "eth_requestAccounts")
          throw new Error("Cannot load accounts for method: " + request.method);
        const accounts = await (async () => {
          var _a2, _b, _c, _d, _e, _f, _g;
          const [params] = request._decoded.params ?? [];
          const { capabilities } = params ?? {};
          const authUrl = getAuthUrl(((_a2 = capabilities == null ? void 0 : capabilities.signInWithEthereum) == null ? void 0 : _a2.authUrl) ?? config2.authUrl, { storage });
          const signInWithEthereum2 = (_d = (_c = (_b = request.params) == null ? void 0 : _b[0]) == null ? void 0 : _c.capabilities) == null ? void 0 : _d.signInWithEthereum;
          const key = await toKey2(capabilities == null ? void 0 : capabilities.grantPermissions, {
            chainId: client.chain.id
          });
          const permissionsRequest = key ? encode2(Schema2, fromKey2(key)) : void 0;
          const { accounts: accounts2 } = await provider.request({
            method: "wallet_connect",
            params: [
              {
                ...(_e = request.params) == null ? void 0 : _e[0],
                capabilities: {
                  ...(_g = (_f = request.params) == null ? void 0 : _f[0]) == null ? void 0 : _g.capabilities,
                  grantPermissions: permissionsRequest,
                  signInWithEthereum: authUrl || signInWithEthereum2 ? {
                    ...signInWithEthereum2,
                    authUrl
                  } : void 0
                }
              }
            ]
          });
          return Promise.all(accounts2.map(async (account) => {
            var _a3, _b2, _c2, _d2;
            const adminKeys = (_b2 = (_a3 = account.capabilities) == null ? void 0 : _a3.admins) == null ? void 0 : _b2.map((key2) => from11(key2)).filter(Boolean);
            const sessionKeys = (_d2 = (_c2 = account.capabilities) == null ? void 0 : _c2.permissions) == null ? void 0 : _d2.map((permission) => {
              try {
                const key_permission = toKey(decode(Schema, permission));
                if (key_permission.id === (key == null ? void 0 : key.id))
                  return {
                    ...key_permission,
                    ...key,
                    permissions: key_permission.permissions
                  };
                return key_permission;
              } catch {
                return void 0;
              }
            }).filter(Boolean);
            const signInWithEthereum_response = await (async () => {
              var _a4, _b3, _c3, _d3;
              if (!((_a4 = account.capabilities) == null ? void 0 : _a4.signInWithEthereum))
                return;
              const { message, signature } = account.capabilities.signInWithEthereum;
              if (!authUrl)
                return {
                  message,
                  signature
                };
              const { token } = await authenticate({
                address: account.address,
                authUrl,
                message,
                publicKey: (_d3 = (_c3 = (_b3 = account.capabilities) == null ? void 0 : _b3.admins) == null ? void 0 : _c3[0]) == null ? void 0 : _d3.publicKey,
                signature
              });
              return {
                message,
                signature,
                token
              };
            })();
            return {
              ...from12({
                address: account.address,
                keys: [...adminKeys ?? [], ...sessionKeys ?? []]
              }),
              signInWithEthereum: signInWithEthereum_response
            };
          }));
        })();
        return {
          accounts
        };
      },
      async prepareCalls(parameters2) {
        var _a2, _b, _c;
        const { account, internal } = parameters2;
        const { store, request } = internal;
        if (request.method !== "wallet_prepareCalls")
          throw new Error("Cannot prepare calls for method: " + request.method);
        if (!renderer.supportsHeadless)
          return fallback2.actions.prepareCalls(parameters2);
        const feeToken2 = await resolveFeeToken2(internal, parameters2);
        const provider = getProvider(store);
        const result = decode(wallet_prepareCalls2.Response, await provider.request({
          ...request,
          params: [
            {
              ...(_a2 = request.params) == null ? void 0 : _a2[0],
              capabilities: {
                ...(_c = (_b = request.params) == null ? void 0 : _b[0]) == null ? void 0 : _c.capabilities,
                feeToken: feeToken2
              }
            }
          ]
        }));
        return {
          account,
          chainId: Number(result.chainId),
          context: result.context,
          digest: result.digest,
          key: result.key,
          typedData: result.typedData
        };
      },
      async prepareUpgradeAccount(parameters2) {
        var _a2, _b, _c, _d;
        const { internal } = parameters2;
        const { client, store, request } = internal;
        if (request.method !== "wallet_prepareUpgradeAccount")
          throw new Error("Cannot prepare upgrade for method: " + request.method);
        if (!renderer.supportsHeadless)
          return fallback2.actions.prepareUpgradeAccount(parameters2);
        const [{ capabilities }] = request._decoded.params ?? [{}];
        const key = await toKey2(capabilities == null ? void 0 : capabilities.grantPermissions, {
          chainId: client.chain.id
        });
        const permissionsRequest = key ? encode2(Schema2, fromKey2(key)) : void 0;
        const provider = getProvider(store);
        const { context, digests } = await provider.request({
          ...request,
          params: [
            {
              ...(_a2 = request.params) == null ? void 0 : _a2[0],
              capabilities: {
                ...(_c = (_b = request.params) == null ? void 0 : _b[0]) == null ? void 0 : _c.capabilities,
                grantPermissions: permissionsRequest
              }
            }
          ]
        });
        const keys = (_d = context.account.keys) == null ? void 0 : _d.map((k) => {
          if (k.id === (key == null ? void 0 : key.id))
            return { ...k, ...key };
          return k;
        });
        return {
          context: {
            ...context,
            account: { ...context.account, keys }
          },
          digests
        };
      },
      async revokeAdmin(parameters2) {
        var _a2, _b, _c, _d, _e;
        const { account, id, internal } = parameters2;
        const { store, request } = internal;
        if (request.method !== "wallet_revokeAdmin")
          throw new Error("Cannot revoke admin for method: " + request.method);
        const key = (_a2 = account.keys) == null ? void 0 : _a2.find((key2) => key2.id === id);
        if (!key)
          return;
        if (key.type === "webauthn-p256" && ((_b = account.keys) == null ? void 0 : _b.filter((key2) => key2.type === "webauthn-p256").length) === 1)
          throw new Error("revoke the only WebAuthn key left.");
        const feeToken2 = await resolveFeeToken2(internal, parameters2);
        const provider = getProvider(store);
        return await provider.request({
          ...request,
          params: [
            {
              ...(_c = request.params) == null ? void 0 : _c[0],
              capabilities: {
                ...(_e = (_d = request.params) == null ? void 0 : _d[0]) == null ? void 0 : _e.capabilities,
                feeToken: feeToken2
              }
            }
          ]
        });
      },
      async revokePermissions(parameters2) {
        var _a2;
        const { account, id, internal } = parameters2;
        const { store, request } = internal;
        if (request.method !== "wallet_revokePermissions")
          throw new Error("Cannot revoke permissions for method: " + request.method);
        const key = (_a2 = account.keys) == null ? void 0 : _a2.find((key2) => key2.id === id);
        if (!key)
          return;
        if (key.role === "admin")
          throw new Error("cannot revoke permissions.");
        const provider = getProvider(store);
        return await provider.request(request);
      },
      async sendCalls(parameters2) {
        var _a2, _b, _c, _d, _e, _f, _g, _h;
        const { account, asTxHash, calls, chainId, internal, merchantUrl: merchantUrl2, requiredFunds: requiredFunds3 } = parameters2;
        const { client, store, request } = internal;
        const provider = getProvider(store);
        const feeToken2 = await resolveFeeToken2(internal, parameters2);
        const key = await getAuthorizedExecuteKey({
          account,
          calls,
          permissionsId: parameters2.permissionsId
        });
        if (key && key.role === "session") {
          if (!renderer.supportsHeadless)
            return fallback2.actions.sendCalls(parameters2);
          try {
            const req = await provider.request(encode2(wallet_prepareCalls2.Request, {
              method: "wallet_prepareCalls",
              params: [
                {
                  calls,
                  capabilities: {
                    ...request._decoded.method === "wallet_sendCalls" ? (_b = (_a2 = request._decoded.params) == null ? void 0 : _a2[0]) == null ? void 0 : _b.capabilities : void 0,
                    feeToken: feeToken2,
                    merchantUrl: merchantUrl2,
                    requiredFunds: requiredFunds3
                  },
                  chainId,
                  from: account.address,
                  key
                }
              ]
            }));
            const quotes = ((_d = (_c = req.capabilities) == null ? void 0 : _c.quote) == null ? void 0 : _d.quotes) ?? [];
            const hasFeeDeficit = quotes.some((quote, index) => {
              const isMultichainDestination = index === quotes.length - 1 && quotes.length > 1;
              if (isMultichainDestination)
                return false;
              return toBigInt2(quote.feeTokenDeficit) > 0n;
            });
            if (hasFeeDeficit)
              throw new Error("insufficient funds");
            const signature = await sign5(key, {
              address: null,
              payload: req.digest,
              wrap: false
            });
            const result = await provider.request({
              method: "wallet_sendPreparedCalls",
              params: [
                {
                  ...req,
                  signature
                }
              ]
            });
            const response = result[0];
            if (!response)
              throw new Error("id not found");
            if (asTxHash) {
              const { id, receipts, status } = await waitForCallsStatus(client, {
                id: response.id,
                pollingInterval: 500
              });
              if (!(receipts == null ? void 0 : receipts[0])) {
                if (status === "success")
                  throw new UnknownBundleIdError({
                    message: "Call bundle with id: " + id + " not found."
                  });
                throw new TransactionRejectedError({
                  message: "Transaction failed under call bundle id: " + id + "."
                });
              }
              return {
                id: receipts[0].transactionHash
              };
            }
            return response;
          } catch {
          }
        }
        if (request.method === "eth_sendTransaction") {
          const id = await provider.request({
            ...request,
            params: [
              {
                ...(_e = request.params) == null ? void 0 : _e[0],
                // @ts-expect-error
                capabilities: {
                  feeToken: feeToken2,
                  merchantUrl: merchantUrl2
                },
                ...chainId ? { chainId: fromNumber(chainId) } : {}
              }
            ]
          });
          return { id };
        }
        if (request.method === "wallet_sendCalls") {
          const result = await provider.request({
            method: "wallet_sendCalls",
            params: [
              {
                ...(_f = request.params) == null ? void 0 : _f[0],
                capabilities: {
                  ...(_h = (_g = request.params) == null ? void 0 : _g[0]) == null ? void 0 : _h.capabilities,
                  feeToken: feeToken2,
                  merchantUrl: merchantUrl2
                },
                ...chainId ? { chainId: fromNumber(chainId) } : {}
              }
            ]
          });
          return result;
        }
        throw new Error("Cannot execute for method: " + request.method);
      },
      async sendPreparedCalls(parameters2) {
        var _a2;
        const { internal } = parameters2;
        const { store, request } = internal;
        if (request.method !== "wallet_sendPreparedCalls")
          throw new Error("Cannot send prepared calls for method: " + request.method);
        if (!renderer.supportsHeadless)
          return fallback2.actions.sendPreparedCalls(parameters2);
        const provider = getProvider(store);
        const result = await provider.request(request);
        const id = (_a2 = result[0]) == null ? void 0 : _a2.id;
        if (!id)
          throw new Error("id not found");
        return id;
      },
      async signPersonalMessage(parameters2) {
        const { internal } = parameters2;
        const { store, request } = internal;
        if (request.method !== "personal_sign")
          throw new Error("Cannot sign personal message for method: " + request.method);
        const provider = getProvider(store);
        return await provider.request(request);
      },
      async signTypedData(parameters2) {
        const { internal } = parameters2;
        const { store, request } = internal;
        if (request.method !== "eth_signTypedData_v4")
          throw new Error("Cannot sign typed data for method: " + request.method);
        const provider = getProvider(store);
        return await provider.request(request);
      },
      async switchChain(parameters2) {
        const { internal } = parameters2;
        const { store, request } = internal;
        if (request.method !== "wallet_switchEthereumChain")
          throw new Error("Cannot switch chain for method: " + request.method);
        if (!renderer.supportsHeadless)
          return;
        const provider = getProvider(store);
        return await provider.request(request);
      },
      async upgradeAccount(parameters2) {
        const { account, internal } = parameters2;
        const { store, request } = internal;
        if (request.method !== "wallet_upgradeAccount")
          throw new Error("Cannot upgrade account for method: " + request.method);
        const provider = getProvider(store);
        await provider.request(request);
        return { account };
      },
      async verifyEmail(parameters2) {
        const { internal } = parameters2;
        const { request, store } = internal;
        if (request.method !== "account_verifyEmail")
          throw new Error("Cannot verify email for method: " + request.method);
        const provider = getProvider(store);
        return await provider.request(request);
      }
    },
    config: parameters,
    name: "dialog",
    setup(parameters2) {
      const { internal } = parameters2;
      const { store } = internal;
      const dialog2 = renderer.setup({
        host,
        internal,
        theme,
        themeController
      });
      const unsubscribe = store.subscribe((x) => x.requestQueue, (requestQueue) => {
        for (const listener of listeners)
          listener(requestQueue);
        const requests = requestQueue.map((x) => x.status === "pending" ? x : void 0).filter(Boolean);
        dialog2.syncRequests(requests).catch(() => {
        });
        if (requests.length === 0)
          dialog2.close();
      });
      return () => {
        unsubscribe();
        dialog2.destroy();
      };
    }
  });
}
async function resolveFeeToken2(internal, parameters) {
  const { config: { feeToken: feeToken2 } } = internal;
  const { feeToken: overrideFeeToken } = parameters ?? {};
  return overrideFeeToken ?? feeToken2;
}
function getAuthUrl(apiUrl, { storage }) {
  if (!apiUrl)
    return void 0;
  const authUrl = resolveAuthUrl(apiUrl, typeof window !== "undefined" ? window.location.origin : void 0);
  if (authUrl)
    storage.setItem("porto.authUrl", authUrl);
  return authUrl;
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/modes/reactNative.js
function reactNative2(parameters = {}) {
  if (!isReactNative())
    return parameters.fallback ?? from14({ actions: relay().actions, name: "relay" });
  const { redirectUri, requestOptions, ...baseParameters } = parameters;
  return from14({
    ...dialog({
      ...baseParameters,
      renderer: authSession({ redirectUri, requestOptions })
    }),
    name: "reactNative"
  });
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/internal/types.js
var types_exports = {};

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/Porto.js
var Porto_exports = {};
__export(Porto_exports, {
  create: () => create2,
  defaultConfig: () => defaultConfig
});

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/Storage.js
var Storage_exports = {};
__export(Storage_exports, {
  combine: () => combine,
  cookie: () => cookie,
  from: () => from18,
  idb: () => idb,
  localStorage: () => localStorage,
  memory: () => memory
});
function from18(storage) {
  return storage;
}
function combine(...storages) {
  return {
    async getItem(name) {
      const results = await Promise.allSettled(storages.map((x) => x.getItem(name)));
      const result = results.find((x) => x.status === "fulfilled" && x.value !== null);
      if ((result == null ? void 0 : result.status) !== "fulfilled")
        return null;
      if (result.value === null)
        return null;
      return result.value;
    },
    async removeItem(name) {
      await Promise.allSettled(storages.map((x) => x.removeItem(name)));
    },
    async setItem(name, value) {
      await Promise.allSettled(storages.map((x) => x.setItem(name, value)));
    },
    sizeLimit: Math.min(...storages.map((x) => x.sizeLimit)),
    storages
  };
}
function idb() {
  const store = typeof indexedDB !== "undefined" ? createStore2("porto", "store") : void 0;
  return from18({
    async getItem(name) {
      const value = await get(name, store);
      if (value === null)
        return null;
      return value;
    },
    async removeItem(name) {
      await del(name, store);
    },
    async setItem(name, value) {
      await set(name, normalizeValue(value), store);
    },
    sizeLimit: 1024 * 1024 * 50
    // 50MB
  });
}
function localStorage() {
  return from18({
    async getItem(name) {
      const item = window.localStorage.getItem(name);
      if (item === null)
        return null;
      try {
        return parse(item);
      } catch {
        return null;
      }
    },
    async removeItem(name) {
      window.localStorage.removeItem(name);
    },
    async setItem(name, value) {
      window.localStorage.setItem(name, stringify(value));
    },
    sizeLimit: 1024 * 1024 * 5
    // 5MB
  });
}
function cookie() {
  return from18({
    async getItem(name) {
      const value = document.cookie.split("; ").find((x) => x.startsWith(`${name}=`));
      if (!value)
        return null;
      try {
        return parse(value.substring(name.length + 1));
      } catch {
        return null;
      }
    },
    async removeItem(name) {
      document.cookie = `${name}=;max-age=-1;path=/`;
    },
    async setItem(name, value) {
      document.cookie = `${name}=${stringify(value)};path=/;samesite=None;secure;max-age=31536000`;
    },
    sizeLimit: 1024 * 4
    // 4kB
  });
}
function memory() {
  const store = /* @__PURE__ */ new Map();
  return from18({
    getItem(name) {
      return store.get(name) ?? null;
    },
    removeItem(name) {
      store.delete(name);
    },
    setItem(name, value) {
      store.set(name, value);
    },
    sizeLimit: Number.POSITIVE_INFINITY
  });
}

// node_modules/@wagmi/connectors/node_modules/porto/dist/core/Porto.js
var browser = typeof window !== "undefined" && typeof document !== "undefined";
var defaultConfig = {
  announceProvider: true,
  chains: all,
  mode: browser ? dialog({ host: hostUrls.prod }) : relay(),
  relay: http(relayUrls.prod.http),
  storage: browser && typeof indexedDB !== "undefined" ? idb() : memory(),
  storageKey: "porto.store"
};
function create2(parameters = {}) {
  const chains = parameters.chains ?? defaultConfig.chains;
  const transports = Object.fromEntries(chains.map((chain) => {
    var _a2;
    return [
      chain.id,
      ((_a2 = parameters.transports) == null ? void 0 : _a2[chain.id]) ?? http()
    ];
  }));
  const config2 = {
    announceProvider: parameters.announceProvider ?? defaultConfig.announceProvider,
    authUrl: parameters.authUrl,
    chains,
    feeToken: parameters.feeToken,
    merchantUrl: parameters.merchantUrl,
    mode: parameters.mode ?? defaultConfig.mode,
    relay: parameters.relay ?? defaultConfig.relay,
    storage: parameters.storage ?? defaultConfig.storage,
    storageKey: parameters.storageKey ?? defaultConfig.storageKey,
    transports
  };
  const store = createStore(devtools(subscribeWithSelector(persist((_) => ({
    accounts: [],
    chainIds: config2.chains.map((chain) => chain.id),
    feeToken: config2.feeToken,
    requestQueue: []
  }), {
    merge(p, currentState) {
      var _a2;
      const persistedState = p;
      const currentChainId = ((_a2 = config2.chains.find((chain) => chain.id === persistedState.chainIds[0])) == null ? void 0 : _a2.id) ?? config2.chains[0].id;
      const chainIds = [
        currentChainId,
        ...config2.chains.map((chain) => chain.id).filter((id) => id !== currentChainId)
      ];
      return {
        ...currentState,
        ...persistedState,
        chainIds
      };
    },
    name: config2.storageKey,
    partialize: (state) => ({
      accounts: state.accounts.map((account) => (
        // omit non-serializable properties (e.g. functions).
        normalizeValue(account)
      )),
      chainIds: state.chainIds
    }),
    storage: config2.storage,
    version: 5
  }))));
  let mode = config2.mode;
  const internal = {
    config: config2,
    getMode() {
      return mode;
    },
    id: uuidv4(),
    setMode(i) {
      destroy == null ? void 0 : destroy();
      mode = i;
      destroy = i.setup({
        internal
      });
      return destroy;
    },
    store
  };
  const provider = from13(internal);
  let destroy = mode !== null ? mode.setup({
    internal
  }) : () => {
  };
  return {
    _internal: internal,
    config: config2,
    destroy() {
      destroy();
      provider._internal.destroy();
    },
    provider
  };
}

export {
  Chains_exports,
  Messenger_exports,
  Dialog_exports,
  mini_exports,
  call_exports,
  Key_exports,
  Account_exports,
  Transport_exports,
  from13 as from,
  RpcSchema_exports,
  RelayActions_exports,
  Mode_exports,
  Storage_exports,
  Porto_exports
};
//# sourceMappingURL=chunk-RZL5TIPK.js.map
