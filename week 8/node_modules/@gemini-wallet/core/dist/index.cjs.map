{"version":3,"sources":["../src/index.ts","../src/communicator.ts","../src/constants.ts","../package.json","../src/types.ts","../src/utils/base64.ts","../src/utils/calculateWalletAddress.ts","../src/utils/ens.ts","../src/utils/popup.ts","../src/utils/strings.ts","../src/provider/provider.ts","../src/storage/storage.ts","../src/storage/storageInterface.ts","../src/wallets/wallet.ts","../src/provider/provider.utils.ts"],"sourcesContent":["// Main exports\nexport { Communicator } from \"./communicator\";\n\n// Provider exports\nexport { GeminiWalletProvider } from \"./provider\";\nexport * from \"./provider/provider.utils\";\n\n// Wallet exports\nexport { GeminiWallet, isChainSupportedByGeminiSw } from \"./wallets\";\n\n// Storage exports\nexport type { GeminiStorageConfig, IStorage } from \"./storage\";\nexport {\n  GeminiStorage,\n  STORAGE_CALL_BATCHES_KEY,\n  STORAGE_ETH_ACCOUNTS_KEY,\n  STORAGE_ETH_ACTIVE_CHAIN_KEY,\n  STORAGE_PASSKEY_CREDENTIAL_KEY,\n  STORAGE_PRESERVED_PASSKEY_CREDENTIALS_KEY,\n  STORAGE_SETTINGS_KEY,\n  STORAGE_SMART_ACCOUNT_KEY,\n  STORAGE_WC_REQUESTS_KEY,\n} from \"./storage\";\n\n// Type exports\nexport type {\n  AppContext,\n  AppMetadata,\n  Call,\n  CallBatchMetadata,\n  Chain,\n  ConnectResponse,\n  GeminiProviderConfig,\n  GeminiSdkAppContextMessage,\n  GeminiSdkMessage,\n  GeminiSdkMessageResponse,\n  GeminiSdkSendBatchCalls,\n  GeminiSdkSendTransaction,\n  GeminiSdkSignMessage,\n  GeminiSdkSignTypedData,\n  GeminiSdkSwitchChain,\n  GetCallsStatusResponse,\n  ProviderEventCallback,\n  ProviderEventMap,\n  ProviderInterface,\n  ProviderRpcError,\n  ReverseEnsResponse,\n  RpcRequestArgs,\n  SendCallsParams,\n  SendCallsResponse,\n  SendTransactionResponse,\n  SignMessageResponse,\n  SignTypedDataResponse,\n  SwitchChainResponse,\n  WalletCapabilities,\n} from \"./types\";\nexport { GeminiSdkEvent, PlatformType, ProviderEventEmitter } from \"./types\";\n\n// Utility exports\nexport type { CalculateWalletAddressParams, WebAuthnValidatorData } from \"./utils\";\nexport {\n  base64ToHex,\n  bufferToBase64URLString,\n  calculateV1Address,\n  calculateWalletAddress,\n  closePopup,\n  decodeBase64,\n  encodeBase64,\n  generateAuthenticatorIdHash,\n  hexStringFromNumber,\n  openPopup,\n  reverseResolveEns,\n  safeJsonStringify,\n  utf8StringToBuffer,\n  validateWebAuthnKey,\n} from \"./utils\";\n\n// Constants\nexport { DEFAULT_CHAIN_ID, POPUP_HEIGHT, POPUP_WIDTH, SDK_BACKEND_URL, SDK_VERSION } from \"./constants\";\n","import { providerErrors, rpcErrors } from \"@metamask/rpc-errors\";\n\nimport { DEFAULT_CHAIN_ID } from \"./constants\";\nimport {\n  AppContext,\n  type AppMetadata,\n  GeminiSdkEvent,\n  type GeminiSdkMessage,\n  type GeminiSdkMessageResponse,\n} from \"./types\";\nimport { closePopup, openPopup, SDK_BACKEND_URL, SDK_VERSION } from \"./utils\";\n\ntype CommunicatorConfigParams = {\n  appMetadata: AppMetadata;\n  onDisconnectCallback?: () => void;\n};\n\n// creates and communicates with a popup window to send and receive messages\nexport class Communicator {\n  private readonly appMetadata: AppMetadata;\n  private readonly url: URL;\n  private popup: Window | null = null;\n  private listeners = new Map<(_: MessageEvent) => void, { reject: (_: Error) => void }>();\n  private onDisconnectCallback?: () => void;\n\n  constructor({ appMetadata, onDisconnectCallback }: CommunicatorConfigParams) {\n    this.url = new URL(SDK_BACKEND_URL);\n    this.appMetadata = appMetadata;\n    this.onDisconnectCallback = onDisconnectCallback;\n  }\n\n  // posts a message to the popup window\n  postMessage = async (message: GeminiSdkMessage) => {\n    const popup = await this.waitForPopupLoaded();\n    popup.postMessage(message, this.url.origin);\n  };\n\n  // posts a request to the popup window and waits for a response\n  postRequestAndWaitForResponse = async <M extends GeminiSdkMessage, R extends GeminiSdkMessageResponse>(\n    request: GeminiSdkMessage,\n  ): Promise<R> => {\n    const responsePromise = this.onMessage<M, R>(({ requestId }) => requestId === request.requestId);\n    this.postMessage(request);\n    return await responsePromise;\n  };\n\n  // listens for messages from the popup window that match a given predicate\n  onMessage = <M extends GeminiSdkMessage, R extends GeminiSdkMessageResponse>(\n    predicate: (_: Partial<M>) => boolean,\n  ): Promise<R> => {\n    return new Promise((resolve, reject) => {\n      const listener = (event: MessageEvent<M>) => {\n        // ensure origin of message\n        if (event.origin !== this.url.origin) return;\n\n        const message = event.data;\n        if (predicate(message)) {\n          resolve(message as unknown as R);\n          window.removeEventListener(\"message\", listener);\n          this.listeners.delete(listener);\n        }\n      };\n\n      window.addEventListener(\"message\", listener);\n      this.listeners.set(listener, { reject });\n    });\n  };\n\n  // closes the popup, rejects all requests and clears event listeners\n  private onRequestCancelled = () => {\n    closePopup(this.popup);\n    this.popup = null;\n\n    this.listeners.forEach(({ reject }, listener) => {\n      reject(providerErrors.userRejectedRequest());\n      window.removeEventListener(\"message\", listener);\n    });\n    this.listeners.clear();\n  };\n\n  // waits for the popup window to fully load and then sends a version message\n  waitForPopupLoaded = (): Promise<Window> => {\n    if (this.popup && !this.popup.closed) {\n      // in case the user un-focused the popup between requests, focus it again\n      this.popup.focus();\n      return Promise.resolve(this.popup);\n    }\n\n    this.popup = openPopup(this.url);\n\n    // setup popup closed listener in case user closes window without explicit response\n    this.onMessage<GeminiSdkMessage, GeminiSdkMessageResponse>(({ event }) => event === GeminiSdkEvent.POPUP_UNLOADED)\n      .then(this.onRequestCancelled)\n      .catch(() => {});\n\n    // setup account disconnect listener in case user requests disconnect from within popup\n    this.onMessage<GeminiSdkMessage, GeminiSdkMessageResponse>(({ event }) => event === GeminiSdkEvent.SDK_DISCONNECT)\n      .then(() => {\n        // invoke disconnect callback passed in from wallet\n        this.onDisconnectCallback?.();\n        // cleanup remaining event listeners\n        this.onRequestCancelled();\n      })\n      .catch(() => {});\n\n    return this.onMessage<GeminiSdkMessage, GeminiSdkMessageResponse>(\n      ({ event }) => event === GeminiSdkEvent.POPUP_LOADED,\n    )\n      .then(message => {\n        // report app metadata to backend upon load complete\n        this.postMessage({\n          chainId: DEFAULT_CHAIN_ID,\n          data: {\n            appMetadata: this.appMetadata,\n            origin: window.location.origin,\n            sdkVersion: SDK_VERSION,\n          } as AppContext,\n          event: GeminiSdkEvent.POPUP_APP_CONTEXT,\n          origin: window.location.origin,\n          requestId: message.requestId,\n        });\n      })\n      .then(() => {\n        if (!this.popup) throw rpcErrors.internal();\n        return this.popup;\n      });\n  };\n}\n","import {\n  arbitrum,\n  arbitrumSepolia,\n  base,\n  baseSepolia,\n  mainnet,\n  optimism,\n  optimismSepolia,\n  polygon,\n  polygonAmoy,\n  sepolia,\n} from \"viem/chains\";\n\nimport packageJson from \"../package.json\";\n\nconst DEFAULT_BACKEND_URL = \"https://keys.gemini.com\";\n\nexport const SDK_BACKEND_URL = undefined || DEFAULT_BACKEND_URL;\nexport const ENS_API_URL = \"https://horizon-api.gemini.com/api/ens\";\nexport const SDK_VERSION = packageJson.version;\nexport const DEFAULT_CHAIN_ID = 42161; // Arbitrum One\n\n// Mainnet chain IDs\nexport const MAINNET_CHAIN_IDS = {\n  ARBITRUM_ONE: 42161,\n  BASE: 8453,\n  ETHEREUM: 1,\n  OP_MAINNET: 10,\n  POLYGON: 137,\n} as const;\n\n// Testnet chain IDs\nexport const TESTNET_CHAIN_IDS = {\n  ARBITRUM_SEPOLIA: 421614,\n  BASE_SEPOLIA: 84532,\n  OP_SEPOLIA: 11155420,\n  POLYGON_AMOY: 80002,\n  SEPOLIA: 11155111,\n} as const;\n\n// All supported chain IDs\nexport const SUPPORTED_CHAIN_IDS = [...Object.values(MAINNET_CHAIN_IDS), ...Object.values(TESTNET_CHAIN_IDS)];\n\n// Helper function to get default RPC URL for a chain using viem chains\nexport function getDefaultRpcUrl(chainId: number): string | undefined {\n  const chainMap: Record<number, string> = {\n    [mainnet.id]: mainnet.rpcUrls.default.http[0],\n    [arbitrum.id]: arbitrum.rpcUrls.default.http[0],\n    [optimism.id]: optimism.rpcUrls.default.http[0],\n    [base.id]: base.rpcUrls.default.http[0],\n    [polygon.id]: polygon.rpcUrls.default.http[0],\n    [sepolia.id]: sepolia.rpcUrls.default.http[0],\n    [arbitrumSepolia.id]: arbitrumSepolia.rpcUrls.default.http[0],\n    [optimismSepolia.id]: optimismSepolia.rpcUrls.default.http[0],\n    [baseSepolia.id]: baseSepolia.rpcUrls.default.http[0],\n    [polygonAmoy.id]: polygonAmoy.rpcUrls.default.http[0],\n  };\n\n  return chainMap[chainId];\n}\n\n// Popup window dimensions\nexport const POPUP_WIDTH = 420;\nexport const POPUP_HEIGHT = 650;\n","{\n  \"name\": \"@gemini-wallet/core\",\n  \"version\": \"0.3.2\",\n  \"description\": \"Core SDK for Gemini Wallet integration with popup communication\",\n  \"main\": \"./dist/index.cjs\",\n  \"types\": \"./dist/index.d.ts\",\n  \"type\": \"module\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/gemini/gemini-wallet-core.git\"\n  },\n  \"homepage\": \"https://keys.gemini.com\",\n  \"bugs\": {\n    \"url\": \"https://github.com/gemini/gemini-wallet-core/issues\"\n  },\n  \"license\": \"MIT\",\n  \"author\": \"Gemini\",\n  \"files\": [\n    \"dist\",\n    \"src\",\n    \"README.md\",\n    \"LICENSE\"\n  ],\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\",\n      \"require\": \"./dist/index.cjs\"\n    },\n    \"./package.json\": \"./package.json\"\n  },\n  \"scripts\": {\n    \"build\": \"dotenv -e .env.production -- tsup\",\n    \"dev\": \"dotenv -e .env.local -- tsup --watch\",\n    \"typecheck\": \"tsc --noEmit\",\n    \"lint\": \"eslint ./src\",\n    \"lint:ci\": \"eslint --max-warnings 0 ./src\",\n    \"lint:fix\": \"eslint ./src --fix\",\n    \"test\": \"bun test\"\n  },\n  \"dependencies\": {\n    \"@metamask/rpc-errors\": \"7.0.2\",\n    \"eventemitter3\": \"5.0.1\"\n  },\n  \"devDependencies\": {\n    \"@eslint/eslintrc\": \"3.3.1\",\n    \"@eslint/js\": \"9.38.0\",\n    \"@types/node\": \"22.13.0\",\n    \"dotenv-cli\": \"10.0.0\",\n    \"esbuild-plugin-replace\": \"1.4.0\",\n    \"eslint\": \"9.38.0\",\n    \"eslint-config-prettier\": \"10.1.8\",\n    \"eslint-config-turbo\": \"2.5.6\",\n    \"eslint-plugin-import\": \"2.32.0\",\n    \"eslint-plugin-only-warn\": \"1.1.0\",\n    \"eslint-plugin-prettier\": \"5.5.4\",\n    \"eslint-plugin-simple-import-sort\": \"12.1.1\",\n    \"eslint-plugin-sort-keys-fix\": \"1.1.2\",\n    \"globals\": \"16.4.0\",\n    \"prettier\": \"3.6.2\",\n    \"tsup\": \"8.5.0\",\n    \"typescript\": \"5.5.3\",\n    \"typescript-eslint\": \"8.40.0\",\n    \"vitest\": \"3.2.4\"\n  },\n  \"peerDependencies\": {\n    \"viem\": \">=2.0.0\"\n  },\n  \"keywords\": [\n    \"gemini\",\n    \"wallet\",\n    \"sdk\",\n    \"ethereum\",\n    \"web3\",\n    \"crypto\"\n  ],\n  \"module\": \"./dist/index.js\"\n}","import { EventEmitter } from \"eventemitter3\";\nimport type { Address, Hex, SignMessageParameters, SignTypedDataParameters, TransactionRequest } from \"viem\";\n\nimport { type IStorage } from \"./storage/storageInterface\";\n\nexport enum GeminiSdkEvent {\n  // Popup events\n  POPUP_LOADED = \"POPUP_LOADED\",\n  POPUP_UNLOADED = \"POPUP_UNLOADED\",\n  POPUP_APP_CONTEXT = \"POPUP_APP_CONTEXT\",\n\n  // SDK events\n  SDK_CONNECT = \"SDK_CONNECT\",\n  SDK_DISCONNECT = \"SDK_DISCONNECT\",\n  SDK_SEND_TRANSACTION = \"SDK_SEND_TRANSACTION\",\n  SDK_SIGN_DATA = \"SDK_SIGN_DATA\",\n  SDK_SIGN_TYPED_DATA = \"SDK_SIGN_TYPED_DATA\",\n  SDK_SWITCH_CHAIN = \"SDK_SWITCH_CHAIN\",\n  SDK_OPEN_SETTINGS = \"SDK_OPEN_SETTINGS\",\n  SDK_CURRENT_ACCOUNT = \"SDK_CURRENT_ACCOUNT\",\n\n  // EIP-5792 events\n  SDK_SEND_BATCH_CALLS = \"SDK_SEND_BATCH_CALLS\",\n  SDK_GET_CAPABILITIES = \"SDK_GET_CAPABILITIES\",\n  SDK_GET_CALLS_STATUS = \"SDK_GET_CALLS_STATUS\",\n  SDK_SHOW_CALLS_STATUS = \"SDK_SHOW_CALLS_STATUS\",\n}\n\nexport interface AppMetadata {\n  /**\n   * The name of your application\n   */\n  name?: string;\n  /**\n   * The description of your application (optional)\n   */\n  description?: string;\n  /**\n   * URL of your application\n   */\n  url?: string;\n  /**\n   * URL to your application's icon or logo\n   */\n  icon?: string;\n  /**\n   * @deprecated Use `name` instead\n   */\n  appName?: string;\n  /**\n   * @deprecated Use `icon` instead\n   */\n  appLogoUrl?: string;\n}\n\nexport interface AppContext {\n  appMetadata: AppMetadata;\n  origin: string;\n  sdkVersion: string;\n}\n\nexport interface Chain {\n  id: number;\n  rpcUrl?: string;\n}\n\n// Using const object with 'as const' assertion instead of enum\n// This avoids TypeScript's isolatedModules re-export limitations\nexport const PlatformType = {\n  REACT_NATIVE: \"REACT_NATIVE\",\n  WEB: \"WEB\",\n} as const;\n\n// Extract type from const object for type safety\nexport type PlatformType = (typeof PlatformType)[keyof typeof PlatformType];\n\nexport type GeminiProviderConfig = {\n  appMetadata: AppMetadata;\n  chain: Chain;\n  platform?: PlatformType;\n  onDisconnectCallback?: () => void;\n  storage?: IStorage;\n};\n\nexport interface RpcRequestArgs {\n  readonly method: string;\n  readonly params?: readonly unknown[] | object | Hex[];\n}\n\nexport interface ProviderRpcError extends Error {\n  code: number;\n  data?: unknown;\n  message: string;\n}\n\nexport type ProviderEventMap = {\n  accountsChanged: string[];\n  chainChanged: string; // hex string\n  connect: {\n    readonly chainId: string;\n  };\n  disconnect: ProviderRpcError;\n};\n\nexport type ProviderEventCallback = ProviderInterface[\"emit\"];\n\nexport class ProviderEventEmitter extends EventEmitter<keyof ProviderEventMap> {}\n\nexport interface ProviderInterface extends ProviderEventEmitter {\n  disconnect(): Promise<void>;\n  emit<K extends keyof ProviderEventMap>(event: K, ...args: [ProviderEventMap[K]]): boolean;\n  on<K extends keyof ProviderEventMap>(event: K, listener: (_: ProviderEventMap[K]) => void): this;\n  request(args: RpcRequestArgs): Promise<any>;\n}\n\nexport interface GeminiSdkMessage {\n  chainId: number;\n  data?: unknown;\n  event: GeminiSdkEvent;\n  origin: string;\n  requestId?: string;\n  wcData?: any;\n}\n\nexport interface GeminiSdkMessageResponse {\n  data?: unknown;\n  event: GeminiSdkEvent;\n  requestId?: string;\n}\n\nexport interface ConnectResponse extends Omit<GeminiSdkMessageResponse, \"data\"> {\n  data: { address: Address };\n}\n\nexport interface SendTransactionResponse extends Omit<GeminiSdkMessageResponse, \"data\"> {\n  data: { hash?: Hex; error?: string };\n}\n\nexport interface SignMessageResponse extends Omit<GeminiSdkMessageResponse, \"data\"> {\n  data: { hash?: Hex; error?: string };\n}\n\nexport interface SignTypedDataResponse extends Omit<GeminiSdkMessageResponse, \"data\"> {\n  data: { hash?: Hex; error?: string };\n}\n\nexport interface SwitchChainResponse extends Omit<GeminiSdkMessageResponse, \"data\"> {\n  data: { chainId?: number; error?: string };\n}\n\nexport interface GeminiSdkSendTransaction extends Omit<GeminiSdkMessage, \"data\"> {\n  data: TransactionRequest;\n}\n\nexport interface GeminiSdkSignMessage extends Omit<GeminiSdkMessage, \"data\"> {\n  data: SignMessageParameters;\n}\n\nexport interface GeminiSdkSignTypedData extends Omit<GeminiSdkMessage, \"data\"> {\n  data: SignTypedDataParameters;\n}\n\nexport interface GeminiSdkSendBatchCalls extends Omit<GeminiSdkMessage, \"data\"> {\n  data: SendCallsParams;\n}\n\nexport interface GeminiSdkSwitchChain extends Omit<GeminiSdkMessage, \"data\"> {\n  data: number;\n}\n\nexport interface GeminiSdkAppContextMessage extends Omit<GeminiSdkMessage, \"data\"> {\n  data: AppContext;\n}\n\nexport interface ReverseEnsResponse {\n  address: Address;\n  name: string | null;\n}\n\n// EIP-5792 Types\nexport interface Call {\n  to: Address;\n  value?: Hex;\n  data?: Hex;\n  chainId?: Hex;\n}\n\nexport interface SendCallsParams {\n  version: string;\n  chainId: Hex;\n  from: Address;\n  calls: Call[];\n  capabilities?: Record<string, any>;\n}\n\nexport interface WalletCapabilities {\n  [chainId: string]: {\n    atomic?: {\n      status: \"supported\" | \"unsupported\";\n    };\n    paymasterService?: {\n      supported: boolean;\n    };\n  };\n}\n\nexport interface CallBatchMetadata {\n  id: string;\n  chainId: string;\n  from: Address;\n  calls: Call[];\n  transactionHash?: Hex;\n  status: \"pending\" | \"confirmed\" | \"failed\" | \"reverted\";\n  timestamp: number;\n  capabilities?: Record<string, any>;\n}\n\nexport interface GetCallsStatusResponse {\n  version: string;\n  id: string;\n  chainId: Hex;\n  status: 100 | 200 | 400 | 500; // pending, confirmed, offchain failure, reverted\n  atomic: boolean;\n  receipts?: Array<{\n    logs: Array<{\n      address: Address;\n      data: Hex;\n      topics: Hex[];\n    }>;\n    status: \"success\" | \"reverted\";\n    blockHash: Hex;\n    blockNumber: Hex;\n    gasUsed: Hex;\n    transactionHash: Hex;\n  }>;\n}\n\nexport interface SendCallsResponse {\n  id: string;\n  capabilities?: {\n    caip345?: {\n      caip2: string;\n      transactionHashes: Hex[];\n    };\n  };\n}\n","/**\n * Utility functions for base64 encoding and decoding\n * Compatible with both browser and Node.js environments\n */\n\n/**\n * Encodes a Uint8Array to a base64url string\n * @param array - The Uint8Array to encode\n * @returns The base64url encoded string\n */\nexport function encodeBase64(array: Uint8Array): string {\n  let base64: string;\n\n  // Check if we're in a Node.js environment (Buffer is available)\n  if (typeof Buffer !== \"undefined\") {\n    // Node.js environment\n    base64 = Buffer.from(array).toString(\"base64\");\n  } else {\n    // Browser environment\n    base64 = btoa(\n      Array.from(array)\n        .map(b => String.fromCharCode(b))\n        .join(\"\"),\n    );\n  }\n\n  // Convert to base64url format by replacing characters\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=+$/, \"\");\n}\n\n/**\n * Decodes a base64url string to a Uint8Array\n * @param base64url - The base64url encoded string\n * @returns The decoded Uint8Array\n */\nexport function decodeBase64(base64url: string): Uint8Array {\n  // Convert base64url to standard base64 by restoring special chars\n  let base64 = base64url.replace(/-/g, \"+\").replace(/_/g, \"/\");\n\n  // Add padding if needed\n  while (base64.length % 4 !== 0) {\n    base64 += \"=\";\n  }\n\n  // Check if we're in a Node.js environment (Buffer is available)\n  if (typeof Buffer !== \"undefined\") {\n    // Node.js environment\n    return new Uint8Array(Buffer.from(base64, \"base64\"));\n  } else {\n    // Browser environment\n    const binaryString = atob(base64);\n    const bytes = new Uint8Array(binaryString.length);\n    for (let i = 0; i < binaryString.length; i++) {\n      bytes[i] = binaryString.charCodeAt(i);\n    }\n    return bytes;\n  }\n}\n\n/**\n * Convert an ArrayBuffer or Uint8Array to a base64url string\n * @param buffer - The buffer to convert\n * @returns The base64url encoded string\n */\nexport function bufferToBase64URLString(buffer: ArrayBuffer | Uint8Array): string {\n  const bytes = buffer instanceof Uint8Array ? buffer : new Uint8Array(buffer);\n  return encodeBase64(bytes);\n}\n\n/**\n * Convert a string to UTF-8 encoded Uint8Array\n * @param value - The string to convert\n * @returns The UTF-8 encoded Uint8Array\n */\nexport function utf8StringToBuffer(value: string): Uint8Array {\n  if (typeof TextEncoder !== \"undefined\") {\n    // Modern browsers and Node.js with TextEncoder support\n    return new TextEncoder().encode(value);\n  } else if (typeof Buffer !== \"undefined\") {\n    // Node.js fallback\n    return new Uint8Array(Buffer.from(value, \"utf8\"));\n  } else {\n    // Very old browsers fallback (not recommended)\n    const bytes = new Uint8Array(value.length);\n    for (let i = 0; i < value.length; i++) {\n      bytes[i] = value.charCodeAt(i);\n    }\n    return bytes;\n  }\n}\n\n/**\n * Convert a base64 string to hex string\n * @param base64 - The base64 string to convert\n * @returns The hex string\n */\nexport function base64ToHex(base64: string): string {\n  const bytes = decodeBase64(base64);\n  return Array.from(bytes)\n    .map(b => b.toString(16).padStart(2, \"0\"))\n    .join(\"\");\n}\n","import {\n  type Address,\n  encodeAbiParameters,\n  encodeFunctionData,\n  encodePacked,\n  getCreate2Address,\n  type Hex,\n  keccak256,\n} from \"viem\";\n\n// WebAuthn validator data structure\nexport interface WebAuthnValidatorData {\n  pubKeyX: bigint;\n  pubKeyY: bigint;\n}\n\n// Parameters for calculating wallet address\nexport interface CalculateWalletAddressParams {\n  publicKey: Hex; // Combined 64-byte hex string (32 bytes X + 32 bytes Y)\n  credentialId: string; // Base64URL encoded credential ID\n  index?: bigint; // Optional, defaults to 0\n}\n\n// Shared contract addresses across versions\nconst SHARED_CONTRACT_ADDRESSES = {\n  ATTESTER: \"0x000474392a9cd86a4687354f1Ce2964B52e97484\" as const,\n  BOOTSTRAPPER: \"0x00000000D3254452a909E4eeD47455Af7E27C289\" as const,\n  REGISTRY: \"0x000000000069E2a187AEFFb852bF3cCdC95151B2\" as const,\n};\n\n// V2 contract addresses (current Horizon deployment)\nconst V2_CONTRACT_ADDRESSES = {\n  ...SHARED_CONTRACT_ADDRESSES,\n  ACCOUNT_IMPLEMENTATION: \"0x00000000029d9c8b864DD51d6bb0d99FB72D650b\" as const,\n  FACTORY: \"0x000000000452377e1Bd9e72E939855ECb9363Cab\" as const,\n  WEBAUTHN_VALIDATOR: \"0x7ab16Ff354AcB328452F1D445b3Ddee9a91e9e69\" as const,\n};\n\n// V1 contract addresses\nconst V1_CONTRACT_ADDRESSES = {\n  ...SHARED_CONTRACT_ADDRESSES,\n  ACCOUNT_IMPLEMENTATION: \"0x0006050168DE255a8672ACaD4821e721CBA44337\" as const,\n  FACTORY: \"0x00E58DF70FaB983a324c4C068c82d20407579FaC\" as const,\n  WEBAUTHN_VALIDATOR: \"0xbA45a2BFb8De3D24cA9D7F1B551E14dFF5d690Fd\" as const,\n};\n\n/**\n * Internal helper to process and validate wallet address calculation parameters\n */\nfunction processWalletAddressParams(\n  params: CalculateWalletAddressParams,\n  contractAddresses: typeof V1_CONTRACT_ADDRESSES | typeof V2_CONTRACT_ADDRESSES,\n): Address {\n  const { publicKey, credentialId, index = 0n } = params;\n\n  // Validate input\n  if (!publicKey.startsWith(\"0x\") || publicKey.length !== 130) {\n    throw new Error(\"Invalid public key: must be 64-byte hex string (0x + 128 chars)\");\n  }\n\n  // Extract X and Y coordinates\n  const pubKeyX = `0x${publicKey.slice(2, 66)}` as Hex;\n  const pubKeyY = `0x${publicKey.slice(66, 130)}` as Hex;\n\n  // Convert to WebAuthnValidatorData\n  const webAuthnData: WebAuthnValidatorData = {\n    pubKeyX: BigInt(pubKeyX),\n    pubKeyY: BigInt(pubKeyY),\n  };\n\n  // Validate the key is on the secp256r1 curve\n  if (!validateWebAuthnKey(webAuthnData)) {\n    throw new Error(\"Invalid WebAuthn key: coordinates are not on secp256r1 curve\");\n  }\n\n  // Calculate authenticator ID hash from credential ID\n  const authenticatorIdHash = generateAuthenticatorIdHash(credentialId);\n\n  // Use the internal calculation with provided addresses\n  return calculateAddressInternal({\n    authenticatorIdHash,\n    contractAddresses,\n    index,\n    webAuthnData,\n  });\n}\n\n/**\n * Calculate smart wallet address from public key and credential ID (V2)\n * This handles all validation and setup internally\n */\nexport function calculateWalletAddress(params: CalculateWalletAddressParams): Address {\n  return processWalletAddressParams(params, V2_CONTRACT_ADDRESSES);\n}\n\n/**\n * Calculate smart wallet address from public key and credential ID (V1)\n * This handles all validation and setup internally\n */\nexport function calculateV1Address(params: CalculateWalletAddressParams): Address {\n  return processWalletAddressParams(params, V1_CONTRACT_ADDRESSES);\n}\n\n/**\n * Generate authenticator ID hash from credential ID\n */\nexport function generateAuthenticatorIdHash(credentialId: string): Hex {\n  // Convert base64url to bytes\n  const padding = \"=\".repeat((4 - (credentialId.length % 4)) % 4);\n  const base64 = credentialId.replace(/-/g, \"+\").replace(/_/g, \"/\") + padding;\n\n  const binaryString = atob(base64);\n  const bytes = new Uint8Array(binaryString.length);\n  for (let i = 0; i < binaryString.length; i++) {\n    bytes[i] = binaryString.charCodeAt(i);\n  }\n\n  return keccak256(bytes);\n}\n\n/**\n * Validate WebAuthn public key offchain\n * Mirrors the contract's _validateWebAuthnKey function\n */\nexport function validateWebAuthnKey(webAuthnData: WebAuthnValidatorData): boolean {\n  const SECP256R1_P = 0xffffffff00000001000000000000000000000000ffffffffffffffffffffffffn;\n  const SECP256R1_B = 0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604bn;\n\n  const { pubKeyX, pubKeyY } = webAuthnData;\n\n  // Check if coordinates are valid\n  if (pubKeyX === 0n || pubKeyY === 0n || pubKeyX >= SECP256R1_P || pubKeyY >= SECP256R1_P) {\n    return false;\n  }\n\n  // Validate curve membership: Y² ≡ X³ - 3X + B (mod P)\n  const ySquared = (pubKeyY * pubKeyY) % SECP256R1_P;\n  const xCubed = (pubKeyX * pubKeyX * pubKeyX) % SECP256R1_P;\n  const threeX = (3n * pubKeyX) % SECP256R1_P;\n  const rightSide = (xCubed + SECP256R1_P - threeX + SECP256R1_B) % SECP256R1_P;\n\n  return ySquared === rightSide;\n}\n\n/**\n * Internal calculation method using provided contract addresses\n */\nfunction calculateAddressInternal(params: {\n  webAuthnData: WebAuthnValidatorData;\n  authenticatorIdHash: Hex;\n  index: bigint;\n  contractAddresses: typeof V1_CONTRACT_ADDRESSES | typeof V2_CONTRACT_ADDRESSES;\n}): Address {\n  const { webAuthnData, authenticatorIdHash, index, contractAddresses } = params;\n\n  // Use provided contract addresses\n  const factoryAddress = contractAddresses.FACTORY;\n  const accountImplementation = contractAddresses.ACCOUNT_IMPLEMENTATION;\n  const webAuthnValidator = contractAddresses.WEBAUTHN_VALIDATOR;\n  const attester = contractAddresses.ATTESTER;\n  const bootstrapper = contractAddresses.BOOTSTRAPPER;\n  const registry = contractAddresses.REGISTRY;\n\n  // Generate cross-chain consistent salt (same as contract)\n  const salt = keccak256(\n    encodePacked(\n      [\"uint256\", \"uint256\", \"bytes32\", \"uint256\"],\n      [webAuthnData.pubKeyX, webAuthnData.pubKeyY, authenticatorIdHash, index],\n    ),\n  );\n\n  // Prepare validator initialization data (WebAuthnValidatorData + authenticatorIdHash)\n  const validatorInitData = encodeAbiParameters(\n    [\n      {\n        components: [\n          { name: \"pubKeyX\", type: \"uint256\" },\n          { name: \"pubKeyY\", type: \"uint256\" },\n        ],\n        type: \"tuple\",\n      },\n      { type: \"bytes32\" },\n    ],\n    [webAuthnData, authenticatorIdHash],\n  );\n\n  // Create RegistryConfig struct\n  const registryConfig = {\n    attesters: [attester],\n    registry,\n    threshold: 1n,\n  };\n\n  // Encode the bootstrap call\n  const bootstrapCall = encodeFunctionData({\n    abi: [\n      {\n        inputs: [\n          { name: \"validator\", type: \"address\" },\n          { name: \"validatorInitData\", type: \"bytes\" },\n          {\n            components: [\n              { name: \"registry\", type: \"address\" },\n              { name: \"attesters\", type: \"address[]\" },\n              { name: \"threshold\", type: \"uint8\" },\n            ],\n            name: \"registryConfig\",\n            type: \"tuple\",\n          },\n        ],\n        name: \"initNexusWithSingleValidator\",\n        type: \"function\",\n      },\n    ],\n    args: [webAuthnValidator, validatorInitData, registryConfig],\n    functionName: \"initNexusWithSingleValidator\",\n  });\n\n  // Format initialization data as expected by ProxyLib\n  const initData = encodeAbiParameters([{ type: \"address\" }, { type: \"bytes\" }], [bootstrapper, bootstrapCall]);\n\n  // Calculate CREATE2 address using the same logic as ProxyLib.predictProxyAddress\n  return predictProxyAddress(accountImplementation, salt, initData, factoryAddress);\n}\n\n/**\n * Predicts the proxy address using CREATE2\n * Mirrors ProxyLib.predictProxyAddress functionality exactly\n */\nfunction predictProxyAddress(implementation: Address, salt: Hex, initData: Hex, deployer: Address): Address {\n  // Encode the call to INexus.initializeAccount with initData\n  const initializeCall = encodeFunctionData({\n    abi: [\n      {\n        inputs: [{ name: \"data\", type: \"bytes\" }],\n        name: \"initializeAccount\",\n        type: \"function\",\n      },\n    ],\n    args: [initData],\n    functionName: \"initializeAccount\",\n  });\n\n  // Encode constructor arguments for NexusProxy\n  const constructorArgs = encodeAbiParameters(\n    [{ type: \"address\" }, { type: \"bytes\" }],\n    [implementation, initializeCall],\n  );\n\n  // Calculate initCodeHash using actual compiled NexusProxy creation bytecode\n  const nexusProxyCreationCode =\n    \"0x60806040526102c8803803806100148161018c565b92833981016040828203126101885781516001600160a01b03811692909190838303610188576020810151906001600160401b03821161018857019281601f8501121561018857835161006e610069826101c5565b61018c565b9481865260208601936020838301011161018857815f926020809301865e8601015260017f90b772c2cb8a51aa7a8a65fc23543c6d022d5b3f8e2b92eed79fba7eef8293005d823b15610176577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc80546001600160a01b031916821790557fbc7cd75a20ee27fd9adebab32041f755214dbc6bffa90cc0225b39da2e5c2d3b5f80a282511561015e575f8091610146945190845af43d15610156573d91610137610069846101c5565b9283523d5f602085013e6101e0565b505b6040516089908161023f8239f35b6060916101e0565b50505034156101485763b398979f60e01b5f5260045ffd5b634c9c8ce360e01b5f5260045260245ffd5b5f80fd5b6040519190601f01601f191682016001600160401b038111838210176101b157604052565b634e487b7160e01b5f52604160045260245ffd5b6001600160401b0381116101b157601f01601f191660200190565b9061020457508051156101f557805190602001fd5b63d6bda27560e01b5f5260045ffd5b81511580610235575b610215575090565b639996b31560e01b5f9081526001600160a01b0391909116600452602490fd5b50803b1561020d56fe608060405236156051577f360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc545f9081906001600160a01b0316368280378136915af43d5f803e15604d573d5ff35b3d5ffd5b00fea264697066735822122041b5f70a351952142223f22504ca7b4e6d975f3a302d114ff820442fcf815ac264736f6c634300081b0033\" as const;\n\n  const initCodeHash = keccak256(encodePacked([\"bytes\", \"bytes\"], [nexusProxyCreationCode, constructorArgs]));\n\n  // Standard CREATE2 formula\n  return getCreate2Address({\n    bytecodeHash: initCodeHash,\n    from: deployer,\n    salt,\n  });\n}\n","import type { Address } from \"viem\";\n\nimport { ENS_API_URL } from \"@/constants\";\nimport type { ReverseEnsResponse } from \"@/types\";\n\nexport async function reverseResolveEns(address: Address): Promise<ReverseEnsResponse> {\n  try {\n    const response = await fetch(`${ENS_API_URL}/reverse/${address}`);\n\n    if (!response.ok) {\n      throw new Error(`ENS API request failed: ${response.status} ${response.statusText}`);\n    }\n\n    const data: ReverseEnsResponse = await response.json();\n\n    return {\n      address: data.address,\n      name: data.name || null,\n    };\n  } catch (error) {\n    console.error(\"Failed to resolve ENS name:\", error);\n    return {\n      address,\n      name: null,\n    };\n  }\n}\n","import { rpcErrors } from \"@metamask/rpc-errors\";\n\nconst POPUP_WIDTH = 420;\nconst POPUP_HEIGHT = 650;\n\nexport const openPopup = (url: URL): Window => {\n  const left = (window.innerWidth - POPUP_WIDTH) / 2 + window.screenX;\n  const top = (window.innerHeight - POPUP_HEIGHT) / 2 + window.screenY;\n\n  const popupId = `wallet_${window?.crypto?.randomUUID()}`;\n  const popup = window.open(url, popupId, `width=${POPUP_WIDTH}, height=${POPUP_HEIGHT}, left=${left}, top=${top}`);\n\n  popup?.focus();\n\n  if (!popup) {\n    throw rpcErrors.internal(\"Pop up window failed to open\");\n  }\n\n  return popup;\n};\n\nexport const closePopup = (popup: Window | null) => {\n  if (popup && !popup.closed) {\n    popup.opener?.focus();\n    popup.close();\n  }\n};\n","export const hexStringFromNumber = (num: number): string => {\n  return `0x${BigInt(num).toString(16)}`;\n};\n\nexport const safeJsonStringify = (obj: any) =>\n  JSON.stringify(obj, (_, value) => (typeof value === \"bigint\" ? value.toString() + \"n\" : value), 2);\n","import { errorCodes, providerErrors, rpcErrors, serializeError } from \"@metamask/rpc-errors\";\nimport {\n  type Address,\n  type Hex,\n  type SignMessageParameters,\n  SignTypedDataParameters,\n  type TransactionRequest,\n} from \"viem\";\n\nimport { DEFAULT_CHAIN_ID } from \"../constants\";\nimport { GeminiStorage, STORAGE_ETH_ACCOUNTS_KEY, STORAGE_ETH_ACTIVE_CHAIN_KEY } from \"../storage\";\nimport {\n  type GeminiProviderConfig,\n  type GetCallsStatusResponse,\n  ProviderEventEmitter,\n  type ProviderInterface,\n  type RpcRequestArgs,\n  type SendCallsParams,\n  type SendCallsResponse,\n  type WalletCapabilities,\n} from \"../types\";\nimport { hexStringFromNumber } from \"../utils\";\nimport { GeminiWallet } from \"../wallets\";\nimport { convertSendValuesToBigInt, fetchRpcRequest, validateRpcRequestArgs } from \"./provider.utils\";\n\nexport class GeminiWalletProvider extends ProviderEventEmitter implements ProviderInterface {\n  private readonly config: GeminiProviderConfig;\n  private wallet: GeminiWallet | null = null;\n\n  constructor(providerConfig: Readonly<GeminiProviderConfig>) {\n    super();\n    this.config = providerConfig;\n\n    // Preserve user's disconnect callback while adding provider cleanup\n    const userDisconnectCallback = providerConfig.onDisconnectCallback;\n    this.wallet = new GeminiWallet({\n      ...providerConfig,\n      onDisconnectCallback: () => {\n        // Call user's callback first\n        userDisconnectCallback?.();\n        // Then handle provider cleanup\n        this.disconnect();\n      },\n    });\n  }\n\n  public async request<T>(args: RpcRequestArgs): Promise<T> {\n    try {\n      validateRpcRequestArgs(args);\n\n      if (!this.wallet?.accounts?.length) {\n        switch (args.method) {\n          case \"eth_requestAccounts\": {\n            // Use existing wallet instance instead of recreating\n            if (!this.wallet) {\n              // Preserve user's disconnect callback while adding provider cleanup\n              const userDisconnectCallback = this.config.onDisconnectCallback;\n              this.wallet = new GeminiWallet({\n                ...this.config,\n                onDisconnectCallback: () => {\n                  // Call user's callback first\n                  userDisconnectCallback?.();\n                  // Then handle provider cleanup\n                  this.disconnect();\n                },\n              });\n            }\n            await this.wallet.connect();\n            this.emit(\"accountsChanged\", this.wallet.accounts);\n            break;\n          }\n          case \"net_version\":\n            // not connected default value\n            return DEFAULT_CHAIN_ID as T;\n          case \"eth_chainId\":\n            // not connected default value\n            return hexStringFromNumber(DEFAULT_CHAIN_ID) as T;\n          default: {\n            // all other methods require active connection\n            throw providerErrors.unauthorized();\n          }\n        }\n      }\n\n      let response;\n      let requestParams;\n      switch (args.method) {\n        case \"eth_requestAccounts\":\n        case \"eth_accounts\":\n          response = this.wallet.accounts;\n          break;\n        case \"net_version\":\n          response = this.wallet.chain.id;\n          break;\n        case \"eth_chainId\":\n          response = hexStringFromNumber(this.wallet.chain.id);\n          break;\n        case \"personal_sign\":\n        case \"wallet_sign\":\n          requestParams = args.params as Array<Hex | Address>;\n          response = await this.wallet.signData({\n            account: requestParams[1] as Address,\n            message: requestParams[0] as Hex,\n          } as SignMessageParameters);\n          if (response.error) {\n            throw rpcErrors.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        case \"eth_sendTransaction\":\n        case \"wallet_sendTransaction\":\n          requestParams = args.params as Array<TransactionRequest>;\n          requestParams = convertSendValuesToBigInt(requestParams[0]);\n          response = await this.wallet.sendTransaction(requestParams);\n          if (response.error) {\n            throw rpcErrors.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        case \"wallet_switchEthereumChain\": {\n          // Handle both standard EIP-3326 format [{ chainId: hex }] and legacy format { id: number }\n          const rawParams = args.params as [{ chainId: string }] | { id: number };\n          let chainId: number;\n\n          if (Array.isArray(rawParams) && rawParams[0]?.chainId) {\n            // Standard EIP-3326 format: [{ chainId: \"0x1\" }]\n            chainId = parseInt(rawParams[0].chainId, 16);\n          } else if (\n            rawParams &&\n            typeof rawParams === \"object\" &&\n            \"id\" in rawParams &&\n            Number.isInteger(rawParams.id)\n          ) {\n            // Legacy format: { id: 1 }\n            chainId = rawParams.id;\n          } else {\n            throw rpcErrors.invalidParams(\n              \"Invalid chain id argument. Expected [{ chainId: hex_string }] or { id: number }.\",\n            );\n          }\n\n          response = await this.wallet.switchChain({ id: chainId });\n\n          // Per EIP-3326, a non-null response indicates error\n          if (response) {\n            throw providerErrors.custom({ code: 4902, message: response });\n          }\n\n          await this.emit(\"chainChanged\", hexStringFromNumber(chainId));\n          break;\n        }\n        case \"eth_signTypedData_v1\":\n        case \"eth_signTypedData_v2\":\n        case \"eth_signTypedData_v3\":\n        case \"eth_signTypedData_v4\":\n        case \"eth_signTypedData\": {\n          requestParams = args.params as Array<Hex | Address>;\n          const signedTypedDataParams = JSON.parse(requestParams[1] as string) as SignTypedDataParameters;\n          response = await this.wallet.signTypedData({\n            account: requestParams[0] as Address,\n            domain: signedTypedDataParams.domain,\n            message: signedTypedDataParams.message,\n            primaryType: signedTypedDataParams.primaryType,\n            types: signedTypedDataParams.types,\n          });\n          if (response.error) {\n            throw rpcErrors.transactionRejected(response.error);\n          } else {\n            response = response.hash;\n          }\n          break;\n        }\n        // EIP-5792 Wallet Call API\n        case \"wallet_getCapabilities\": {\n          const capabilityParams = Array.isArray(args.params) ? args.params : undefined;\n          response = this.getCapabilities(capabilityParams);\n          break;\n        }\n        case \"wallet_sendCalls\": {\n          requestParams = args.params as [SendCallsParams];\n          response = await this.sendCalls(requestParams[0]);\n          break;\n        }\n        case \"wallet_getCallsStatus\": {\n          requestParams = args.params as [string];\n          response = await this.getCallsStatus(requestParams[0]);\n          break;\n        }\n        case \"wallet_showCallsStatus\": {\n          requestParams = args.params as [string];\n          await this.showCallsStatus(requestParams[0]);\n          response = null;\n          break;\n        }\n\n        // TODO: not yet implemented or unclear if we support\n        case \"eth_ecRecover\":\n        case \"eth_subscribe\":\n        case \"eth_unsubscribe\":\n        case \"personal_ecRecover\":\n        case \"eth_signTransaction\":\n        case \"wallet_watchAsset\":\n        case \"wallet_grantPermissions\":\n          throw rpcErrors.methodNotSupported(\"Not yet implemented.\");\n\n        // not supported\n        case \"eth_sign\":\n        case \"eth_coinbase\":\n        case \"wallet_addEthereumChain\":\n          throw rpcErrors.methodNotSupported();\n\n        // call rpc directly for everything else\n        default:\n          if (!this.wallet.chain.rpcUrl)\n            throw rpcErrors.internal(`RPC URL missing for current chain (${this.wallet.chain.id})`);\n          return fetchRpcRequest(args, this.wallet.chain.rpcUrl);\n      }\n\n      return response as T;\n    } catch (error) {\n      const { code } = error as { code?: number };\n      if (code === errorCodes.provider.unauthorized) this.disconnect();\n      return Promise.reject(serializeError(error));\n    }\n  }\n\n  // custom wallet function to open settings page\n  async openSettings() {\n    await this.wallet?.openSettings();\n  }\n\n  // EIP-5792 Implementation Methods - delegating to wallet\n\n  private getCapabilities(params?: readonly unknown[]): WalletCapabilities {\n    if (!this.wallet) {\n      throw providerErrors.unauthorized();\n    }\n    const requestedChainIds = params?.[0] as string[] | undefined;\n    return this.wallet.getCapabilities(requestedChainIds);\n  }\n\n  private async sendCalls(params: SendCallsParams): Promise<SendCallsResponse> {\n    if (!this.wallet) {\n      throw providerErrors.unauthorized();\n    }\n    try {\n      return await this.wallet.sendCalls(params);\n    } catch (error) {\n      throw rpcErrors.transactionRejected(error instanceof Error ? error.message : String(error));\n    }\n  }\n\n  private async getCallsStatus(batchId: string): Promise<GetCallsStatusResponse> {\n    if (!this.wallet) {\n      throw providerErrors.unauthorized();\n    }\n    try {\n      return await this.wallet.getCallsStatus(batchId);\n    } catch (error) {\n      throw rpcErrors.invalidParams(error instanceof Error ? error.message : String(error));\n    }\n  }\n\n  private async showCallsStatus(batchId: string): Promise<void> {\n    if (!this.wallet) {\n      throw providerErrors.unauthorized();\n    }\n    try {\n      await this.wallet.showCallsStatus(batchId);\n    } catch (error) {\n      throw rpcErrors.invalidParams(error instanceof Error ? error.message : String(error));\n    }\n  }\n\n  async disconnect() {\n    // If wallet exists, let it handle its own storage cleanup\n    if (this.wallet) {\n      // Create a temporary storage instance with the same config to clean up\n      const storage = this.config.storage || new GeminiStorage();\n      await storage.removeItem(STORAGE_ETH_ACCOUNTS_KEY);\n      await storage.removeItem(STORAGE_ETH_ACTIVE_CHAIN_KEY);\n    }\n    this.wallet = null;\n    // Call the user's disconnect callback if provided\n    this.config.onDisconnectCallback?.();\n    await this.emit(\"disconnect\", \"User initiated disconnection\");\n    await this.emit(\"accountsChanged\", []);\n  }\n}\n","import { safeJsonStringify } from \"../utils\";\nimport { type IStorage } from \"./storageInterface\";\n\n// memory fallback storage for environments without localStorage\nconst memoryStorage: Record<string, string> = {};\n\nexport type GeminiStorageConfig = {\n  scope?: string;\n  module?: string;\n};\n\n/**\n * Default web storage implementation using localStorage\n * For mobile platforms, implement a custom storage class that implements IStorage\n */\nexport class GeminiStorage implements IStorage {\n  private scope: string;\n  private module: string;\n\n  constructor({ scope = \"@gemini\", module = \"wallet\" }: GeminiStorageConfig = {}) {\n    this.scope = scope;\n    this.module = module;\n  }\n\n  private scopedKey(key: string): string {\n    return `${this.scope}.${this.module}.${key}`;\n  }\n\n  public async storeObject<T>(key: string, item: T): Promise<void> {\n    const json = safeJsonStringify(item);\n    await this.setItem(key, json);\n  }\n\n  public async loadObject<T>(key: string, fallback: T): Promise<T> {\n    const item = await this.getItem(key);\n    if (!item) {\n      await this.storeObject(key, fallback);\n      return fallback;\n    }\n\n    try {\n      return JSON.parse(item);\n    } catch (error) {\n      console.error(`Error parsing JSON for key ${key}:`, error);\n      return fallback;\n    }\n  }\n\n  // eslint-disable-next-line require-await\n  public async setItem(key: string, value: string): Promise<void> {\n    const scoped = this.scopedKey(key);\n\n    try {\n      localStorage.setItem(scoped, value);\n    } catch (e) {\n      // fallback to memory storage if localStorage is not available\n      console.warn(\"localStorage not available, using memory storage\", e);\n      memoryStorage[scoped] = value;\n    }\n  }\n\n  // eslint-disable-next-line require-await\n  public async getItem(key: string): Promise<string | null> {\n    const scoped = this.scopedKey(key);\n\n    try {\n      return localStorage.getItem(scoped);\n    } catch (e) {\n      // fallback to memory storage if localStorage is not available\n      console.warn(\"localStorage not available, using memory storage\", e);\n      return memoryStorage[scoped] || null;\n    }\n  }\n\n  // eslint-disable-next-line require-await\n  public async removeItem(key: string): Promise<void> {\n    const scoped = this.scopedKey(key);\n\n    try {\n      localStorage.removeItem(scoped);\n    } catch (e) {\n      // fallback to memory storage if localStorage is not available\n      console.warn(\"localStorage not available, using memory storage\", e);\n      delete memoryStorage[scoped];\n    }\n  }\n\n  public async removeItems(keys: string[]): Promise<void> {\n    await Promise.all(keys.map(key => this.removeItem(key)));\n  }\n}\n","/**\n * Interface for storage backends used by the Gemini wallet SDK\n */\nexport interface IStorage {\n  /**\n   * Store a serializable object in storage\n   * @param key Storage key\n   * @param item Object to store\n   */\n  storeObject<T>(key: string, item: T): Promise<void>;\n\n  /**\n   * Load a serializable object from storage\n   * @param key Storage key\n   * @param fallback Default value if key doesn't exist\n   * @returns The stored object or fallback\n   */\n  loadObject<T>(key: string, fallback: T): Promise<T>;\n\n  /**\n   * Store a string value in storage\n   * @param key Storage key\n   * @param value String value to store\n   */\n  setItem(key: string, value: string): Promise<void>;\n\n  /**\n   * Retrieve a string value from storage\n   * @param key Storage key\n   * @returns The stored string or null if not found\n   */\n  getItem(key: string): Promise<string | null>;\n\n  /**\n   * Remove an item from storage\n   * @param key Storage key\n   */\n  removeItem(key: string): Promise<void>;\n\n  /**\n   * Remove multiple items from storage\n   * @param keys Array of storage keys to remove\n   */\n  removeItems(keys: string[]): Promise<void>;\n}\n\n// Export storage keys\nexport const STORAGE_ETH_ACCOUNTS_KEY = \"eth-accounts\";\nexport const STORAGE_ETH_ACTIVE_CHAIN_KEY = \"eth-active-chain\";\nexport const STORAGE_PASSKEY_CREDENTIAL_KEY = \"passkey-credential\";\nexport const STORAGE_PRESERVED_PASSKEY_CREDENTIALS_KEY = \"preserved-passkey-credentials\";\nexport const STORAGE_SMART_ACCOUNT_KEY = \"smart-account\";\nexport const STORAGE_SETTINGS_KEY = \"settings\";\nexport const STORAGE_WC_REQUESTS_KEY = \"wc-requests\";\nexport const STORAGE_CALL_BATCHES_KEY = \"call-batches\";\n","import {\n  type Address,\n  type Hex,\n  type SignMessageParameters,\n  type SignTypedDataParameters,\n  type SwitchChainParameters,\n  type TransactionRequest,\n} from \"viem\";\n\nimport { Communicator } from \"../communicator\";\nimport { DEFAULT_CHAIN_ID, getDefaultRpcUrl, SUPPORTED_CHAIN_IDS } from \"../constants\";\nimport {\n  GeminiStorage,\n  type IStorage,\n  STORAGE_CALL_BATCHES_KEY,\n  STORAGE_ETH_ACCOUNTS_KEY,\n  STORAGE_ETH_ACTIVE_CHAIN_KEY,\n} from \"../storage\";\nimport {\n  type CallBatchMetadata,\n  type Chain,\n  type ConnectResponse,\n  type GeminiProviderConfig,\n  GeminiSdkEvent,\n  type GeminiSdkMessage,\n  type GeminiSdkMessageResponse,\n  type GeminiSdkSendTransaction,\n  type GeminiSdkSignMessage,\n  type GeminiSdkSignTypedData,\n  type GetCallsStatusResponse,\n  type SendCallsParams,\n  type SendCallsResponse,\n  type SendTransactionResponse,\n  type SignMessageResponse,\n  type SignTypedDataResponse,\n  type SwitchChainResponse,\n  type WalletCapabilities,\n} from \"../types\";\nimport { hexStringFromNumber } from \"../utils\";\n\nexport function isChainSupportedByGeminiSw(chainId: number): boolean {\n  return SUPPORTED_CHAIN_IDS.includes(chainId as (typeof SUPPORTED_CHAIN_IDS)[number]);\n}\n\nexport class GeminiWallet {\n  private readonly communicator: Communicator;\n  private readonly storage: IStorage;\n  private initPromise: Promise<void>;\n  public accounts: Address[] = [];\n  public chain: Chain = { id: DEFAULT_CHAIN_ID };\n\n  constructor({ appMetadata, chain, onDisconnectCallback, storage }: Readonly<GeminiProviderConfig>) {\n    this.communicator = new Communicator({\n      appMetadata,\n      onDisconnectCallback,\n    });\n    // Use provided storage or create default GeminiStorage for web\n    this.storage = storage || new GeminiStorage();\n\n    // Initialize storage data - use provided chain config or fallback to default\n    const fallbackChainId = chain?.id ?? DEFAULT_CHAIN_ID;\n    const fallbackRpcUrl = chain?.rpcUrl ?? getDefaultRpcUrl(fallbackChainId);\n    const defaultChain: Chain = {\n      id: fallbackChainId,\n      rpcUrl: fallbackRpcUrl,\n    };\n    this.initPromise = this.initializeFromStorage(defaultChain);\n  }\n\n  private async initializeFromStorage(defaultChain: Chain): Promise<void> {\n    const fallbackChain: Chain = {\n      ...defaultChain,\n      rpcUrl: defaultChain.rpcUrl || getDefaultRpcUrl(defaultChain.id),\n    };\n    const [storedChain, storedAccounts] = await Promise.all([\n      this.storage.loadObject<Chain>(STORAGE_ETH_ACTIVE_CHAIN_KEY, fallbackChain),\n      this.storage.loadObject<Address[]>(STORAGE_ETH_ACCOUNTS_KEY, this.accounts),\n    ]);\n\n    // Ensure chain has rpcUrl fallback\n    this.chain = {\n      ...storedChain,\n      rpcUrl: storedChain.rpcUrl || getDefaultRpcUrl(storedChain.id),\n    };\n    this.accounts = storedAccounts;\n  }\n\n  private async ensureInitialized(): Promise<void> {\n    await this.initPromise;\n  }\n\n  async connect(): Promise<Address[]> {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup<GeminiSdkMessage, ConnectResponse>({\n      chainId: this.chain.id,\n      event: GeminiSdkEvent.SDK_CONNECT,\n      origin: window.location.origin,\n    });\n\n    this.accounts = response.data.address ? [response.data.address] : [];\n    await this.storage.storeObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts);\n\n    return this.accounts;\n  }\n\n  async disconnect(): Promise<void> {\n    await this.ensureInitialized();\n    this.accounts = [];\n    await this.storage.storeObject(STORAGE_ETH_ACCOUNTS_KEY, this.accounts);\n  }\n\n  async switchChain({ id }: SwitchChainParameters): Promise<string | null> {\n    await this.ensureInitialized();\n    // If chain is supported return response immediately\n    if (isChainSupportedByGeminiSw(id)) {\n      this.chain = {\n        id,\n        rpcUrl: getDefaultRpcUrl(id),\n      };\n      // Store new active chain with rpcUrl\n      await this.storage.storeObject(STORAGE_ETH_ACTIVE_CHAIN_KEY, this.chain);\n      // Per EIP-3326, must return null if chain switch was success\n      return null;\n    }\n\n    // Message sdk to inform user of error\n    const response = await this.sendMessageToPopup<GeminiSdkMessage, SwitchChainResponse>({\n      chainId: this.chain.id,\n      data: id,\n      event: GeminiSdkEvent.SDK_SWITCH_CHAIN,\n      origin: window.location.origin,\n    });\n\n    // Return error message\n    return response.data.error ?? \"Unsupported chain.\";\n  }\n\n  async sendTransaction(txData: TransactionRequest): Promise<SendTransactionResponse[\"data\"]> {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup<GeminiSdkSendTransaction, SendTransactionResponse>({\n      chainId: this.chain.id,\n      data: txData,\n      event: GeminiSdkEvent.SDK_SEND_TRANSACTION,\n      origin: window.location.origin,\n    });\n\n    return response.data;\n  }\n\n  async signData({ message }: SignMessageParameters): Promise<SignMessageResponse[\"data\"]> {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup<GeminiSdkSignMessage, SignMessageResponse>({\n      chainId: this.chain.id,\n      data: { message },\n      event: GeminiSdkEvent.SDK_SIGN_DATA,\n      origin: window.location.origin,\n    });\n\n    return response.data;\n  }\n\n  async signTypedData({\n    message,\n    types,\n    primaryType,\n    domain,\n  }: SignTypedDataParameters): Promise<SignTypedDataResponse[\"data\"]> {\n    await this.ensureInitialized();\n    const response = await this.sendMessageToPopup<GeminiSdkSignTypedData, SignTypedDataResponse>({\n      chainId: this.chain.id,\n      data: {\n        domain,\n        message,\n        primaryType,\n        types,\n      },\n      event: GeminiSdkEvent.SDK_SIGN_TYPED_DATA,\n      origin: window.location.origin,\n    });\n    return response.data;\n  }\n\n  async openSettings(): Promise<void> {\n    await this.ensureInitialized();\n    await this.sendMessageToPopup<GeminiSdkMessage, GeminiSdkMessageResponse>({\n      chainId: this.chain.id,\n      data: {},\n      event: GeminiSdkEvent.SDK_OPEN_SETTINGS,\n      origin: window.location.origin,\n    });\n  }\n\n  // EIP-5792 Wallet Call API Methods\n\n  getCapabilities(requestedChainIds?: string[]): WalletCapabilities {\n    const capabilities: WalletCapabilities = {};\n    const chainIds = requestedChainIds?.map(id => parseInt(id, 16)) || [this.chain.id];\n\n    for (const chainId of chainIds) {\n      const chainIdHex = hexStringFromNumber(chainId);\n      capabilities[chainIdHex] = {\n        atomic: {\n          status: \"supported\", // Smart accounts support atomic batch execution\n        },\n        paymasterService: {\n          supported: true,\n        },\n      };\n    }\n\n    return capabilities;\n  }\n\n  async sendCalls(params: SendCallsParams): Promise<SendCallsResponse> {\n    await this.ensureInitialized();\n\n    // Generate unique bundle ID\n    const batchId = window?.crypto?.randomUUID() || `batch-${Date.now()}-${Math.random()}`;\n\n    // Validate chain ID matches current chain\n    const requestedChainId = parseInt(params.chainId, 16);\n    if (requestedChainId !== this.chain.id) {\n      throw new Error(`Chain mismatch. Expected ${this.chain.id}, got ${requestedChainId}`);\n    }\n\n    // Validate we have calls\n    if (!params.calls || params.calls.length === 0) {\n      throw new Error(\"No calls provided\");\n    }\n\n    // Create batch metadata\n    const batchMetadata: CallBatchMetadata = {\n      calls: params.calls,\n      capabilities: params.capabilities,\n      chainId: params.chainId,\n      from: params.from,\n      id: batchId,\n      status: \"pending\",\n      timestamp: Date.now(),\n    };\n\n    // Store batch metadata for status tracking\n    const batches = await this.storage.loadObject<Record<string, CallBatchMetadata>>(STORAGE_CALL_BATCHES_KEY, {});\n    batches[batchId] = batchMetadata;\n    await this.storage.storeObject(STORAGE_CALL_BATCHES_KEY, batches);\n\n    try {\n      // Send the batch call through the popup/iframe\n      // The wallet-web will handle this through the smart account client\n      const response = await this.sendMessageToPopup<GeminiSdkMessage, SendTransactionResponse>({\n        chainId: this.chain.id,\n        data: {\n          calls: params.calls,\n        },\n        event: GeminiSdkEvent.SDK_SEND_BATCH_CALLS,\n        origin: window.location.origin,\n      });\n\n      if (response.data.error) {\n        throw new Error(response.data.error);\n      }\n\n      // Update batch with transaction hash\n      batchMetadata.transactionHash = response.data.hash as Hex;\n      batchMetadata.status = \"pending\";\n      batches[batchId] = batchMetadata;\n      await this.storage.storeObject(STORAGE_CALL_BATCHES_KEY, batches);\n\n      // Return response with bundle ID and transaction hash\n      return {\n        capabilities: {\n          caip345: {\n            caip2: `eip155:${requestedChainId}`,\n            transactionHashes: [response.data.hash as Hex],\n          },\n        },\n        id: batchId,\n      };\n    } catch (error) {\n      // Mark batch as failed\n      batchMetadata.status = \"failed\";\n      batches[batchId] = batchMetadata;\n      await this.storage.storeObject(STORAGE_CALL_BATCHES_KEY, batches);\n      throw error;\n    }\n  }\n\n  async getCallsStatus(batchId: string): Promise<GetCallsStatusResponse> {\n    await this.ensureInitialized();\n\n    const batches = await this.storage.loadObject<Record<string, CallBatchMetadata>>(STORAGE_CALL_BATCHES_KEY, {});\n    const batch = batches[batchId];\n\n    if (!batch) {\n      throw new Error(`Unknown bundle ID: ${batchId}`);\n    }\n\n    // If we have a transaction hash, check its status on chain\n    if (batch.transactionHash && this.chain.rpcUrl) {\n      try {\n        const response = await fetch(this.chain.rpcUrl, {\n          body: JSON.stringify({\n            id: 1,\n            jsonrpc: \"2.0\",\n            method: \"eth_getTransactionReceipt\",\n            params: [batch.transactionHash],\n          }),\n          headers: { \"Content-Type\": \"application/json\" },\n          method: \"POST\",\n        });\n\n        const json = await response.json();\n        const receipt = json.result;\n\n        if (receipt) {\n          // Update batch status based on receipt\n          const receiptStatus = receipt.status === \"0x1\" ? \"confirmed\" : \"reverted\";\n          batch.status = receiptStatus;\n          batches[batchId] = batch;\n          await this.storage.storeObject(STORAGE_CALL_BATCHES_KEY, batches);\n\n          return {\n            atomic: true,\n            chainId: batch.chainId as Hex,\n            id: batchId,\n            receipts: [\n              {\n                blockHash: receipt.blockHash,\n                blockNumber: receipt.blockNumber,\n                gasUsed: receipt.gasUsed,\n                logs: receipt.logs.map((log: { address: string; data: string; topics: string[] }) => ({\n                  address: log.address,\n                  data: log.data,\n                  topics: log.topics,\n                })),\n                status: receiptStatus === \"confirmed\" ? \"success\" : \"reverted\",\n                transactionHash: receipt.transactionHash,\n              },\n            ],\n            status: receiptStatus === \"confirmed\" ? 200 : 500,\n            version: \"2.0.0\",\n          };\n        }\n      } catch (error) {\n        // If receipt fetch fails, return pending status\n        console.error(\"Failed to fetch transaction receipt:\", error);\n      }\n    }\n\n    // Return status based on batch metadata\n    let statusCode: 100 | 200 | 400 | 500;\n    switch (batch.status) {\n      case \"pending\":\n        statusCode = 100;\n        break;\n      case \"confirmed\":\n        statusCode = 200;\n        break;\n      case \"failed\":\n        statusCode = 400;\n        break;\n      case \"reverted\":\n        statusCode = 500;\n        break;\n      default:\n        statusCode = 100;\n    }\n\n    return {\n      atomic: true,\n      chainId: batch.chainId as Hex,\n      id: batchId,\n      status: statusCode,\n      version: \"2.0.0\",\n    };\n  }\n\n  async showCallsStatus(batchId: string): Promise<void> {\n    await this.ensureInitialized();\n\n    // Validate batch exists\n    const batches = await this.storage.loadObject<Record<string, CallBatchMetadata>>(STORAGE_CALL_BATCHES_KEY, {});\n    const batch = batches[batchId];\n\n    if (!batch) {\n      throw new Error(`Unknown bundle ID: ${batchId}`);\n    }\n\n    // Open SDK UI to show call status\n    // TODO: Implement actual UI showing via communicator\n    // For now, this just validates the batch exists\n  }\n\n  private sendMessageToPopup<M extends GeminiSdkMessage, R extends GeminiSdkMessageResponse>(\n    request: GeminiSdkMessage,\n  ): Promise<R> {\n    return this.communicator.postRequestAndWaitForResponse<M, R>({\n      ...request,\n      requestId: window?.crypto?.randomUUID(),\n    });\n  }\n}\n","import { rpcErrors } from \"@metamask/rpc-errors\";\nimport { isHex, type TransactionRequest } from \"viem\";\n\nimport type { RpcRequestArgs } from \"../types\";\n\n/**\n * Calls the RPC with a given request\n * @param request The request to make to the RPC.\n * @param rpcUrl The url of the RPC.\n * @returns Response from the RPC call.\n */\nexport const fetchRpcRequest = async (request: RpcRequestArgs, rpcUrl: string) => {\n  const requestBody = {\n    ...request,\n    id: window?.crypto?.randomUUID(),\n    jsonrpc: \"2.0\",\n  };\n  const res = await window.fetch(rpcUrl, {\n    body: JSON.stringify(requestBody),\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    method: \"POST\",\n    mode: \"cors\",\n  });\n  const { result, error } = await res.json();\n  if (error) throw error;\n  return result;\n};\n\n/**\n * Validates the RPC request arguments\n * Valid request args are defined here: https://eips.ethereum.org/EIPS/eip-1193#request\n * @param args The request arguments to validate.\n * @returns An error object if the arguments are invalid, otherwise undefined.\n */\nexport function validateRpcRequestArgs(args: unknown): asserts args is RpcRequestArgs {\n  if (!args || typeof args !== \"object\" || Array.isArray(args)) {\n    throw rpcErrors.invalidParams({\n      message: \"Expected a single, non-array, object argument.\",\n    });\n  }\n\n  const { method, params } = args as RpcRequestArgs;\n\n  if (typeof method !== \"string\" || method.length === 0) {\n    throw rpcErrors.invalidParams({\n      message: \"'args.method' must be a non-empty string.\",\n    });\n  }\n\n  if (params !== undefined && !Array.isArray(params) && (typeof params !== \"object\" || params === null)) {\n    throw rpcErrors.invalidParams({\n      message: \"'args.params' must be an object or array if provided.\",\n    });\n  }\n}\n\n/**\n * Converts specific tx request values from hex to BigInt to align with Viem types.\n * @param tx The raw transaction request object.\n * @returns The raw transaction object with certain fields converted to BigInts\n */\nexport function convertSendValuesToBigInt(tx: TransactionRequest): TransactionRequest {\n  const FIELDS_TO_NORMALIZE: (keyof Pick<\n    TransactionRequest,\n    \"value\" | \"gas\" | \"gasPrice\" | \"maxPriorityFeePerGas\" | \"maxFeePerGas\"\n  >)[] = [\"value\", \"gas\", \"gasPrice\", \"maxPriorityFeePerGas\", \"maxFeePerGas\"];\n\n  const normalized = { ...tx };\n\n  for (const field of FIELDS_TO_NORMALIZE) {\n    if (!(field in tx)) continue;\n\n    const value = tx[field];\n\n    if (typeof value === \"bigint\") continue;\n    if (isHex(value)) {\n      normalized[field] = BigInt(value);\n    }\n  }\n\n  return normalized;\n}\n"],"mappings":"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","names":["import_rpc_errors","GeminiSdkEvent","POPUP_WIDTH","POPUP_HEIGHT","import_rpc_errors","module","import_rpc_errors","import_viem"]}