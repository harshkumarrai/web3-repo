{"version":3,"file":"xrplf-secret-numbers-latest-min.js","mappings":"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","sources":["webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/secp256k1.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/hashes/src/legacy.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/abstract/hash-to-curve.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/abstract/curve.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/ed25519.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-keypairs/src/utils/assert.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/hashes/src/sha2.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/abstract/weierstrass.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/hashes/src/crypto.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-address-codec/src/index.ts","webpack://xrplf_secret_numbers/../../node_modules/@xrplf/isomorphic/src/sha256/browser.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-keypairs/src/index.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/abstract/utils.ts","webpack://xrplf_secret_numbers/./src/schema/Account.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-keypairs/src/signing-schemes/secp256k1/index.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/node_modules/@noble/hashes/src/_assert.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/hashes/src/utils.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-address-codec/src/xrp-codec.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/hashes/src/ripemd160.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-keypairs/src/signing-schemes/ed25519/index.ts","webpack://xrplf_secret_numbers/../../node_modules/@xrplf/isomorphic/src/utils/shared.ts","webpack://xrplf_secret_numbers/../../node_modules/@scure/base/index.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/node_modules/@noble/hashes/src/_md.ts","webpack://xrplf_secret_numbers/../../node_modules/@xrplf/isomorphic/src/utils/browser.ts","webpack://xrplf_secret_numbers/../../node_modules/@xrplf/isomorphic/src/internal/wrapNoble.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/_shortw_utils.ts","webpack://xrplf_secret_numbers/../../node_modules/@xrplf/isomorphic/src/ripemd160/browser.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/hashes/src/_u64.ts","webpack://xrplf_secret_numbers/./src/index.ts","webpack://xrplf_secret_numbers/./src/utils/index.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/node_modules/@noble/hashes/src/sha512.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/abstract/montgomery.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-keypairs/src/utils/getAlgorithmFromKey.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/node_modules/@noble/hashes/src/hmac.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/abstract/modular.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/src/abstract/edwards.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-address-codec/src/utils.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/node_modules/@noble/hashes/src/crypto.ts","webpack://xrplf_secret_numbers/../../node_modules/@xrplf/isomorphic/src/internal/normalizeInput.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-keypairs/src/utils/Sha512.ts","webpack://xrplf_secret_numbers/../../node_modules/@xrplf/isomorphic/src/sha512/browser.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/hashes/src/_md.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/node_modules/@noble/hashes/src/_u64.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/hashes/src/sha512.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/node_modules/@noble/hashes/src/sha256.ts","webpack://xrplf_secret_numbers/../../node_modules/ripple-keypairs/src/signing-schemes/secp256k1/utils.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/curves/node_modules/@noble/hashes/src/utils.ts","webpack://xrplf_secret_numbers/../../node_modules/@noble/hashes/src/sha256.ts","webpack://xrplf_secret_numbers/webpack/bootstrap","webpack://xrplf_secret_numbers/webpack/startup"],"sourcesContent":["/**\n * NIST secp256k1. See [pdf](https://www.secg.org/sec2-v2.pdf).\n *\n * Seems to be rigid (not backdoored)\n * [as per discussion](https://bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975).\n *\n * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.\n * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.\n * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.\n * [See explanation](https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066).\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha256 } from '@noble/hashes/sha256';\nimport { randomBytes } from '@noble/hashes/utils';\nimport { createCurve, type CurveFnWithCreate } from './_shortw_utils.js';\nimport { createHasher, type HTFMethod, isogenyMap } from './abstract/hash-to-curve.js';\nimport { Field, mod, pow2 } from './abstract/modular.js';\nimport type { Hex, PrivKey } from './abstract/utils.js';\nimport {\n  aInRange,\n  bytesToNumberBE,\n  concatBytes,\n  ensureBytes,\n  inRange,\n  numberToBytesBE,\n} from './abstract/utils.js';\nimport { mapToCurveSimpleSWU, type ProjPointType as PointType } from './abstract/weierstrass.js';\n\nconst secp256k1P = BigInt('0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f');\nconst secp256k1N = BigInt('0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141');\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\nconst divNearest = (a: bigint, b: bigint) => (a + b / _2n) / b;\n\n/**\n * n = n^((p+1)/4) for fields p = 3 mod 4. We unwrap the loop and multiply bit-by-bit.\n * (P+1n/4n).toString(2) would produce bits [223x 1, 0, 22x 1, 4x 0, 11, 00]\n */\nfunction sqrtMod(y: bigint): bigint {\n  const P = secp256k1P;\n  // prettier-ignore\n  const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);\n  // prettier-ignore\n  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);\n  const b2 = (y * y * y) % P; // x^3, 11\n  const b3 = (b2 * b2 * y) % P; // x^7\n  const b6 = (pow2(b3, _3n, P) * b3) % P;\n  const b9 = (pow2(b6, _3n, P) * b3) % P;\n  const b11 = (pow2(b9, _2n, P) * b2) % P;\n  const b22 = (pow2(b11, _11n, P) * b11) % P;\n  const b44 = (pow2(b22, _22n, P) * b22) % P;\n  const b88 = (pow2(b44, _44n, P) * b44) % P;\n  const b176 = (pow2(b88, _88n, P) * b88) % P;\n  const b220 = (pow2(b176, _44n, P) * b44) % P;\n  const b223 = (pow2(b220, _3n, P) * b3) % P;\n  const t1 = (pow2(b223, _23n, P) * b22) % P;\n  const t2 = (pow2(t1, _6n, P) * b2) % P;\n  const root = pow2(t2, _2n, P);\n  if (!Fpk1.eql(Fpk1.sqr(root), y)) throw new Error('Cannot find square root');\n  return root;\n}\n\nconst Fpk1 = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });\n\n/**\n * secp256k1 short weierstrass curve and ECDSA signatures over it.\n *\n * @example\n * import { secp256k1 } from '@noble/curves/secp256k1';\n *\n * const priv = secp256k1.utils.randomPrivateKey();\n * const pub = secp256k1.getPublicKey(priv);\n * const msg = new Uint8Array(32).fill(1); // message hash (not message) in ecdsa\n * const sig = secp256k1.sign(msg, priv); // `{prehash: true}` option is available\n * const isValid = secp256k1.verify(sig, msg, pub) === true;\n */\nexport const secp256k1: CurveFnWithCreate = createCurve(\n  {\n    a: BigInt(0), // equation params: a, b\n    b: BigInt(7),\n    Fp: Fpk1, // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n\n    n: secp256k1N, // Curve order, total count of valid points in the field\n    // Base point (x, y) aka generator point\n    Gx: BigInt('55066263022277343669578718895168534326250603453777594175500187360389116729240'),\n    Gy: BigInt('32670510020758816978083085130507043184471273380659243275938904335757337482424'),\n    h: BigInt(1), // Cofactor\n    lowS: true, // Allow only low-S signatures by default in sign() and verify()\n    endo: {\n      // Endomorphism, see above\n      beta: BigInt('0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee'),\n      splitScalar: (k: bigint) => {\n        const n = secp256k1N;\n        const a1 = BigInt('0x3086d221a7d46bcde86c90e49284eb15');\n        const b1 = -_1n * BigInt('0xe4437ed6010e88286f547fa90abfe4c3');\n        const a2 = BigInt('0x114ca50f7a8e2f3f657c1108d9d44cfd8');\n        const b2 = a1;\n        const POW_2_128 = BigInt('0x100000000000000000000000000000000'); // (2n**128n).toString(16)\n\n        const c1 = divNearest(b2 * k, n);\n        const c2 = divNearest(-b1 * k, n);\n        let k1 = mod(k - c1 * a1 - c2 * a2, n);\n        let k2 = mod(-c1 * b1 - c2 * b2, n);\n        const k1neg = k1 > POW_2_128;\n        const k2neg = k2 > POW_2_128;\n        if (k1neg) k1 = n - k1;\n        if (k2neg) k2 = n - k2;\n        if (k1 > POW_2_128 || k2 > POW_2_128) {\n          throw new Error('splitScalar: Endomorphism failed, k=' + k);\n        }\n        return { k1neg, k1, k2neg, k2 };\n      },\n    },\n  },\n  sha256\n);\n\n// Schnorr signatures are superior to ECDSA from above. Below is Schnorr-specific BIP0340 code.\n// https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\nconst _0n = BigInt(0);\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\nconst TAGGED_HASH_PREFIXES: { [tag: string]: Uint8Array } = {};\nfunction taggedHash(tag: string, ...messages: Uint8Array[]): Uint8Array {\n  let tagP = TAGGED_HASH_PREFIXES[tag];\n  if (tagP === undefined) {\n    const tagH = sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));\n    tagP = concatBytes(tagH, tagH);\n    TAGGED_HASH_PREFIXES[tag] = tagP;\n  }\n  return sha256(concatBytes(tagP, ...messages));\n}\n\n// ECDSA compact points are 33-byte. Schnorr is 32: we strip first byte 0x02 or 0x03\nconst pointToBytes = (point: PointType<bigint>) => point.toRawBytes(true).slice(1);\nconst numTo32b = (n: bigint) => numberToBytesBE(n, 32);\nconst modP = (x: bigint) => mod(x, secp256k1P);\nconst modN = (x: bigint) => mod(x, secp256k1N);\nconst Point = secp256k1.ProjectivePoint;\nconst GmulAdd = (Q: PointType<bigint>, a: bigint, b: bigint) =>\n  Point.BASE.multiplyAndAddUnsafe(Q, a, b);\n\n// Calculate point, scalar and bytes\nfunction schnorrGetExtPubKey(priv: PrivKey) {\n  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv); // same method executed in fromPrivateKey\n  let p = Point.fromPrivateKey(d_); // P = d'G; 0 < d' < n check is done inside\n  const scalar = p.hasEvenY() ? d_ : modN(-d_);\n  return { scalar: scalar, bytes: pointToBytes(p) };\n}\n/**\n * lift_x from BIP340. Convert 32-byte x coordinate to elliptic curve point.\n * @returns valid point checked for being on-curve\n */\nfunction lift_x(x: bigint): PointType<bigint> {\n  aInRange('x', x, _1n, secp256k1P); // Fail if x  p.\n  const xx = modP(x * x);\n  const c = modP(xx * x + BigInt(7)); // Let c = x + 7 mod p.\n  let y = sqrtMod(c); // Let y = c^(p+1)/4 mod p.\n  if (y % _2n !== _0n) y = modP(-y); // Return the unique point P such that x(P) = x and\n  const p = new Point(x, y, _1n); // y(P) = y if y mod 2 = 0 or y(P) = p-y otherwise.\n  p.assertValidity();\n  return p;\n}\nconst num = bytesToNumberBE;\n/**\n * Create tagged hash, convert it to bigint, reduce modulo-n.\n */\nfunction challenge(...args: Uint8Array[]): bigint {\n  return modN(num(taggedHash('BIP0340/challenge', ...args)));\n}\n\n/**\n * Schnorr public key is just `x` coordinate of Point as per BIP340.\n */\nfunction schnorrGetPublicKey(privateKey: Hex): Uint8Array {\n  return schnorrGetExtPubKey(privateKey).bytes; // d'=int(sk). Fail if d'=0 or d'n. Ret bytes(d'G)\n}\n\n/**\n * Creates Schnorr signature as per BIP340. Verifies itself before returning anything.\n * auxRand is optional and is not the sole source of k generation: bad CSPRNG won't be dangerous.\n */\nfunction schnorrSign(\n  message: Hex,\n  privateKey: PrivKey,\n  auxRand: Hex = randomBytes(32)\n): Uint8Array {\n  const m = ensureBytes('message', message);\n  const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey); // checks for isWithinCurveOrder\n  const a = ensureBytes('auxRand', auxRand, 32); // Auxiliary random data a: a 32-byte array\n  const t = numTo32b(d ^ num(taggedHash('BIP0340/aux', a))); // Let t be the byte-wise xor of bytes(d) and hash/aux(a)\n  const rand = taggedHash('BIP0340/nonce', t, px, m); // Let rand = hash/nonce(t || bytes(P) || m)\n  const k_ = modN(num(rand)); // Let k' = int(rand) mod n\n  if (k_ === _0n) throw new Error('sign failed: k is zero'); // Fail if k' = 0.\n  const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_); // Let R = k'G.\n  const e = challenge(rx, px, m); // Let e = int(hash/challenge(bytes(R) || bytes(P) || m)) mod n.\n  const sig = new Uint8Array(64); // Let sig = bytes(R) || bytes((k + ed) mod n).\n  sig.set(rx, 0);\n  sig.set(numTo32b(modN(k + e * d)), 32);\n  // If Verify(bytes(P), m, sig) (see below) returns failure, abort\n  if (!schnorrVerify(sig, m, px)) throw new Error('sign: Invalid signature produced');\n  return sig;\n}\n\n/**\n * Verifies Schnorr signature.\n * Will swallow errors & return false except for initial type validation of arguments.\n */\nfunction schnorrVerify(signature: Hex, message: Hex, publicKey: Hex): boolean {\n  const sig = ensureBytes('signature', signature, 64);\n  const m = ensureBytes('message', message);\n  const pub = ensureBytes('publicKey', publicKey, 32);\n  try {\n    const P = lift_x(num(pub)); // P = lift_x(int(pk)); fail if that fails\n    const r = num(sig.subarray(0, 32)); // Let r = int(sig[0:32]); fail if r  p.\n    if (!inRange(r, _1n, secp256k1P)) return false;\n    const s = num(sig.subarray(32, 64)); // Let s = int(sig[32:64]); fail if s  n.\n    if (!inRange(s, _1n, secp256k1N)) return false;\n    const e = challenge(numTo32b(r), pointToBytes(P), m); // int(challenge(bytes(r)||bytes(P)||m))%n\n    const R = GmulAdd(P, s, modN(-e)); // R = sG - eP\n    if (!R || !R.hasEvenY() || R.toAffine().x !== r) return false; // -eP == (n-e)P\n    return true; // Fail if is_infinite(R) / not has_even_y(R) / x(R)  r.\n  } catch (error) {\n    return false;\n  }\n}\n\nexport type SecpSchnorr = {\n  getPublicKey: typeof schnorrGetPublicKey;\n  sign: typeof schnorrSign;\n  verify: typeof schnorrVerify;\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    lift_x: typeof lift_x;\n    pointToBytes: (point: PointType<bigint>) => Uint8Array;\n    numberToBytesBE: typeof numberToBytesBE;\n    bytesToNumberBE: typeof bytesToNumberBE;\n    taggedHash: typeof taggedHash;\n    mod: typeof mod;\n  };\n};\n/**\n * Schnorr signatures over secp256k1.\n * https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki\n * @example\n * import { schnorr } from '@noble/curves/secp256k1';\n * const priv = schnorr.utils.randomPrivateKey();\n * const pub = schnorr.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = schnorr.sign(msg, priv);\n * const isValid = schnorr.verify(sig, msg, pub);\n */\nexport const schnorr: SecpSchnorr = /* @__PURE__ */ (() => ({\n  getPublicKey: schnorrGetPublicKey,\n  sign: schnorrSign,\n  verify: schnorrVerify,\n  utils: {\n    randomPrivateKey: secp256k1.utils.randomPrivateKey,\n    lift_x,\n    pointToBytes,\n    numberToBytesBE,\n    bytesToNumberBE,\n    taggedHash,\n    mod,\n  },\n}))();\n\nconst isoMap = /* @__PURE__ */ (() =>\n  isogenyMap(\n    Fpk1,\n    [\n      // xNum\n      [\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7',\n        '0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581',\n        '0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262',\n        '0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c',\n      ],\n      // xDen\n      [\n        '0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b',\n        '0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n      // yNum\n      [\n        '0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c',\n        '0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3',\n        '0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931',\n        '0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84',\n      ],\n      // yDen\n      [\n        '0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b',\n        '0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573',\n        '0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f',\n        '0x0000000000000000000000000000000000000000000000000000000000000001', // LAST 1\n      ],\n    ].map((i) => i.map((j) => BigInt(j))) as [bigint[], bigint[], bigint[], bigint[]]\n  ))();\nconst mapSWU = /* @__PURE__ */ (() =>\n  mapToCurveSimpleSWU(Fpk1, {\n    A: BigInt('0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533'),\n    B: BigInt('1771'),\n    Z: Fpk1.create(BigInt('-11')),\n  }))();\nconst htf = /* @__PURE__ */ (() =>\n  createHasher(\n    secp256k1.ProjectivePoint,\n    (scalars: bigint[]) => {\n      const { x, y } = mapSWU(Fpk1.create(scalars[0]));\n      return isoMap(x, y);\n    },\n    {\n      DST: 'secp256k1_XMD:SHA-256_SSWU_RO_',\n      encodeDST: 'secp256k1_XMD:SHA-256_SSWU_NU_',\n      p: Fpk1.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha256,\n    }\n  ))();\n\n/** secp256k1 hash-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */\nexport const hashToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() => htf.hashToCurve)();\n\n/** secp256k1 encode-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380). */\nexport const encodeToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() => htf.encodeToCurve)();\n","/**\n\nSHA1 (RFC 3174), MD5 (RFC 1321) and RIPEMD160 (RFC 2286) legacy, weak hash functions.\nDon't use them in a new protocol. What \"weak\" means:\n\n- Collisions can be made with 2^18 effort in MD5, 2^60 in SHA1, 2^80 in RIPEMD160.\n- No practical pre-image attacks (only theoretical, 2^123.4)\n- HMAC seems kinda ok: https://datatracker.ietf.org/doc/html/rfc6151\n * @module\n */\nimport { Chi, HashMD, Maj } from './_md.ts';\nimport { type CHash, clean, createHasher, rotl } from './utils.ts';\n\n/** Initial SHA1 state */\nconst SHA1_IV = /* @__PURE__ */ Uint32Array.from([\n  0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0,\n]);\n\n// Reusable temporary buffer\nconst SHA1_W = /* @__PURE__ */ new Uint32Array(80);\n\n/** SHA1 legacy hash class. */\nexport class SHA1 extends HashMD<SHA1> {\n  private A = SHA1_IV[0] | 0;\n  private B = SHA1_IV[1] | 0;\n  private C = SHA1_IV[2] | 0;\n  private D = SHA1_IV[3] | 0;\n  private E = SHA1_IV[4] | 0;\n\n  constructor() {\n    super(64, 20, 8, false);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { A, B, C, D, E } = this;\n    return [A, B, C, D, E];\n  }\n  protected set(A: number, B: number, C: number, D: number, E: number): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) SHA1_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 80; i++)\n      SHA1_W[i] = rotl(SHA1_W[i - 3] ^ SHA1_W[i - 8] ^ SHA1_W[i - 14] ^ SHA1_W[i - 16], 1);\n    // Compression function main loop, 80 rounds\n    let { A, B, C, D, E } = this;\n    for (let i = 0; i < 80; i++) {\n      let F, K;\n      if (i < 20) {\n        F = Chi(B, C, D);\n        K = 0x5a827999;\n      } else if (i < 40) {\n        F = B ^ C ^ D;\n        K = 0x6ed9eba1;\n      } else if (i < 60) {\n        F = Maj(B, C, D);\n        K = 0x8f1bbcdc;\n      } else {\n        F = B ^ C ^ D;\n        K = 0xca62c1d6;\n      }\n      const T = (rotl(A, 5) + F + E + K + SHA1_W[i]) | 0;\n      E = D;\n      D = C;\n      C = rotl(B, 30);\n      B = A;\n      A = T;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    this.set(A, B, C, D, E);\n  }\n  protected roundClean(): void {\n    clean(SHA1_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/** SHA1 (RFC 3174) legacy hash function. It was cryptographically broken. */\nexport const sha1: CHash = /* @__PURE__ */ createHasher(() => new SHA1());\n\n/** Per-round constants */\nconst p32 = /* @__PURE__ */ Math.pow(2, 32);\nconst K = /* @__PURE__ */ Array.from({ length: 64 }, (_, i) =>\n  Math.floor(p32 * Math.abs(Math.sin(i + 1)))\n);\n\n/** md5 initial state: same as sha1, but 4 u32 instead of 5. */\nconst MD5_IV = /* @__PURE__ */ SHA1_IV.slice(0, 4);\n\n// Reusable temporary buffer\nconst MD5_W = /* @__PURE__ */ new Uint32Array(16);\n/** MD5 legacy hash class. */\nexport class MD5 extends HashMD<MD5> {\n  private A = MD5_IV[0] | 0;\n  private B = MD5_IV[1] | 0;\n  private C = MD5_IV[2] | 0;\n  private D = MD5_IV[3] | 0;\n\n  constructor() {\n    super(64, 16, 8, true);\n  }\n  protected get(): [number, number, number, number] {\n    const { A, B, C, D } = this;\n    return [A, B, C, D];\n  }\n  protected set(A: number, B: number, C: number, D: number): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) MD5_W[i] = view.getUint32(offset, true);\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D } = this;\n    for (let i = 0; i < 64; i++) {\n      let F, g, s;\n      if (i < 16) {\n        F = Chi(B, C, D);\n        g = i;\n        s = [7, 12, 17, 22];\n      } else if (i < 32) {\n        F = Chi(D, B, C);\n        g = (5 * i + 1) % 16;\n        s = [5, 9, 14, 20];\n      } else if (i < 48) {\n        F = B ^ C ^ D;\n        g = (3 * i + 5) % 16;\n        s = [4, 11, 16, 23];\n      } else {\n        F = C ^ (B | ~D);\n        g = (7 * i) % 16;\n        s = [6, 10, 15, 21];\n      }\n      F = F + A + K[i] + MD5_W[g];\n      A = D;\n      D = C;\n      C = B;\n      B = B + rotl(F, s[i % 4]);\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    this.set(A, B, C, D);\n  }\n  protected roundClean(): void {\n    clean(MD5_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\n/**\n * MD5 (RFC 1321) legacy hash function. It was cryptographically broken.\n * MD5 architecture is similar to SHA1, with some differences:\n * - Reduced output length: 16 bytes (128 bit) instead of 20\n * - 64 rounds, instead of 80\n * - Little-endian: could be faster, but will require more code\n * - Non-linear index selection: huge speed-up for unroll\n * - Per round constants: more memory accesses, additional speed-up for unroll\n */\nexport const md5: CHash = /* @__PURE__ */ createHasher(() => new MD5());\n\n// RIPEMD-160\n\nconst Rho160 = /* @__PURE__ */ Uint8Array.from([\n  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,\n]);\nconst Id160 = /* @__PURE__ */ (() => Uint8Array.from(new Array(16).fill(0).map((_, i) => i)))();\nconst Pi160 = /* @__PURE__ */ (() => Id160.map((i) => (9 * i + 5) % 16))();\nconst idxLR = /* @__PURE__ */ (() => {\n  const L = [Id160];\n  const R = [Pi160];\n  const res = [L, R];\n  for (let i = 0; i < 4; i++) for (let j of res) j.push(j[i].map((k) => Rho160[k]));\n  return res;\n})();\nconst idxL = /* @__PURE__ */ (() => idxLR[0])();\nconst idxR = /* @__PURE__ */ (() => idxLR[1])();\n// const [idxL, idxR] = idxLR;\n\nconst shifts160 = /* @__PURE__ */ [\n  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],\n  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],\n  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],\n  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],\n  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5],\n].map((i) => Uint8Array.from(i));\nconst shiftsL160 = /* @__PURE__ */ idxL.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst shiftsR160 = /* @__PURE__ */ idxR.map((idx, i) => idx.map((j) => shifts160[i][j]));\nconst Kl160 = /* @__PURE__ */ Uint32Array.from([\n  0x00000000, 0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xa953fd4e,\n]);\nconst Kr160 = /* @__PURE__ */ Uint32Array.from([\n  0x50a28be6, 0x5c4dd124, 0x6d703ef3, 0x7a6d76e9, 0x00000000,\n]);\n// It's called f() in spec.\nfunction ripemd_f(group: number, x: number, y: number, z: number): number {\n  if (group === 0) return x ^ y ^ z;\n  if (group === 1) return (x & y) | (~x & z);\n  if (group === 2) return (x | ~y) ^ z;\n  if (group === 3) return (x & z) | (y & ~z);\n  return x ^ (y | ~z);\n}\n// Reusable temporary buffer\nconst BUF_160 = /* @__PURE__ */ new Uint32Array(16);\nexport class RIPEMD160 extends HashMD<RIPEMD160> {\n  private h0 = 0x67452301 | 0;\n  private h1 = 0xefcdab89 | 0;\n  private h2 = 0x98badcfe | 0;\n  private h3 = 0x10325476 | 0;\n  private h4 = 0xc3d2e1f0 | 0;\n\n  constructor() {\n    super(64, 20, 8, true);\n  }\n  protected get(): [number, number, number, number, number] {\n    const { h0, h1, h2, h3, h4 } = this;\n    return [h0, h1, h2, h3, h4];\n  }\n  protected set(h0: number, h1: number, h2: number, h3: number, h4: number): void {\n    this.h0 = h0 | 0;\n    this.h1 = h1 | 0;\n    this.h2 = h2 | 0;\n    this.h3 = h3 | 0;\n    this.h4 = h4 | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    for (let i = 0; i < 16; i++, offset += 4) BUF_160[i] = view.getUint32(offset, true);\n    // prettier-ignore\n    let al = this.h0 | 0, ar = al,\n        bl = this.h1 | 0, br = bl,\n        cl = this.h2 | 0, cr = cl,\n        dl = this.h3 | 0, dr = dl,\n        el = this.h4 | 0, er = el;\n\n    // Instead of iterating 0 to 80, we split it into 5 groups\n    // And use the groups in constants, functions, etc. Much simpler\n    for (let group = 0; group < 5; group++) {\n      const rGroup = 4 - group;\n      const hbl = Kl160[group], hbr = Kr160[group]; // prettier-ignore\n      const rl = idxL[group], rr = idxR[group]; // prettier-ignore\n      const sl = shiftsL160[group], sr = shiftsR160[group]; // prettier-ignore\n      for (let i = 0; i < 16; i++) {\n        const tl = (rotl(al + ripemd_f(group, bl, cl, dl) + BUF_160[rl[i]] + hbl, sl[i]) + el) | 0;\n        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl; // prettier-ignore\n      }\n      // 2 loops are 10% faster\n      for (let i = 0; i < 16; i++) {\n        const tr = (rotl(ar + ripemd_f(rGroup, br, cr, dr) + BUF_160[rr[i]] + hbr, sr[i]) + er) | 0;\n        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr; // prettier-ignore\n      }\n    }\n    // Add the compressed chunk to the current hash value\n    this.set(\n      (this.h1 + cl + dr) | 0,\n      (this.h2 + dl + er) | 0,\n      (this.h3 + el + ar) | 0,\n      (this.h4 + al + br) | 0,\n      (this.h0 + bl + cr) | 0\n    );\n  }\n  protected roundClean(): void {\n    clean(BUF_160);\n  }\n  destroy(): void {\n    this.destroyed = true;\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0);\n  }\n}\n\n/**\n * RIPEMD-160 - a legacy hash function from 1990s.\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n */\nexport const ripemd160: CHash = /* @__PURE__ */ createHasher(() => new RIPEMD160());\n","/**\n * hash-to-curve from [RFC 9380](https://www.rfc-editor.org/rfc/rfc9380).\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport type { AffinePoint, Group, GroupConstructor } from './curve.js';\nimport { type IField, mod } from './modular.js';\nimport type { CHash } from './utils.js';\nimport { abytes, bytesToNumberBE, concatBytes, utf8ToBytes, validateObject } from './utils.js';\n\nexport type UnicodeOrBytes = string | Uint8Array;\n\n/**\n * * `DST` is a domain separation tag, defined in section 2.2.5\n * * `p` characteristic of F, where F is a finite field of characteristic p and order q = p^m\n * * `m` is extension degree (1 for prime fields)\n * * `k` is the target security target in bits (e.g. 128), from section 5.1\n * * `expand` is `xmd` (SHA2, SHA3, BLAKE) or `xof` (SHAKE, BLAKE-XOF)\n * * `hash` conforming to `utils.CHash` interface, with `outputLen` / `blockLen` props\n */\nexport type Opts = {\n  DST: UnicodeOrBytes;\n  p: bigint;\n  m: number;\n  k: number;\n  expand: 'xmd' | 'xof';\n  hash: CHash;\n};\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = bytesToNumberBE;\n\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value: number, length: number): Uint8Array {\n  anum(value);\n  anum(length);\n  if (value < 0 || value >= 1 << (8 * length)) throw new Error('invalid I2OSP input: ' + value);\n  const res = Array.from({ length }).fill(0) as number[];\n  for (let i = length - 1; i >= 0; i--) {\n    res[i] = value & 0xff;\n    value >>>= 8;\n  }\n  return new Uint8Array(res);\n}\n\nfunction strxor(a: Uint8Array, b: Uint8Array): Uint8Array {\n  const arr = new Uint8Array(a.length);\n  for (let i = 0; i < a.length; i++) {\n    arr[i] = a[i] ^ b[i];\n  }\n  return arr;\n}\n\nfunction anum(item: unknown): void {\n  if (!Number.isSafeInteger(item)) throw new Error('number expected');\n}\n\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */\nexport function expand_message_xmd(\n  msg: Uint8Array,\n  DST: Uint8Array,\n  lenInBytes: number,\n  H: CHash\n): Uint8Array {\n  abytes(msg);\n  abytes(DST);\n  anum(lenInBytes);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  if (DST.length > 255) DST = H(concatBytes(utf8ToBytes('H2C-OVERSIZE-DST-'), DST));\n  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n  const ell = Math.ceil(lenInBytes / b_in_bytes);\n  if (lenInBytes > 65535 || ell > 255) throw new Error('expand_message_xmd: invalid lenInBytes');\n  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\n  const Z_pad = i2osp(0, r_in_bytes);\n  const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n  const b = new Array<Uint8Array>(ell);\n  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\n  for (let i = 1; i <= ell; i++) {\n    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n    b[i] = H(concatBytes(...args));\n  }\n  const pseudo_random_bytes = concatBytes(...b);\n  return pseudo_random_bytes.slice(0, lenInBytes);\n}\n\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */\nexport function expand_message_xof(\n  msg: Uint8Array,\n  DST: Uint8Array,\n  lenInBytes: number,\n  k: number,\n  H: CHash\n): Uint8Array {\n  abytes(msg);\n  abytes(DST);\n  anum(lenInBytes);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n  if (DST.length > 255) {\n    const dkLen = Math.ceil((2 * k) / 8);\n    DST = H.create({ dkLen }).update(utf8ToBytes('H2C-OVERSIZE-DST-')).update(DST).digest();\n  }\n  if (lenInBytes > 65535 || DST.length > 255)\n    throw new Error('expand_message_xof: invalid lenInBytes');\n  return (\n    H.create({ dkLen: lenInBytes })\n      .update(msg)\n      .update(i2osp(lenInBytes, 2))\n      // 2. DST_prime = DST || I2OSP(len(DST), 1)\n      .update(DST)\n      .update(i2osp(DST.length, 1))\n      .digest()\n  );\n}\n\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nexport function hash_to_field(msg: Uint8Array, count: number, options: Opts): bigint[][] {\n  validateObject(options, {\n    DST: 'stringOrUint8Array',\n    p: 'bigint',\n    m: 'isSafeInteger',\n    k: 'isSafeInteger',\n    hash: 'hash',\n  });\n  const { p, k, m, hash, expand, DST: _DST } = options;\n  abytes(msg);\n  anum(count);\n  const DST = typeof _DST === 'string' ? utf8ToBytes(_DST) : _DST;\n  const log2p = p.toString(2).length;\n  const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n  const len_in_bytes = count * m * L;\n  let prb; // pseudo_random_bytes\n  if (expand === 'xmd') {\n    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n  } else if (expand === 'xof') {\n    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n  } else if (expand === '_internal_pass') {\n    // for internal tests only\n    prb = msg;\n  } else {\n    throw new Error('expand must be \"xmd\" or \"xof\"');\n  }\n  const u = new Array(count);\n  for (let i = 0; i < count; i++) {\n    const e = new Array(m);\n    for (let j = 0; j < m; j++) {\n      const elm_offset = L * (j + i * m);\n      const tv = prb.subarray(elm_offset, elm_offset + L);\n      e[j] = mod(os2ip(tv), p);\n    }\n    u[i] = e;\n  }\n  return u;\n}\n\nexport type XY<T> = (\n  x: T,\n  y: T\n) => {\n  x: T;\n  y: T;\n};\nexport function isogenyMap<T, F extends IField<T>>(field: F, map: [T[], T[], T[], T[]]): XY<T> {\n  // Make same order as in spec\n  const COEFF = map.map((i) => Array.from(i).reverse());\n  return (x: T, y: T) => {\n    const [xNum, xDen, yNum, yDen] = COEFF.map((val) =>\n      val.reduce((acc, i) => field.add(field.mul(acc, x), i))\n    );\n    x = field.div(xNum, xDen); // xNum / xDen\n    y = field.mul(y, field.div(yNum, yDen)); // y * (yNum / yDev)\n    return { x: x, y: y };\n  };\n}\n\n/** Point interface, which curves must implement to work correctly with the module. */\nexport interface H2CPoint<T> extends Group<H2CPoint<T>> {\n  add(rhs: H2CPoint<T>): H2CPoint<T>;\n  toAffine(iz?: bigint): AffinePoint<T>;\n  clearCofactor(): H2CPoint<T>;\n  assertValidity(): void;\n}\n\nexport interface H2CPointConstructor<T> extends GroupConstructor<H2CPoint<T>> {\n  fromAffine(ap: AffinePoint<T>): H2CPoint<T>;\n}\n\nexport type MapToCurve<T> = (scalar: bigint[]) => AffinePoint<T>;\n\n// Separated from initialization opts, so users won't accidentally change per-curve parameters\n// (changing DST is ok!)\nexport type htfBasicOpts = { DST: UnicodeOrBytes };\nexport type HTFMethod<T> = (msg: Uint8Array, options?: htfBasicOpts) => H2CPoint<T>;\nexport type MapMethod<T> = (scalars: bigint[]) => H2CPoint<T>;\n\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. */\nexport function createHasher<T>(\n  Point: H2CPointConstructor<T>,\n  mapToCurve: MapToCurve<T>,\n  def: Opts & { encodeDST?: UnicodeOrBytes }\n): {\n  hashToCurve: HTFMethod<T>;\n  encodeToCurve: HTFMethod<T>;\n  mapToCurve: MapMethod<T>;\n} {\n  if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');\n  return {\n    // Encodes byte string to elliptic curve.\n    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n    hashToCurve(msg: Uint8Array, options?: htfBasicOpts): H2CPoint<T> {\n      const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options } as Opts);\n      const u0 = Point.fromAffine(mapToCurve(u[0]));\n      const u1 = Point.fromAffine(mapToCurve(u[1]));\n      const P = u0.add(u1).clearCofactor();\n      P.assertValidity();\n      return P;\n    },\n\n    // Encodes byte string to elliptic curve.\n    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3\n    encodeToCurve(msg: Uint8Array, options?: htfBasicOpts): H2CPoint<T> {\n      const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options } as Opts);\n      const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();\n      P.assertValidity();\n      return P;\n    },\n    // Same as encodeToCurve, but without hash\n    mapToCurve(scalars: bigint[]): H2CPoint<T> {\n      if (!Array.isArray(scalars)) throw new Error('mapToCurve: expected array of bigints');\n      for (const i of scalars)\n        if (typeof i !== 'bigint') throw new Error('mapToCurve: expected array of bigints');\n      const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();\n      P.assertValidity();\n      return P;\n    },\n  };\n}\n","/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { type IField, nLength, validateField } from './modular.js';\nimport { bitLen, validateObject } from './utils.js';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { z?: never; t?: never };\n\nexport interface Group<T extends Group<T>> {\n  double(): T;\n  negate(): T;\n  add(other: T): T;\n  subtract(other: T): T;\n  equals(other: T): boolean;\n  multiply(scalar: bigint): T;\n}\n\nexport type GroupConstructor<T> = {\n  BASE: T;\n  ZERO: T;\n};\nexport type Mapper<T> = (i: T[]) => T[];\n\nfunction constTimeNegate<T extends Group<T>>(condition: boolean, item: T): T {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\n\nfunction validateW(W: number, bits: number) {\n  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n    throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\n\nfunction calcWOpts(W: number, bits: number) {\n  validateW(W, bits);\n  const windows = Math.ceil(bits / W) + 1; // +1, because\n  const windowSize = 2 ** (W - 1); // -1 because we skip zero\n  return { windows, windowSize };\n}\n\nfunction validateMSMPoints(points: any[], c: any) {\n  if (!Array.isArray(points)) throw new Error('array expected');\n  points.forEach((p, i) => {\n    if (!(p instanceof c)) throw new Error('invalid point at index ' + i);\n  });\n}\nfunction validateMSMScalars(scalars: any[], field: any) {\n  if (!Array.isArray(scalars)) throw new Error('array of scalars expected');\n  scalars.forEach((s, i) => {\n    if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);\n  });\n}\n\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes\nconst pointPrecomputes = new WeakMap<any, any[]>();\nconst pointWindowSizes = new WeakMap<any, number>(); // This allows use make points immutable (nothing changes inside)\n\nfunction getW(P: any): number {\n  return pointWindowSizes.get(P) || 1;\n}\n\nexport type IWNAF<T extends Group<T>> = {\n  constTimeNegate: <T extends Group<T>>(condition: boolean, item: T) => T;\n  hasPrecomputes(elm: T): boolean;\n  unsafeLadder(elm: T, n: bigint, p?: T): T;\n  precomputeWindow(elm: T, W: number): Group<T>[];\n  wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T };\n  wNAFUnsafe(W: number, precomputes: T[], n: bigint, acc?: T): T;\n  getPrecomputes(W: number, P: T, transform: Mapper<T>): T[];\n  wNAFCached(P: T, n: bigint, transform: Mapper<T>): { p: T; f: T };\n  wNAFCachedUnsafe(P: T, n: bigint, transform: Mapper<T>, prev?: T): T;\n  setWindowSize(P: T, W: number): void;\n};\n\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport function wNAF<T extends Group<T>>(c: GroupConstructor<T>, bits: number): IWNAF<T> {\n  return {\n    constTimeNegate,\n\n    hasPrecomputes(elm: T) {\n      return getW(elm) !== 1;\n    },\n\n    // non-const time multiplication ladder\n    unsafeLadder(elm: T, n: bigint, p = c.ZERO) {\n      let d: T = elm;\n      while (n > _0n) {\n        if (n & _1n) p = p.add(d);\n        d = d.double();\n        n >>= _1n;\n      }\n      return p;\n    },\n\n    /**\n     * Creates a wNAF precomputation window. Used for caching.\n     * Default window size is set by `utils.precompute()` and is equal to 8.\n     * Number of precomputed points depends on the curve size:\n     * 2^(1) * (Math.ceil( / ) + 1), where:\n     * -  is the window size\n     * -  is the bitlength of the curve order.\n     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n     * @param elm Point instance\n     * @param W window size\n     * @returns precomputed point tables flattened to a single array\n     */\n    precomputeWindow(elm: T, W: number): Group<T>[] {\n      const { windows, windowSize } = calcWOpts(W, bits);\n      const points: T[] = [];\n      let p: T = elm;\n      let base = p;\n      for (let window = 0; window < windows; window++) {\n        base = p;\n        points.push(base);\n        // =1, because we skip zero\n        for (let i = 1; i < windowSize; i++) {\n          base = base.add(p);\n          points.push(base);\n        }\n        p = base.double();\n      }\n      return points;\n    },\n\n    /**\n     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @returns real and fake (for const-time) points\n     */\n    wNAF(W: number, precomputes: T[], n: bigint): { p: T; f: T } {\n      // TODO: maybe check that scalar is less than group order? wNAF behavious is undefined otherwise\n      // But need to carefully remove other checks before wNAF. ORDER == bits here\n      const { windows, windowSize } = calcWOpts(W, bits);\n\n      let p = c.ZERO;\n      let f = c.BASE;\n\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        // Extract W bits.\n        let wbits = Number(n & mask);\n\n        // Shift number by W bits.\n        n >>= shiftBy;\n\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n\n        // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n        // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n        // there is negate now: it is possible that negated element from low value\n        // would be the same as high element, which will create carry into next window.\n        // It's not obvious how this can fail, but still worth investigating later.\n\n        // Check if we're onto Zero point.\n        // Add random point inside current window to f.\n        const offset1 = offset;\n        const offset2 = offset + Math.abs(wbits) - 1; // -1 because we skip zero\n        const cond1 = window % 2 !== 0;\n        const cond2 = wbits < 0;\n        if (wbits === 0) {\n          // The most important part for const-time getPublicKey\n          f = f.add(constTimeNegate(cond1, precomputes[offset1]));\n        } else {\n          p = p.add(constTimeNegate(cond2, precomputes[offset2]));\n        }\n      }\n      // JIT-compiler should not eliminate f here, since it will later be used in normalizeZ()\n      // Even if the variable is still unused, there are some checks which will\n      // throw an exception, so compiler needs to prove they won't happen, which is hard.\n      // At this point there is a way to F be infinity-point even if p is not,\n      // which makes it less const-time: around 1 bigint multiply.\n      return { p, f };\n    },\n\n    /**\n     * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n     * @param W window size\n     * @param precomputes precomputed tables\n     * @param n scalar (we don't check here, but should be less than curve order)\n     * @param acc accumulator point to add result of multiplication\n     * @returns point\n     */\n    wNAFUnsafe(W: number, precomputes: T[], n: bigint, acc: T = c.ZERO): T {\n      const { windows, windowSize } = calcWOpts(W, bits);\n      const mask = BigInt(2 ** W - 1); // Create mask with W ones: 0b1111 for W=4 etc.\n      const maxNumber = 2 ** W;\n      const shiftBy = BigInt(W);\n      for (let window = 0; window < windows; window++) {\n        const offset = window * windowSize;\n        if (n === _0n) break; // No need to go over empty scalar\n        // Extract W bits.\n        let wbits = Number(n & mask);\n        // Shift number by W bits.\n        n >>= shiftBy;\n        // If the bits are bigger than max size, we'll split those.\n        // +224 => 256 - 32\n        if (wbits > windowSize) {\n          wbits -= maxNumber;\n          n += _1n;\n        }\n        if (wbits === 0) continue;\n        let curr = precomputes[offset + Math.abs(wbits) - 1]; // -1 because we skip zero\n        if (wbits < 0) curr = curr.negate();\n        // NOTE: by re-using acc, we can save a lot of additions in case of MSM\n        acc = acc.add(curr);\n      }\n      return acc;\n    },\n\n    getPrecomputes(W: number, P: T, transform: Mapper<T>): T[] {\n      // Calculate precomputes on a first run, reuse them after\n      let comp = pointPrecomputes.get(P);\n      if (!comp) {\n        comp = this.precomputeWindow(P, W) as T[];\n        if (W !== 1) pointPrecomputes.set(P, transform(comp));\n      }\n      return comp;\n    },\n\n    wNAFCached(P: T, n: bigint, transform: Mapper<T>): { p: T; f: T } {\n      const W = getW(P);\n      return this.wNAF(W, this.getPrecomputes(W, P, transform), n);\n    },\n\n    wNAFCachedUnsafe(P: T, n: bigint, transform: Mapper<T>, prev?: T): T {\n      const W = getW(P);\n      if (W === 1) return this.unsafeLadder(P, n, prev); // For W=1 ladder is ~x2 faster\n      return this.wNAFUnsafe(W, this.getPrecomputes(W, P, transform), n, prev);\n    },\n\n    // We calculate precomputes for elliptic curve point multiplication\n    // using windowed method. This specifies window size and\n    // stores precomputed values. Usually only base point would be precomputed.\n\n    setWindowSize(P: T, W: number) {\n      validateW(W, bits);\n      pointWindowSizes.set(P, W);\n      pointPrecomputes.delete(P);\n    },\n  };\n}\n\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster with precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka private keys / bigints)\n */\nexport function pippenger<T extends Group<T>>(\n  c: GroupConstructor<T>,\n  fieldN: IField<bigint>,\n  points: T[],\n  scalars: bigint[]\n): T {\n  // If we split scalars by some window (let's say 8 bits), every chunk will only\n  // take 256 buckets even if there are 4096 scalars, also re-uses double.\n  // TODO:\n  // - https://eprint.iacr.org/2024/750.pdf\n  // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n  // 0 is accepted in scalars\n  validateMSMPoints(points, c);\n  validateMSMScalars(scalars, fieldN);\n  if (points.length !== scalars.length)\n    throw new Error('arrays of points and scalars must have equal length');\n  const zero = c.ZERO;\n  const wbits = bitLen(BigInt(points.length));\n  const windowSize = wbits > 12 ? wbits - 3 : wbits > 4 ? wbits - 2 : wbits ? 2 : 1; // in bits\n  const MASK = (1 << windowSize) - 1;\n  const buckets = new Array(MASK + 1).fill(zero); // +1 for zero array\n  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n  let sum = zero;\n  for (let i = lastBits; i >= 0; i -= windowSize) {\n    buckets.fill(zero);\n    for (let j = 0; j < scalars.length; j++) {\n      const scalar = scalars[j];\n      const wbits = Number((scalar >> BigInt(i)) & BigInt(MASK));\n      buckets[wbits] = buckets[wbits].add(points[j]);\n    }\n    let resI = zero; // not using this will do small speed-up, but will lose ct\n    // Skip first bucket, because it is zero\n    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n      sumI = sumI.add(buckets[j]);\n      resI = resI.add(sumI);\n    }\n    sum = sum.add(resI);\n    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();\n  }\n  return sum as T;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe<T extends Group<T>>(\n  c: GroupConstructor<T>,\n  fieldN: IField<bigint>,\n  points: T[],\n  windowSize: number\n): (scalars: bigint[]) => T {\n  /**\n   * Performance Analysis of Window-based Precomputation\n   *\n   * Base Case (256-bit scalar, 8-bit window):\n   * - Standard precomputation requires:\n   *   - 31 additions per scalar  256 scalars = 7,936 ops\n   *   - Plus 255 summary additions = 8,191 total ops\n   *   Note: Summary additions can be optimized via accumulator\n   *\n   * Chunked Precomputation Analysis:\n   * - Using 32 chunks requires:\n   *   - 255 additions per chunk\n   *   - 256 doublings\n   *   - Total: (255  32) + 256 = 8,416 ops\n   *\n   * Memory Usage Comparison:\n   * Window Size | Standard Points | Chunked Points\n   * ------------|-----------------|---------------\n   *     4-bit   |     520         |      15\n   *     8-bit   |    4,224        |     255\n   *    10-bit   |   13,824        |   1,023\n   *    16-bit   |  557,056        |  65,535\n   *\n   * Key Advantages:\n   * 1. Enables larger window sizes due to reduced memory overhead\n   * 2. More efficient for smaller scalar counts:\n   *    - 16 chunks: (16  255) + 256 = 4,336 ops\n   *    - ~2x faster than standard 8,191 ops\n   *\n   * Limitations:\n   * - Not suitable for plain precomputes (requires 256 constant doublings)\n   * - Performance degrades with larger scalar counts:\n   *   - Optimal for ~256 scalars\n   *   - Less efficient for 4096+ scalars (Pippenger preferred)\n   */\n  validateW(windowSize, fieldN.BITS);\n  validateMSMPoints(points, c);\n  const zero = c.ZERO;\n  const tableSize = 2 ** windowSize - 1; // table size (without zero)\n  const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n  const MASK = BigInt((1 << windowSize) - 1);\n  const tables = points.map((p: T) => {\n    const res = [];\n    for (let i = 0, acc = p; i < tableSize; i++) {\n      res.push(acc);\n      acc = acc.add(p);\n    }\n    return res;\n  });\n  return (scalars: bigint[]): T => {\n    validateMSMScalars(scalars, fieldN);\n    if (scalars.length > points.length)\n      throw new Error('array of scalars must be smaller than array of points');\n    let res = zero;\n    for (let i = 0; i < chunks; i++) {\n      // No need to double if accumulator is still zero.\n      if (res !== zero) for (let j = 0; j < windowSize; j++) res = res.double();\n      const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n      for (let j = 0; j < scalars.length; j++) {\n        const n = scalars[j];\n        const curr = Number((n >> shiftBy) & MASK);\n        if (!curr) continue; // skip zero scalars chunks\n        res = res.add(tables[j][curr - 1]);\n      }\n    }\n    return res;\n  };\n}\n\n/**\n * Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\n * Though generator can be different (Fp2 / Fp6 for BLS).\n */\nexport type BasicCurve<T> = {\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\n  n: bigint; // Curve order, total count of valid points in the field\n  nBitLength?: number; // bit length of curve order\n  nByteLength?: number; // byte length of curve order\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\n  hEff?: bigint; // Number to multiply to clear cofactor\n  Gx: T; // base point X coordinate\n  Gy: T; // base point Y coordinate\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\n};\n\nexport function validateBasic<FP, T>(\n  curve: BasicCurve<FP> & T\n): Readonly<\n  {\n    readonly nBitLength: number;\n    readonly nByteLength: number;\n  } & BasicCurve<FP> &\n    T & {\n      p: bigint;\n    }\n> {\n  validateField(curve.Fp);\n  validateObject(\n    curve,\n    {\n      n: 'bigint',\n      h: 'bigint',\n      Gx: 'field',\n      Gy: 'field',\n    },\n    {\n      nBitLength: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n    }\n  );\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{ p: curve.Fp.ORDER },\n  } as const);\n}\n","/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha512';\nimport { concatBytes, randomBytes, utf8ToBytes } from '@noble/hashes/utils';\nimport { type AffinePoint, type Group, pippenger } from './abstract/curve.js';\nimport { type CurveFn, type ExtPointType, twistedEdwards } from './abstract/edwards.js';\nimport {\n  createHasher,\n  expand_message_xmd,\n  type htfBasicOpts,\n  type HTFMethod,\n} from './abstract/hash-to-curve.js';\nimport { Field, FpSqrtEven, isNegativeLE, mod, pow2 } from './abstract/modular.js';\nimport { montgomery, type CurveFn as XCurveFn } from './abstract/montgomery.js';\nimport {\n  bytesToHex,\n  bytesToNumberLE,\n  ensureBytes,\n  equalBytes,\n  type Hex,\n  numberToBytesLE,\n} from './abstract/utils.js';\n\nconst ED25519_P = BigInt(\n  '57896044618658097711785492504343953926634992332820282019728792003956564819949'\n);\n// (-1) aka (a) aka 2^((p-1)/4)\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(\n  '19681161376707505956807079304988542015446066515923890162744021073123829784752'\n);\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n\nfunction ed25519_pow_2_252_3(x: bigint) {\n  // prettier-ignore\n  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n  const P = ED25519_P;\n  const x2 = (x * x) % P;\n  const b2 = (x2 * x) % P; // x^3, 11\n  const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n  const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n  const b10 = (pow2(b5, _5n, P) * b5) % P;\n  const b20 = (pow2(b10, _10n, P) * b10) % P;\n  const b40 = (pow2(b20, _20n, P) * b20) % P;\n  const b80 = (pow2(b40, _40n, P) * b40) % P;\n  const b160 = (pow2(b80, _80n, P) * b80) % P;\n  const b240 = (pow2(b160, _80n, P) * b80) % P;\n  const b250 = (pow2(b240, _10n, P) * b10) % P;\n  const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n  // ^ To pow to (p+3)/8, multiply it by x.\n  return { pow_p_5_8, b2 };\n}\n\nfunction adjustScalarBytes(bytes: Uint8Array): Uint8Array {\n  // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n  // set the three least significant bits of the first byte\n  bytes[0] &= 248; // 0b1111_1000\n  // and the most significant bit of the last to zero,\n  bytes[31] &= 127; // 0b0111_1111\n  // set the second most significant bit of the last byte to 1\n  bytes[31] |= 64; // 0b0100_0000\n  return bytes;\n}\n\n// sqrt(u/v)\nfunction uvRatio(u: bigint, v: bigint): { isValid: boolean; value: bigint } {\n  const P = ED25519_P;\n  const v3 = mod(v * v * v, P); // v\n  const v7 = mod(v3 * v3 * v, P); // v\n  // (p+3)/8 and (p-5)/8\n  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n  let x = mod(u * v3 * pow, P); // (uv)(uv)^(p-5)/8\n  const vx2 = mod(v * x * x, P); // vx\n  const root1 = x; // First root candidate\n  const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n  const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n  const useRoot2 = vx2 === mod(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)\n  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n  if (isNegativeLE(x, P)) x = mod(-x, P);\n  return { isValid: useRoot1 || useRoot2, value: x };\n}\n\n// Just in case\nexport const ED25519_TORSION_SUBGROUP: string[] = [\n  '0100000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n  '0000000000000000000000000000000000000000000000000000000000000080',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n  'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\n\nconst Fp = /* @__PURE__ */ (() => Field(ED25519_P, undefined, true))();\n\nconst ed25519Defaults = /* @__PURE__ */ (() =>\n  ({\n    // Param: a\n    a: BigInt(-1), // Fp.create(-1) is proper; our way still works and is faster\n    // d is equal to -121665/121666 over finite field.\n    // Negative number is P - number, and division is invert(number, P)\n    d: BigInt('37095705934669439343138083508754565189542113879843219016388785533085940283555'),\n    // Finite field p over which we'll do calculations; 2n**255n - 19n\n    Fp,\n    // Subgroup order: how many points curve has\n    // 2n**252n + 27742317777372353535851937790883648493n;\n    n: BigInt('7237005577332262213973186563042994240857116359379907606001950938285454250989'),\n    // Cofactor\n    h: _8n,\n    // Base point (x, y) aka generator point\n    Gx: BigInt('15112221349535400772501151409588531511454012693041857206046113283949847762202'),\n    Gy: BigInt('46316835694926478169428394003475163141307993866256225615783033603165251855960'),\n    hash: sha512,\n    randomBytes,\n    adjustScalarBytes,\n    // dom2\n    // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n    // Constant-time, u/v\n    uvRatio,\n  }) as const)();\n\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * import { ed25519 } from '@noble/curves/ed25519';\n * const priv = ed25519.utils.randomPrivateKey();\n * const pub = ed25519.getPublicKey(priv);\n * const msg = new TextEncoder().encode('hello');\n * const sig = ed25519.sign(msg, priv);\n * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215\n * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5\n */\nexport const ed25519: CurveFn = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();\n\nfunction ed25519_domain(data: Uint8Array, ctx: Uint8Array, phflag: boolean) {\n  if (ctx.length > 255) throw new Error('Context is too big');\n  return concatBytes(\n    utf8ToBytes('SigEd25519 no Ed25519 collisions'),\n    new Uint8Array([phflag ? 1 : 0, ctx.length]),\n    ctx,\n    data\n  );\n}\n\nexport const ed25519ctx: CurveFn = /* @__PURE__ */ (() =>\n  twistedEdwards({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n  }))();\nexport const ed25519ph: CurveFn = /* @__PURE__ */ (() =>\n  twistedEdwards(\n    Object.assign({}, ed25519Defaults, {\n      domain: ed25519_domain,\n      prehash: sha512,\n    })\n  ))();\n\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * import { x25519 } from '@noble/curves/ed25519';\n * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';\n * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';\n * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases\n * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);\n * x25519.getPublicKey(x25519.utils.randomPrivateKey());\n */\nexport const x25519: XCurveFn = /* @__PURE__ */ (() =>\n  montgomery({\n    P: ED25519_P,\n    a: BigInt(486662),\n    montgomeryBits: 255, // n is 253 bits\n    nByteLength: 32,\n    Gu: BigInt(9),\n    powPminus2: (x: bigint): bigint => {\n      const P = ED25519_P;\n      // x^(p-2) aka x^(2^255-21)\n      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n      return mod(pow2(pow_p_5_8, _3n, P) * b2, P);\n    },\n    adjustScalarBytes,\n    randomBytes,\n  }))();\n\n/**\n * Converts ed25519 public key to x25519 public key. Uses formula:\n * * `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n * * `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n * @example\n *   const someonesPub = ed25519.getPublicKey(ed25519.utils.randomPrivateKey());\n *   const aPriv = x25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(aPriv, edwardsToMontgomeryPub(someonesPub))\n */\nexport function edwardsToMontgomeryPub(edwardsPub: Hex): Uint8Array {\n  const { y } = ed25519.ExtendedPoint.fromHex(edwardsPub);\n  const _1n = BigInt(1);\n  return Fp.toBytes(Fp.create((_1n + y) * Fp.inv(_1n - y)));\n}\nexport const edwardsToMontgomery: typeof edwardsToMontgomeryPub = edwardsToMontgomeryPub; // deprecated\n\n/**\n * Converts ed25519 secret key to x25519 secret key.\n * @example\n *   const someonesPub = x25519.getPublicKey(x25519.utils.randomPrivateKey());\n *   const aPriv = ed25519.utils.randomPrivateKey();\n *   x25519.getSharedSecret(edwardsToMontgomeryPriv(aPriv), someonesPub)\n */\nexport function edwardsToMontgomeryPriv(edwardsPriv: Uint8Array): Uint8Array {\n  const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));\n  return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);\n}\n\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\n\nconst ELL2_C1 = /* @__PURE__ */ (() => (Fp.ORDER + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u: bigint) {\n  const ELL2_C4 = (Fp.ORDER - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n  const ELL2_J = BigInt(486662);\n\n  let tv1 = Fp.sqr(u);          //  1.  tv1 = u^2\n  tv1 = Fp.mul(tv1, _2n);       //  2.  tv1 = 2 * tv1\n  let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n  let x1n = Fp.neg(ELL2_J);     //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n  let tv2 = Fp.sqr(xd);         //  5.  tv2 = xd^2\n  let gxd = Fp.mul(tv2, xd);    //  6.  gxd = tv2 * xd        # gxd = xd^3\n  let gx1 = Fp.mul(tv1, ELL2_J);//  7.  gx1 = J * tv1         # x1n + J * xd\n  gx1 = Fp.mul(gx1, x1n);       //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n  gx1 = Fp.add(gx1, tv2);       //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n  gx1 = Fp.mul(gx1, x1n);       //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n  let tv3 = Fp.sqr(gxd);        //  11. tv3 = gxd^2\n  tv2 = Fp.sqr(tv3);            //  12. tv2 = tv3^2           # gxd^4\n  tv3 = Fp.mul(tv3, gxd);       //  13. tv3 = tv3 * gxd       # gxd^3\n  tv3 = Fp.mul(tv3, gx1);       //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n  tv2 = Fp.mul(tv2, tv3);       //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n  let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n  y11 = Fp.mul(y11, tv3);       //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n  let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n  tv2 = Fp.sqr(y11);            //  19. tv2 = y11^2\n  tv2 = Fp.mul(tv2, gxd);       //  20. tv2 = tv2 * gxd\n  let e1 = Fp.eql(tv2, gx1);    //  21.  e1 = tv2 == gx1\n  let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n  let x2n = Fp.mul(x1n, tv1);   //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n  let y21 = Fp.mul(y11, u);     //  24. y21 = y11 * u\n  y21 = Fp.mul(y21, ELL2_C2);   //  25. y21 = y21 * c2\n  let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n  let gx2 = Fp.mul(gx1, tv1);   //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n  tv2 = Fp.sqr(y21);            //  28. tv2 = y21^2\n  tv2 = Fp.mul(tv2, gxd);       //  29. tv2 = tv2 * gxd\n  let e2 = Fp.eql(tv2, gx2);    //  30.  e2 = tv2 == gx2\n  let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n  tv2 = Fp.sqr(y1);             //  32. tv2 = y1^2\n  tv2 = Fp.mul(tv2, gxd);       //  33. tv2 = tv2 * gxd\n  let e3 = Fp.eql(tv2, gx1);    //  34.  e3 = tv2 == gx1\n  let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n  let y = Fp.cmov(y2, y1, e3);  //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n  let e4 = Fp.isOdd(y);         //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n  y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\n\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u: bigint) {\n  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n  // map_to_curve_elligator2_curve25519(u)\n  let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n  xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n  let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n  let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n  let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n  let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n  let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n  xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n  xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n  yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n  yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n\n  const inv = Fp.invertBatch([xd, yd]); // batch division\n  return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) }; //  13. return (xn, xd, yn, yd)\n}\n\nconst htf = /* @__PURE__ */ (() =>\n  createHasher(\n    ed25519.ExtendedPoint,\n    (scalars: bigint[]) => map_to_curve_elligator2_edwards25519(scalars[0]),\n    {\n      DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n      encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n      p: Fp.ORDER,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha512,\n    }\n  ))();\nexport const hashToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() => htf.hashToCurve)();\nexport const encodeToCurve: HTFMethod<bigint> = /* @__PURE__ */ (() => htf.encodeToCurve)();\n\nfunction assertRstPoint(other: unknown) {\n  if (!(other instanceof RistPoint)) throw new Error('RistrettoPoint expected');\n}\n\n// (-1) aka (a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// (ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt(\n  '25063068953384623474111414158702152701244531502492656460079210482610430750235'\n);\n// 1 / (a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt(\n  '54469307008909316920995813868745141605393597292927456921205312896311721017578'\n);\n// 1-d\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt(\n  '1159843021668779879193775521855586647937357759715417654439879720876111806838'\n);\n// (d-1)\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt(\n  '40440834346308536858101042469323190826248399146238708352240133220865137265952'\n);\n// Calculates 1/(number)\nconst invertSqrt = (number: bigint) => uvRatio(_1n, number);\n\nconst MAX_255B = /* @__PURE__ */ BigInt(\n  '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n);\nconst bytes255ToNumberLE = (bytes: Uint8Array) =>\n  ed25519.CURVE.Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n\ntype ExtendedPoint = ExtPointType;\n\n// Computes Elligator map for Ristretto\n// https://ristretto.group/formulas/elligator.html\nfunction calcElligatorRistrettoMap(r0: bigint): ExtendedPoint {\n  const { d } = ed25519.CURVE;\n  const P = ed25519.CURVE.Fp.ORDER;\n  const mod = ed25519.CURVE.Fp.create;\n  const r = mod(SQRT_M1 * r0 * r0); // 1\n  const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n  let c = BigInt(-1); // 3\n  const D = mod((c - d * r) * mod(r + d)); // 4\n  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n  let s_ = mod(s * r0); // 6\n  if (!isNegativeLE(s_, P)) s_ = mod(-s_);\n  if (!Ns_D_is_sq) s = s_; // 7\n  if (!Ns_D_is_sq) c = r; // 8\n  const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n  const s2 = s * s;\n  const W0 = mod((s + s) * D); // 10\n  const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n  const W2 = mod(_1n - s2); // 12\n  const W3 = mod(_1n + s2); // 13\n  return new ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n\n/**\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-ristretto255-decaf448\n */\nclass RistPoint implements Group<RistPoint> {\n  static BASE: RistPoint;\n  static ZERO: RistPoint;\n  // Private property to discourage combining ExtendedPoint + RistrettoPoint\n  // Always use Ristretto encoding/decoding instead.\n  constructor(private readonly ep: ExtendedPoint) {}\n\n  static fromAffine(ap: AffinePoint<bigint>): RistPoint {\n    return new RistPoint(ed25519.ExtendedPoint.fromAffine(ap));\n  }\n\n  /**\n   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.\n   * The hash-to-group operation applies Elligator twice and adds the results.\n   * **Note:** this is one-way map, there is no conversion from point to hash.\n   * https://ristretto.group/formulas/elligator.html\n   * @param hex 64-byte output of a hash function\n   */\n  static hashToCurve(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHash', hex, 64);\n    const r1 = bytes255ToNumberLE(hex.slice(0, 32));\n    const R1 = calcElligatorRistrettoMap(r1);\n    const r2 = bytes255ToNumberLE(hex.slice(32, 64));\n    const R2 = calcElligatorRistrettoMap(r2);\n    return new RistPoint(R1.add(R2));\n  }\n\n  /**\n   * Converts ristretto-encoded string to ristretto point.\n   * https://ristretto.group/formulas/decoding.html\n   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n   */\n  static fromHex(hex: Hex): RistPoint {\n    hex = ensureBytes('ristrettoHex', hex, 32);\n    const { a, d } = ed25519.CURVE;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const emsg = 'RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint';\n    const s = bytes255ToNumberLE(hex);\n    // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n    // 3. Check that s is non-negative, or else abort\n    if (!equalBytes(numberToBytesLE(s, 32), hex) || isNegativeLE(s, P)) throw new Error(emsg);\n    const s2 = mod(s * s);\n    const u1 = mod(_1n + a * s2); // 4 (a is -1)\n    const u2 = mod(_1n - a * s2); // 5\n    const u1_2 = mod(u1 * u1);\n    const u2_2 = mod(u2 * u2);\n    const v = mod(a * d * u1_2 - u2_2); // 6\n    const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n    const Dx = mod(I * u2); // 8\n    const Dy = mod(I * Dx * v); // 9\n    let x = mod((s + s) * Dx); // 10\n    if (isNegativeLE(x, P)) x = mod(-x); // 10\n    const y = mod(u1 * Dy); // 11\n    const t = mod(x * y); // 12\n    if (!isValid || isNegativeLE(t, P) || y === _0n) throw new Error(emsg);\n    return new RistPoint(new ed25519.ExtendedPoint(x, y, _1n, t));\n  }\n\n  static msm(points: RistPoint[], scalars: bigint[]): RistPoint {\n    const Fn = Field(ed25519.CURVE.n, ed25519.CURVE.nBitLength);\n    return pippenger(RistPoint, Fn, points, scalars);\n  }\n\n  /**\n   * Encodes ristretto point to Uint8Array.\n   * https://ristretto.group/formulas/encoding.html\n   */\n  toRawBytes(): Uint8Array {\n    let { ex: x, ey: y, ez: z, et: t } = this.ep;\n    const P = ed25519.CURVE.Fp.ORDER;\n    const mod = ed25519.CURVE.Fp.create;\n    const u1 = mod(mod(z + y) * mod(z - y)); // 1\n    const u2 = mod(x * y); // 2\n    // Square root always exists\n    const u2sq = mod(u2 * u2);\n    const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n    const D1 = mod(invsqrt * u1); // 4\n    const D2 = mod(invsqrt * u2); // 5\n    const zInv = mod(D1 * D2 * t); // 6\n    let D: bigint; // 7\n    if (isNegativeLE(t * zInv, P)) {\n      let _x = mod(y * SQRT_M1);\n      let _y = mod(x * SQRT_M1);\n      x = _x;\n      y = _y;\n      D = mod(D1 * INVSQRT_A_MINUS_D);\n    } else {\n      D = D2; // 8\n    }\n    if (isNegativeLE(x * zInv, P)) y = mod(-y); // 9\n    let s = mod((z - y) * D); // 10 (check footer's note, no sqrt(-a))\n    if (isNegativeLE(s, P)) s = mod(-s);\n    return numberToBytesLE(s, 32); // 11\n  }\n\n  toHex(): string {\n    return bytesToHex(this.toRawBytes());\n  }\n\n  toString(): string {\n    return this.toHex();\n  }\n\n  // Compare one point to another.\n  equals(other: RistPoint): boolean {\n    assertRstPoint(other);\n    const { ex: X1, ey: Y1 } = this.ep;\n    const { ex: X2, ey: Y2 } = other.ep;\n    const mod = ed25519.CURVE.Fp.create;\n    // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n    const one = mod(X1 * Y2) === mod(Y1 * X2);\n    const two = mod(Y1 * Y2) === mod(X1 * X2);\n    return one || two;\n  }\n\n  add(other: RistPoint): RistPoint {\n    assertRstPoint(other);\n    return new RistPoint(this.ep.add(other.ep));\n  }\n\n  subtract(other: RistPoint): RistPoint {\n    assertRstPoint(other);\n    return new RistPoint(this.ep.subtract(other.ep));\n  }\n\n  multiply(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiply(scalar));\n  }\n\n  multiplyUnsafe(scalar: bigint): RistPoint {\n    return new RistPoint(this.ep.multiplyUnsafe(scalar));\n  }\n\n  double(): RistPoint {\n    return new RistPoint(this.ep.double());\n  }\n\n  negate(): RistPoint {\n    return new RistPoint(this.ep.negate());\n  }\n}\nexport const RistrettoPoint: typeof RistPoint = /* @__PURE__ */ (() => {\n  if (!RistPoint.BASE) RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);\n  if (!RistPoint.ZERO) RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);\n  return RistPoint;\n})();\n\n// Hashing to ristretto255. https://www.rfc-editor.org/rfc/rfc9380#appendix-B\nexport const hashToRistretto255 = (msg: Uint8Array, options: htfBasicOpts): RistPoint => {\n  const d = options.DST;\n  const DST = typeof d === 'string' ? utf8ToBytes(d) : d;\n  const uniform_bytes = expand_message_xmd(msg, DST, 64, sha512);\n  const P = RistPoint.hashToCurve(uniform_bytes);\n  return P;\n};\nexport const hash_to_ristretto255: (msg: Uint8Array, options: htfBasicOpts) => RistPoint =\n  hashToRistretto255; // legacy\n","const assertHelper: {\n  ok: (cond: boolean, message?: string) => asserts cond is true\n} = {\n  ok(cond, message): asserts cond is true {\n    if (!cond) {\n      throw new Error(message)\n    }\n  },\n}\n\nexport default assertHelper\n","/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\nimport { type CHash, clean, createHasher, rotr } from './utils.ts';\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n\n  constructor(outputLen: number = 32) {\n    super(64, outputLen, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    clean(SHA256_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\nexport class SHA224 extends SHA256 {\n  protected A: number = SHA224_IV[0] | 0;\n  protected B: number = SHA224_IV[1] | 0;\n  protected C: number = SHA224_IV[2] | 0;\n  protected D: number = SHA224_IV[3] | 0;\n  protected E: number = SHA224_IV[4] | 0;\n  protected F: number = SHA224_IV[5] | 0;\n  protected G: number = SHA224_IV[6] | 0;\n  protected H: number = SHA224_IV[7] | 0;\n  constructor() {\n    super(28);\n  }\n}\n\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n\nexport class SHA512 extends HashMD<SHA512> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = SHA512_IV[0] | 0;\n  protected Al: number = SHA512_IV[1] | 0;\n  protected Bh: number = SHA512_IV[2] | 0;\n  protected Bl: number = SHA512_IV[3] | 0;\n  protected Ch: number = SHA512_IV[4] | 0;\n  protected Cl: number = SHA512_IV[5] | 0;\n  protected Dh: number = SHA512_IV[6] | 0;\n  protected Dl: number = SHA512_IV[7] | 0;\n  protected Eh: number = SHA512_IV[8] | 0;\n  protected El: number = SHA512_IV[9] | 0;\n  protected Fh: number = SHA512_IV[10] | 0;\n  protected Fl: number = SHA512_IV[11] | 0;\n  protected Gh: number = SHA512_IV[12] | 0;\n  protected Gl: number = SHA512_IV[13] | 0;\n  protected Hh: number = SHA512_IV[14] | 0;\n  protected Hl: number = SHA512_IV[15] | 0;\n\n  constructor(outputLen: number = 64) {\n    super(128, outputLen, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ): void {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean(): void {\n    clean(SHA512_W_H, SHA512_W_L);\n  }\n  destroy(): void {\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nexport class SHA384 extends SHA512 {\n  protected Ah: number = SHA384_IV[0] | 0;\n  protected Al: number = SHA384_IV[1] | 0;\n  protected Bh: number = SHA384_IV[2] | 0;\n  protected Bl: number = SHA384_IV[3] | 0;\n  protected Ch: number = SHA384_IV[4] | 0;\n  protected Cl: number = SHA384_IV[5] | 0;\n  protected Dh: number = SHA384_IV[6] | 0;\n  protected Dl: number = SHA384_IV[7] | 0;\n  protected Eh: number = SHA384_IV[8] | 0;\n  protected El: number = SHA384_IV[9] | 0;\n  protected Fh: number = SHA384_IV[10] | 0;\n  protected Fl: number = SHA384_IV[11] | 0;\n  protected Gh: number = SHA384_IV[12] | 0;\n  protected Gl: number = SHA384_IV[13] | 0;\n  protected Hh: number = SHA384_IV[14] | 0;\n  protected Hl: number = SHA384_IV[15] | 0;\n\n  constructor() {\n    super(48);\n  }\n}\n\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n  0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n  0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n  0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n  0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n\nexport class SHA512_224 extends SHA512 {\n  protected Ah: number = T224_IV[0] | 0;\n  protected Al: number = T224_IV[1] | 0;\n  protected Bh: number = T224_IV[2] | 0;\n  protected Bl: number = T224_IV[3] | 0;\n  protected Ch: number = T224_IV[4] | 0;\n  protected Cl: number = T224_IV[5] | 0;\n  protected Dh: number = T224_IV[6] | 0;\n  protected Dl: number = T224_IV[7] | 0;\n  protected Eh: number = T224_IV[8] | 0;\n  protected El: number = T224_IV[9] | 0;\n  protected Fh: number = T224_IV[10] | 0;\n  protected Fl: number = T224_IV[11] | 0;\n  protected Gh: number = T224_IV[12] | 0;\n  protected Gl: number = T224_IV[13] | 0;\n  protected Hh: number = T224_IV[14] | 0;\n  protected Hl: number = T224_IV[15] | 0;\n\n  constructor() {\n    super(28);\n  }\n}\n\nexport class SHA512_256 extends SHA512 {\n  protected Ah: number = T256_IV[0] | 0;\n  protected Al: number = T256_IV[1] | 0;\n  protected Bh: number = T256_IV[2] | 0;\n  protected Bl: number = T256_IV[3] | 0;\n  protected Ch: number = T256_IV[4] | 0;\n  protected Cl: number = T256_IV[5] | 0;\n  protected Dh: number = T256_IV[6] | 0;\n  protected Dl: number = T256_IV[7] | 0;\n  protected Eh: number = T256_IV[8] | 0;\n  protected El: number = T256_IV[9] | 0;\n  protected Fh: number = T256_IV[10] | 0;\n  protected Fl: number = T256_IV[11] | 0;\n  protected Gh: number = T256_IV[12] | 0;\n  protected Gl: number = T256_IV[13] | 0;\n  protected Hh: number = T256_IV[14] | 0;\n  protected Hl: number = T256_IV[15] | 0;\n\n  constructor() {\n    super(32);\n  }\n}\n\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexport const sha256: CHash = /* @__PURE__ */ createHasher(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224: CHash = /* @__PURE__ */ createHasher(() => new SHA224());\n\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512: CHash = /* @__PURE__ */ createHasher(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384: CHash = /* @__PURE__ */ createHasher(() => new SHA384());\n\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256: CHash = /* @__PURE__ */ createHasher(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224: CHash = /* @__PURE__ */ createHasher(() => new SHA512_224());\n","/**\n * Short Weierstrass curve methods. The formula is: y = x + ax + b.\n *\n * ### Design rationale for types\n *\n * * Interaction between classes from different curves should fail:\n *   `k256.Point.BASE.add(p256.Point.BASE)`\n * * For this purpose we want to use `instanceof` operator, which is fast and works during runtime\n * * Different calls of `curve()` would return different classes -\n *   `curve(params) !== curve(params)`: if somebody decided to monkey-patch their curve,\n *   it won't affect others\n *\n * TypeScript can't infer types for classes created inside a function. Classes is one instance\n * of nominative types in TypeScript and interfaces only check for shape, so it's hard to create\n * unique type for every function call.\n *\n * We can use generic types via some param, like curve opts, but that would:\n *     1. Enable interaction between `curve(params)` and `curve(params)` (curves of same params)\n *     which is hard to debug.\n *     2. Params can be generic and we can't enforce them to be constant value:\n *     if somebody creates curve from non-constant params,\n *     it would be allowed to interact with other curves with non-constant params\n *\n * @todo https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-7.html#unique-symbol\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  type AffinePoint,\n  type BasicCurve,\n  type Group,\n  type GroupConstructor,\n  pippenger,\n  validateBasic,\n  wNAF,\n} from './curve.js';\nimport {\n  Field,\n  type IField,\n  getMinHashLength,\n  invert,\n  mapHashToField,\n  mod,\n  validateField,\n} from './modular.js';\nimport * as ut from './utils.js';\nimport { type CHash, type Hex, type PrivKey, abool, ensureBytes, memoized } from './utils.js';\n\nexport type { AffinePoint };\ntype HmacFnSync = (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array;\ntype EndomorphismOpts = {\n  beta: bigint;\n  splitScalar: (k: bigint) => { k1neg: boolean; k1: bigint; k2neg: boolean; k2: bigint };\n};\nexport type BasicWCurve<T> = BasicCurve<T> & {\n  // Params: a, b\n  a: T;\n  b: T;\n\n  // Optional params\n  allowedPrivateKeyLengths?: readonly number[]; // for P521\n  wrapPrivateKey?: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n  endo?: EndomorphismOpts; // Endomorphism options for Koblitz curves\n  // When a cofactor != 1, there can be an effective methods to:\n  // 1. Determine whether a point is torsion-free\n  isTorsionFree?: (c: ProjConstructor<T>, point: ProjPointType<T>) => boolean;\n  // 2. Clear torsion component\n  clearCofactor?: (c: ProjConstructor<T>, point: ProjPointType<T>) => ProjPointType<T>;\n};\n\ntype Entropy = Hex | boolean;\nexport type SignOpts = { lowS?: boolean; extraEntropy?: Entropy; prehash?: boolean };\nexport type VerOpts = { lowS?: boolean; prehash?: boolean; format?: 'compact' | 'der' | undefined };\n\nfunction validateSigVerOpts(opts: SignOpts | VerOpts) {\n  if (opts.lowS !== undefined) abool('lowS', opts.lowS);\n  if (opts.prehash !== undefined) abool('prehash', opts.prehash);\n}\n\n// Instance for 3d XYZ points\nexport interface ProjPointType<T> extends Group<ProjPointType<T>> {\n  readonly px: T;\n  readonly py: T;\n  readonly pz: T;\n  get x(): T;\n  get y(): T;\n  multiply(scalar: bigint): ProjPointType<T>;\n  toAffine(iz?: T): AffinePoint<T>;\n  isTorsionFree(): boolean;\n  clearCofactor(): ProjPointType<T>;\n  assertValidity(): void;\n  hasEvenY(): boolean;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n\n  multiplyUnsafe(scalar: bigint): ProjPointType<T>;\n  multiplyAndAddUnsafe(Q: ProjPointType<T>, a: bigint, b: bigint): ProjPointType<T> | undefined;\n  _setWindowSize(windowSize: number): void;\n}\n// Static methods for 3d XYZ points\nexport interface ProjConstructor<T> extends GroupConstructor<ProjPointType<T>> {\n  new (x: T, y: T, z: T): ProjPointType<T>;\n  fromAffine(p: AffinePoint<T>): ProjPointType<T>;\n  fromHex(hex: Hex): ProjPointType<T>;\n  fromPrivateKey(privateKey: PrivKey): ProjPointType<T>;\n  normalizeZ(points: ProjPointType<T>[]): ProjPointType<T>[];\n  msm(points: ProjPointType<T>[], scalars: bigint[]): ProjPointType<T>;\n}\n\nexport type CurvePointsType<T> = BasicWCurve<T> & {\n  // Bytes\n  fromBytes?: (bytes: Uint8Array) => AffinePoint<T>;\n  toBytes?: (c: ProjConstructor<T>, point: ProjPointType<T>, isCompressed: boolean) => Uint8Array;\n};\n\nexport type CurvePointsTypeWithLength<T> = Readonly<\n  CurvePointsType<T> & { nByteLength: number; nBitLength: number }\n>;\n\nfunction validatePointOpts<T>(curve: CurvePointsType<T>): CurvePointsTypeWithLength<T> {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    opts,\n    {\n      a: 'field',\n      b: 'field',\n    },\n    {\n      allowedPrivateKeyLengths: 'array',\n      wrapPrivateKey: 'boolean',\n      isTorsionFree: 'function',\n      clearCofactor: 'function',\n      allowInfinityPoint: 'boolean',\n      fromBytes: 'function',\n      toBytes: 'function',\n    }\n  );\n  const { endo, Fp, a } = opts;\n  if (endo) {\n    if (!Fp.eql(a, Fp.ZERO)) {\n      throw new Error('invalid endomorphism, can only be defined for Koblitz curves that have a=0');\n    }\n    if (\n      typeof endo !== 'object' ||\n      typeof endo.beta !== 'bigint' ||\n      typeof endo.splitScalar !== 'function'\n    ) {\n      throw new Error('invalid endomorphism, expected beta: bigint and splitScalar: function');\n    }\n  }\n  return Object.freeze({ ...opts } as const);\n}\n\nexport type CurvePointsRes<T> = {\n  CURVE: ReturnType<typeof validatePointOpts<T>>;\n  ProjectivePoint: ProjConstructor<T>;\n  normPrivateKeyToScalar: (key: PrivKey) => bigint;\n  weierstrassEquation: (x: T) => T;\n  isWithinCurveOrder: (num: bigint) => boolean;\n};\n\nconst { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;\n\nexport class DERErr extends Error {\n  constructor(m = '') {\n    super(m);\n  }\n}\nexport type IDER = {\n  // asn.1 DER encoding utils\n  Err: typeof DERErr;\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag: number, data: string) => string;\n    // v - value, l - left bytes (unparsed)\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array };\n  };\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num: bigint): string;\n    decode(data: Uint8Array): bigint;\n  };\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint };\n  hexFromSig(sig: { r: bigint; s: bigint }): string;\n};\n/**\n * ASN.1 DER encoding utilities. ASN is very complex & fragile. Format:\n *\n *     [0x30 (SEQUENCE), bytelength, 0x02 (INTEGER), intLength, R, 0x02 (INTEGER), intLength, S]\n *\n * Docs: https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/, https://luca.ntop.org/Teaching/Appunti/asn1.html\n */\nexport const DER: IDER = {\n  // asn.1 DER encoding utils\n  Err: DERErr,\n  // Basic building block is TLV (Tag-Length-Value)\n  _tlv: {\n    encode: (tag: number, data: string): string => {\n      const { Err: E } = DER;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length & 1) throw new E('tlv.encode: unpadded data');\n      const dataLen = data.length / 2;\n      const len = ut.numberToHexUnpadded(dataLen);\n      if ((len.length / 2) & 0b1000_0000) throw new E('tlv.encode: long form length too big');\n      // length of length with long form flag\n      const lenLen = dataLen > 127 ? ut.numberToHexUnpadded((len.length / 2) | 0b1000_0000) : '';\n      const t = ut.numberToHexUnpadded(tag);\n      return t + lenLen + len + data;\n    },\n    // v - value, l - left bytes (unparsed)\n    decode(tag: number, data: Uint8Array): { v: Uint8Array; l: Uint8Array } {\n      const { Err: E } = DER;\n      let pos = 0;\n      if (tag < 0 || tag > 256) throw new E('tlv.encode: wrong tag');\n      if (data.length < 2 || data[pos++] !== tag) throw new E('tlv.decode: wrong tlv');\n      const first = data[pos++];\n      const isLong = !!(first & 0b1000_0000); // First bit of first length byte is flag for short/long form\n      let length = 0;\n      if (!isLong) length = first;\n      else {\n        // Long form: [longFlag(1bit), lengthLength(7bit), length (BE)]\n        const lenLen = first & 0b0111_1111;\n        if (!lenLen) throw new E('tlv.decode(long): indefinite length not supported');\n        if (lenLen > 4) throw new E('tlv.decode(long): byte length is too big'); // this will overflow u32 in js\n        const lengthBytes = data.subarray(pos, pos + lenLen);\n        if (lengthBytes.length !== lenLen) throw new E('tlv.decode: length bytes not complete');\n        if (lengthBytes[0] === 0) throw new E('tlv.decode(long): zero leftmost byte');\n        for (const b of lengthBytes) length = (length << 8) | b;\n        pos += lenLen;\n        if (length < 128) throw new E('tlv.decode(long): not minimal encoding');\n      }\n      const v = data.subarray(pos, pos + length);\n      if (v.length !== length) throw new E('tlv.decode: wrong value length');\n      return { v, l: data.subarray(pos + length) };\n    },\n  },\n  // https://crypto.stackexchange.com/a/57734 Leftmost bit of first byte is 'negative' flag,\n  // since we always use positive integers here. It must always be empty:\n  // - add zero byte if exists\n  // - if next byte doesn't have a flag, leading zero is not allowed (minimal encoding)\n  _int: {\n    encode(num: bigint): string {\n      const { Err: E } = DER;\n      if (num < _0n) throw new E('integer: negative integers are not allowed');\n      let hex = ut.numberToHexUnpadded(num);\n      // Pad with zero byte if negative flag is present\n      if (Number.parseInt(hex[0], 16) & 0b1000) hex = '00' + hex;\n      if (hex.length & 1) throw new E('unexpected DER parsing assertion: unpadded hex');\n      return hex;\n    },\n    decode(data: Uint8Array): bigint {\n      const { Err: E } = DER;\n      if (data[0] & 0b1000_0000) throw new E('invalid signature integer: negative');\n      if (data[0] === 0x00 && !(data[1] & 0b1000_0000))\n        throw new E('invalid signature integer: unnecessary leading zero');\n      return b2n(data);\n    },\n  },\n  toSig(hex: string | Uint8Array): { r: bigint; s: bigint } {\n    // parse DER signature\n    const { Err: E, _int: int, _tlv: tlv } = DER;\n    const data = typeof hex === 'string' ? h2b(hex) : hex;\n    ut.abytes(data);\n    const { v: seqBytes, l: seqLeftBytes } = tlv.decode(0x30, data);\n    if (seqLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    const { v: rBytes, l: rLeftBytes } = tlv.decode(0x02, seqBytes);\n    const { v: sBytes, l: sLeftBytes } = tlv.decode(0x02, rLeftBytes);\n    if (sLeftBytes.length) throw new E('invalid signature: left bytes after parsing');\n    return { r: int.decode(rBytes), s: int.decode(sBytes) };\n  },\n  hexFromSig(sig: { r: bigint; s: bigint }): string {\n    const { _tlv: tlv, _int: int } = DER;\n    const rs = tlv.encode(0x02, int.encode(sig.r));\n    const ss = tlv.encode(0x02, int.encode(sig.s));\n    const seq = rs + ss;\n    return tlv.encode(0x30, seq);\n  },\n};\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3), _4n = BigInt(4);\n\nexport function weierstrassPoints<T>(opts: CurvePointsType<T>): CurvePointsRes<T> {\n  const CURVE = validatePointOpts(opts);\n  const { Fp } = CURVE; // All curves has same field / group length as for now, but they can differ\n  const Fn = Field(CURVE.n, CURVE.nBitLength);\n\n  const toBytes =\n    CURVE.toBytes ||\n    ((_c: ProjConstructor<T>, point: ProjPointType<T>, _isCompressed: boolean) => {\n      const a = point.toAffine();\n      return ut.concatBytes(Uint8Array.from([0x04]), Fp.toBytes(a.x), Fp.toBytes(a.y));\n    });\n  const fromBytes =\n    CURVE.fromBytes ||\n    ((bytes: Uint8Array) => {\n      // const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // if (head !== 0x04) throw new Error('Only non-compressed encoding is supported');\n      const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n      const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n      return { x, y };\n    });\n\n  /**\n   * y = x + ax + b: Short weierstrass curve formula\n   * @returns y\n   */\n  function weierstrassEquation(x: T): T {\n    const { a, b } = CURVE;\n    const x2 = Fp.sqr(x); // x * x\n    const x3 = Fp.mul(x2, x); // x2 * x\n    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b); // x3 + a * x + b\n  }\n  // Validate whether the passed curve params are valid.\n  // We check if curve equation works for generator point.\n  // `assertValidity()` won't work: `isTorsionFree()` is not available at this point in bls12-381.\n  // ProjectivePoint class has not been initialized yet.\n  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))\n    throw new Error('bad generator point: equation left != right');\n\n  // Valid group elements reside in range 1..n-1\n  function isWithinCurveOrder(num: bigint): boolean {\n    return ut.inRange(num, _1n, CURVE.n);\n  }\n  // Validates if priv key is valid and converts it to bigint.\n  // Supports options allowedPrivateKeyLengths and wrapPrivateKey.\n  function normPrivateKeyToScalar(key: PrivKey): bigint {\n    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;\n    if (lengths && typeof key !== 'bigint') {\n      if (ut.isBytes(key)) key = ut.bytesToHex(key);\n      // Normalize to hex string, pad. E.g. P521 would norm 130-132 char hex to 132-char bytes\n      if (typeof key !== 'string' || !lengths.includes(key.length))\n        throw new Error('invalid private key');\n      key = key.padStart(nByteLength * 2, '0');\n    }\n    let num: bigint;\n    try {\n      num =\n        typeof key === 'bigint'\n          ? key\n          : ut.bytesToNumberBE(ensureBytes('private key', key, nByteLength));\n    } catch (error) {\n      throw new Error(\n        'invalid private key, expected hex or ' + nByteLength + ' bytes, got ' + typeof key\n      );\n    }\n    if (wrapPrivateKey) num = mod(num, N); // disabled by default, enabled for BLS\n    ut.aInRange('private key', num, _1n, N); // num in range [1..N-1]\n    return num;\n  }\n\n  function assertPrjPoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ProjectivePoint expected');\n  }\n\n  // Memoized toAffine / validity check. They are heavy. Points are immutable.\n\n  // Converts Projective point to affine (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  // (x, y, z)  (x=x/z, y=y/z)\n  const toAffineMemo = memoized((p: Point, iz?: T): AffinePoint<T> => {\n    const { px: x, py: y, pz: z } = p;\n    // Fast-path for normalized points\n    if (Fp.eql(z, Fp.ONE)) return { x, y };\n    const is0 = p.is0();\n    // If invZ was 0, we return zero point. However we still want to execute\n    // all operations, so we replace invZ with a random number, 1.\n    if (iz == null) iz = is0 ? Fp.ONE : Fp.inv(z);\n    const ax = Fp.mul(x, iz);\n    const ay = Fp.mul(y, iz);\n    const zz = Fp.mul(z, iz);\n    if (is0) return { x: Fp.ZERO, y: Fp.ZERO };\n    if (!Fp.eql(zz, Fp.ONE)) throw new Error('invZ was invalid');\n    return { x: ax, y: ay };\n  });\n  // NOTE: on exception this will crash 'cached' and no value will be set.\n  // Otherwise true will be return\n  const assertValidMemo = memoized((p: Point) => {\n    if (p.is0()) {\n      // (0, 1, 0) aka ZERO is invalid in most contexts.\n      // In BLS, ZERO can be serialized, so we allow it.\n      // (0, 0, 0) is invalid representation of ZERO.\n      if (CURVE.allowInfinityPoint && !Fp.is0(p.py)) return;\n      throw new Error('bad point: ZERO');\n    }\n    // Some 3rd-party test vectors require different wording between here & `fromCompressedHex`\n    const { x, y } = p.toAffine();\n    // Check if x, y are valid field elements\n    if (!Fp.isValid(x) || !Fp.isValid(y)) throw new Error('bad point: x or y not FE');\n    const left = Fp.sqr(y); // y\n    const right = weierstrassEquation(x); // x + ax + b\n    if (!Fp.eql(left, right)) throw new Error('bad point: equation left != right');\n    if (!p.isTorsionFree()) throw new Error('bad point: not in prime-order subgroup');\n    return true;\n  });\n\n  /**\n   * Projective Point works in 3d / projective (homogeneous) coordinates: (x, y, z)  (x=x/z, y=y/z)\n   * Default Point works in 2d / affine coordinates: (x, y)\n   * We're doing calculations in projective, because its operations don't require costly inversion.\n   */\n  class Point implements ProjPointType<T> {\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);\n    static readonly ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);\n\n    constructor(\n      readonly px: T,\n      readonly py: T,\n      readonly pz: T\n    ) {\n      if (px == null || !Fp.isValid(px)) throw new Error('x required');\n      if (py == null || !Fp.isValid(py)) throw new Error('y required');\n      if (pz == null || !Fp.isValid(pz)) throw new Error('z required');\n      Object.freeze(this);\n    }\n\n    // Does not validate if the point is on-curve.\n    // Use fromHex instead, or call assertValidity() later.\n    static fromAffine(p: AffinePoint<T>): Point {\n      const { x, y } = p || {};\n      if (!p || !Fp.isValid(x) || !Fp.isValid(y)) throw new Error('invalid affine point');\n      if (p instanceof Point) throw new Error('projective point not allowed');\n      const is0 = (i: T) => Fp.eql(i, Fp.ZERO);\n      // fromAffine(x:0, y:0) would produce (x:0, y:0, z:1), but we need (x:0, y:1, z:0)\n      if (is0(x) && is0(y)) return Point.ZERO;\n      return new Point(x, y, Fp.ONE);\n    }\n\n    get x(): T {\n      return this.toAffine().x;\n    }\n    get y(): T {\n      return this.toAffine().y;\n    }\n\n    /**\n     * Takes a bunch of Projective Points but executes only one\n     * inversion on all of them. Inversion is very slow operation,\n     * so this improves performance massively.\n     * Optimization: converts a list of projective points to a list of identical points with Z=1.\n     */\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = Fp.invertBatch(points.map((p) => p.pz));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n\n    /**\n     * Converts hash string or Uint8Array to Point.\n     * @param hex short/long ECDSA hex\n     */\n    static fromHex(hex: Hex): Point {\n      const P = Point.fromAffine(fromBytes(ensureBytes('pointHex', hex)));\n      P.assertValidity();\n      return P;\n    }\n\n    // Multiplies generator point by privateKey.\n    static fromPrivateKey(privateKey: PrivKey) {\n      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));\n    }\n\n    // Multiscalar Multiplication\n    static msm(points: Point[], scalars: bigint[]): Point {\n      return pippenger(Point, Fn, points, scalars);\n    }\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      wnaf.setWindowSize(this, windowSize);\n    }\n\n    // A point on curve is valid if it conforms to equation.\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    hasEvenY(): boolean {\n      const { y } = this.toAffine();\n      if (Fp.isOdd) return !Fp.isOdd(y);\n      throw new Error(\"Field doesn't support isOdd\");\n    }\n\n    /**\n     * Compare one point to another.\n     */\n    equals(other: Point): boolean {\n      assertPrjPoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));\n      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));\n      return U1 && U2;\n    }\n\n    /**\n     * Flips point to one corresponding to (x, -y) in Affine coordinates.\n     */\n    negate(): Point {\n      return new Point(this.px, Fp.neg(this.py), this.pz);\n    }\n\n    // Renes-Costello-Batina exception-free doubling formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 3\n    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.\n    double() {\n      const { a, b } = CURVE;\n      const b3 = Fp.mul(b, _3n);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      let t0 = Fp.mul(X1, X1); // step 1\n      let t1 = Fp.mul(Y1, Y1);\n      let t2 = Fp.mul(Z1, Z1);\n      let t3 = Fp.mul(X1, Y1);\n      t3 = Fp.add(t3, t3); // step 5\n      Z3 = Fp.mul(X1, Z1);\n      Z3 = Fp.add(Z3, Z3);\n      X3 = Fp.mul(a, Z3);\n      Y3 = Fp.mul(b3, t2);\n      Y3 = Fp.add(X3, Y3); // step 10\n      X3 = Fp.sub(t1, Y3);\n      Y3 = Fp.add(t1, Y3);\n      Y3 = Fp.mul(X3, Y3);\n      X3 = Fp.mul(t3, X3);\n      Z3 = Fp.mul(b3, Z3); // step 15\n      t2 = Fp.mul(a, t2);\n      t3 = Fp.sub(t0, t2);\n      t3 = Fp.mul(a, t3);\n      t3 = Fp.add(t3, Z3);\n      Z3 = Fp.add(t0, t0); // step 20\n      t0 = Fp.add(Z3, t0);\n      t0 = Fp.add(t0, t2);\n      t0 = Fp.mul(t0, t3);\n      Y3 = Fp.add(Y3, t0);\n      t2 = Fp.mul(Y1, Z1); // step 25\n      t2 = Fp.add(t2, t2);\n      t0 = Fp.mul(t2, t3);\n      X3 = Fp.sub(X3, t0);\n      Z3 = Fp.mul(t2, t1);\n      Z3 = Fp.add(Z3, Z3); // step 30\n      Z3 = Fp.add(Z3, Z3);\n      return new Point(X3, Y3, Z3);\n    }\n\n    // Renes-Costello-Batina exception-free addition formula.\n    // There is 30% faster Jacobian formula, but it is not complete.\n    // https://eprint.iacr.org/2015/1060, algorithm 1\n    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.\n    add(other: Point): Point {\n      assertPrjPoint(other);\n      const { px: X1, py: Y1, pz: Z1 } = this;\n      const { px: X2, py: Y2, pz: Z2 } = other;\n      let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO; // prettier-ignore\n      const a = CURVE.a;\n      const b3 = Fp.mul(CURVE.b, _3n);\n      let t0 = Fp.mul(X1, X2); // step 1\n      let t1 = Fp.mul(Y1, Y2);\n      let t2 = Fp.mul(Z1, Z2);\n      let t3 = Fp.add(X1, Y1);\n      let t4 = Fp.add(X2, Y2); // step 5\n      t3 = Fp.mul(t3, t4);\n      t4 = Fp.add(t0, t1);\n      t3 = Fp.sub(t3, t4);\n      t4 = Fp.add(X1, Z1);\n      let t5 = Fp.add(X2, Z2); // step 10\n      t4 = Fp.mul(t4, t5);\n      t5 = Fp.add(t0, t2);\n      t4 = Fp.sub(t4, t5);\n      t5 = Fp.add(Y1, Z1);\n      X3 = Fp.add(Y2, Z2); // step 15\n      t5 = Fp.mul(t5, X3);\n      X3 = Fp.add(t1, t2);\n      t5 = Fp.sub(t5, X3);\n      Z3 = Fp.mul(a, t4);\n      X3 = Fp.mul(b3, t2); // step 20\n      Z3 = Fp.add(X3, Z3);\n      X3 = Fp.sub(t1, Z3);\n      Z3 = Fp.add(t1, Z3);\n      Y3 = Fp.mul(X3, Z3);\n      t1 = Fp.add(t0, t0); // step 25\n      t1 = Fp.add(t1, t0);\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.mul(b3, t4);\n      t1 = Fp.add(t1, t2);\n      t2 = Fp.sub(t0, t2); // step 30\n      t2 = Fp.mul(a, t2);\n      t4 = Fp.add(t4, t2);\n      t0 = Fp.mul(t1, t4);\n      Y3 = Fp.add(Y3, t0);\n      t0 = Fp.mul(t5, t4); // step 35\n      X3 = Fp.mul(t3, X3);\n      X3 = Fp.sub(X3, t0);\n      t0 = Fp.mul(t3, t1);\n      Z3 = Fp.mul(t5, Z3);\n      Z3 = Fp.add(Z3, t0); // step 40\n      return new Point(X3, Y3, Z3);\n    }\n\n    subtract(other: Point) {\n      return this.add(other.negate());\n    }\n\n    is0() {\n      return this.equals(Point.ZERO);\n    }\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, n, Point.normalizeZ);\n    }\n\n    /**\n     * Non-constant-time multiplication. Uses double-and-add algorithm.\n     * It's faster, but should only be used when you don't care about\n     * an exposed private key e.g. sig verification, which works over *public* keys.\n     */\n    multiplyUnsafe(sc: bigint): Point {\n      const { endo, n: N } = CURVE;\n      ut.aInRange('scalar', sc, _0n, N);\n      const I = Point.ZERO;\n      if (sc === _0n) return I;\n      if (this.is0() || sc === _1n) return this;\n\n      // Case a: no endomorphism. Case b: has precomputes.\n      if (!endo || wnaf.hasPrecomputes(this))\n        return wnaf.wNAFCachedUnsafe(this, sc, Point.normalizeZ);\n\n      // Case c: endomorphism\n      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);\n      let k1p = I;\n      let k2p = I;\n      let d: Point = this;\n      while (k1 > _0n || k2 > _0n) {\n        if (k1 & _1n) k1p = k1p.add(d);\n        if (k2 & _1n) k2p = k2p.add(d);\n        d = d.double();\n        k1 >>= _1n;\n        k2 >>= _1n;\n      }\n      if (k1neg) k1p = k1p.negate();\n      if (k2neg) k2p = k2p.negate();\n      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n      return k1p.add(k2p);\n    }\n\n    /**\n     * Constant time multiplication.\n     * Uses wNAF method. Windowed method may be 10% faster,\n     * but takes 2x longer to generate and consumes 2x memory.\n     * Uses precomputes when available.\n     * Uses endomorphism for Koblitz curves.\n     * @param scalar by which the point would be multiplied\n     * @returns New point\n     */\n    multiply(scalar: bigint): Point {\n      const { endo, n: N } = CURVE;\n      ut.aInRange('scalar', scalar, _1n, N);\n      let point: Point, fake: Point; // Fake point is used to const-time mult\n      if (endo) {\n        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);\n        let { p: k1p, f: f1p } = this.wNAF(k1);\n        let { p: k2p, f: f2p } = this.wNAF(k2);\n        k1p = wnaf.constTimeNegate(k1neg, k1p);\n        k2p = wnaf.constTimeNegate(k2neg, k2p);\n        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);\n        point = k1p.add(k2p);\n        fake = f1p.add(f2p);\n      } else {\n        const { p, f } = this.wNAF(scalar);\n        point = p;\n        fake = f;\n      }\n      // Normalize `z` for both points, but return only real one\n      return Point.normalizeZ([point, fake])[0];\n    }\n\n    /**\n     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.\n     * Not using Strauss-Shamir trick: precomputation tables are faster.\n     * The trick could be useful if both P and Q are not G (not in our case).\n     * @returns non-zero affine point\n     */\n    multiplyAndAddUnsafe(Q: Point, a: bigint, b: bigint): Point | undefined {\n      const G = Point.BASE; // No Strauss-Shamir trick: we have 10% faster G precomputes\n      const mul = (\n        P: Point,\n        a: bigint // Select faster multiply() method\n      ) => (a === _0n || a === _1n || !P.equals(G) ? P.multiplyUnsafe(a) : P.multiply(a));\n      const sum = mul(this, a).add(mul(Q, b));\n      return sum.is0() ? undefined : sum;\n    }\n\n    // Converts Projective point to affine (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    // (x, y, z)  (x=x/z, y=y/z)\n    toAffine(iz?: T): AffinePoint<T> {\n      return toAffineMemo(this, iz);\n    }\n    isTorsionFree(): boolean {\n      const { h: cofactor, isTorsionFree } = CURVE;\n      if (cofactor === _1n) return true; // No subgroups, always torsion-free\n      if (isTorsionFree) return isTorsionFree(Point, this);\n      throw new Error('isTorsionFree() has not been declared for the elliptic curve');\n    }\n    clearCofactor(): Point {\n      const { h: cofactor, clearCofactor } = CURVE;\n      if (cofactor === _1n) return this; // Fast-path\n      if (clearCofactor) return clearCofactor(Point, this) as Point;\n      return this.multiplyUnsafe(CURVE.h);\n    }\n\n    toRawBytes(isCompressed = true): Uint8Array {\n      abool('isCompressed', isCompressed);\n      this.assertValidity();\n      return toBytes(Point, this, isCompressed);\n    }\n\n    toHex(isCompressed = true): string {\n      abool('isCompressed', isCompressed);\n      return ut.bytesToHex(this.toRawBytes(isCompressed));\n    }\n  }\n  const _bits = CURVE.nBitLength;\n  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);\n  // Validate if generator point is on curve\n  return {\n    CURVE,\n    ProjectivePoint: Point as ProjConstructor<T>,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  };\n}\n\n// Instance\nexport interface SignatureType {\n  readonly r: bigint;\n  readonly s: bigint;\n  readonly recovery?: number;\n  assertValidity(): void;\n  addRecoveryBit(recovery: number): RecoveredSignatureType;\n  hasHighS(): boolean;\n  normalizeS(): SignatureType;\n  recoverPublicKey(msgHash: Hex): ProjPointType<bigint>;\n  toCompactRawBytes(): Uint8Array;\n  toCompactHex(): string;\n  // DER-encoded\n  toDERRawBytes(isCompressed?: boolean): Uint8Array;\n  toDERHex(isCompressed?: boolean): string;\n}\nexport type RecoveredSignatureType = SignatureType & {\n  readonly recovery: number;\n};\n// Static methods\nexport type SignatureConstructor = {\n  new (r: bigint, s: bigint): SignatureType;\n  fromCompact(hex: Hex): SignatureType;\n  fromDER(hex: Hex): SignatureType;\n};\ntype SignatureLike = { r: bigint; s: bigint };\n\nexport type PubKey = Hex | ProjPointType<bigint>;\n\nexport type CurveType = BasicWCurve<bigint> & {\n  hash: CHash; // CHash not FHash because we need outputLen for DRBG\n  hmac: HmacFnSync;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n  lowS?: boolean;\n  bits2int?: (bytes: Uint8Array) => bigint;\n  bits2int_modN?: (bytes: Uint8Array) => bigint;\n};\n\nfunction validateOpts(\n  curve: CurveType\n): Readonly<CurveType & { nByteLength: number; nBitLength: number }> {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    opts,\n    {\n      hash: 'hash',\n      hmac: 'function',\n      randomBytes: 'function',\n    },\n    {\n      bits2int: 'function',\n      bits2int_modN: 'function',\n      lowS: 'boolean',\n    }\n  );\n  return Object.freeze({ lowS: true, ...opts } as const);\n}\n\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: PrivKey, isCompressed?: boolean) => Uint8Array;\n  getSharedSecret: (privateA: PrivKey, publicB: Hex, isCompressed?: boolean) => Uint8Array;\n  sign: (msgHash: Hex, privKey: PrivKey, opts?: SignOpts) => RecoveredSignatureType;\n  verify: (signature: Hex | SignatureLike, msgHash: Hex, publicKey: Hex, opts?: VerOpts) => boolean;\n  ProjectivePoint: ProjConstructor<bigint>;\n  Signature: SignatureConstructor;\n  utils: {\n    normPrivateKeyToScalar: (key: PrivKey) => bigint;\n    isValidPrivateKey(privateKey: PrivKey): boolean;\n    randomPrivateKey: () => Uint8Array;\n    precompute: (windowSize?: number, point?: ProjPointType<bigint>) => ProjPointType<bigint>;\n  };\n};\n\n/**\n * Creates short weierstrass curve and ECDSA signature methods for it.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, b, p, n, Gx, Gy\n * const curve = weierstrass({ a, b, Fp: Field(p), n, Gx, Gy, h: 1n })\n */\nexport function weierstrass(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const { Fp, n: CURVE_ORDER } = CURVE;\n  const compressedLen = Fp.BYTES + 1; // e.g. 33 for 32\n  const uncompressedLen = 2 * Fp.BYTES + 1; // e.g. 65 for 32\n\n  function modN(a: bigint) {\n    return mod(a, CURVE_ORDER);\n  }\n  function invN(a: bigint) {\n    return invert(a, CURVE_ORDER);\n  }\n\n  const {\n    ProjectivePoint: Point,\n    normPrivateKeyToScalar,\n    weierstrassEquation,\n    isWithinCurveOrder,\n  } = weierstrassPoints({\n    ...CURVE,\n    toBytes(_c, point, isCompressed: boolean): Uint8Array {\n      const a = point.toAffine();\n      const x = Fp.toBytes(a.x);\n      const cat = ut.concatBytes;\n      abool('isCompressed', isCompressed);\n      if (isCompressed) {\n        return cat(Uint8Array.from([point.hasEvenY() ? 0x02 : 0x03]), x);\n      } else {\n        return cat(Uint8Array.from([0x04]), x, Fp.toBytes(a.y));\n      }\n    },\n    fromBytes(bytes: Uint8Array) {\n      const len = bytes.length;\n      const head = bytes[0];\n      const tail = bytes.subarray(1);\n      // this.assertValidity() is done inside of fromHex\n      if (len === compressedLen && (head === 0x02 || head === 0x03)) {\n        const x = ut.bytesToNumberBE(tail);\n        if (!ut.inRange(x, _1n, Fp.ORDER)) throw new Error('Point is not on curve');\n        const y2 = weierstrassEquation(x); // y = x + ax + b\n        let y: bigint;\n        try {\n          y = Fp.sqrt(y2); // y = y ^ (p+1)/4\n        } catch (sqrtError) {\n          const suffix = sqrtError instanceof Error ? ': ' + sqrtError.message : '';\n          throw new Error('Point is not on curve' + suffix);\n        }\n        const isYOdd = (y & _1n) === _1n;\n        // ECDSA\n        const isHeadOdd = (head & 1) === 1;\n        if (isHeadOdd !== isYOdd) y = Fp.neg(y);\n        return { x, y };\n      } else if (len === uncompressedLen && head === 0x04) {\n        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));\n        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));\n        return { x, y };\n      } else {\n        const cl = compressedLen;\n        const ul = uncompressedLen;\n        throw new Error(\n          'invalid Point, expected length of ' + cl + ', or uncompressed ' + ul + ', got ' + len\n        );\n      }\n    },\n  });\n  const numToNByteStr = (num: bigint): string =>\n    ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));\n\n  function isBiggerThanHalfOrder(number: bigint) {\n    const HALF = CURVE_ORDER >> _1n;\n    return number > HALF;\n  }\n\n  function normalizeS(s: bigint) {\n    return isBiggerThanHalfOrder(s) ? modN(-s) : s;\n  }\n  // slice bytes num\n  const slcNum = (b: Uint8Array, from: number, to: number) => ut.bytesToNumberBE(b.slice(from, to));\n\n  /**\n   * ECDSA signature with its (r, s) properties. Supports DER & compact representations.\n   */\n  class Signature implements SignatureType {\n    constructor(\n      readonly r: bigint,\n      readonly s: bigint,\n      readonly recovery?: number\n    ) {\n      this.assertValidity();\n    }\n\n    // pair (bytes of r, bytes of s)\n    static fromCompact(hex: Hex) {\n      const l = CURVE.nByteLength;\n      hex = ensureBytes('compactSignature', hex, l * 2);\n      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));\n    }\n\n    // DER encoded ECDSA signature\n    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script\n    static fromDER(hex: Hex) {\n      const { r, s } = DER.toSig(ensureBytes('DER', hex));\n      return new Signature(r, s);\n    }\n\n    assertValidity(): void {\n      ut.aInRange('r', this.r, _1n, CURVE_ORDER); // r in [1..N]\n      ut.aInRange('s', this.s, _1n, CURVE_ORDER); // s in [1..N]\n    }\n\n    addRecoveryBit(recovery: number): RecoveredSignature {\n      return new Signature(this.r, this.s, recovery) as RecoveredSignature;\n    }\n\n    recoverPublicKey(msgHash: Hex): typeof Point.BASE {\n      const { r, s, recovery: rec } = this;\n      const h = bits2int_modN(ensureBytes('msgHash', msgHash)); // Truncate hash\n      if (rec == null || ![0, 1, 2, 3].includes(rec)) throw new Error('recovery id invalid');\n      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;\n      if (radj >= Fp.ORDER) throw new Error('recovery id 2 or 3 invalid');\n      const prefix = (rec & 1) === 0 ? '02' : '03';\n      const R = Point.fromHex(prefix + numToNByteStr(radj));\n      const ir = invN(radj); // r^-1\n      const u1 = modN(-h * ir); // -hr^-1\n      const u2 = modN(s * ir); // sr^-1\n      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2); // (sr^-1)R-(hr^-1)G = -(hr^-1)G + (sr^-1)\n      if (!Q) throw new Error('point at infinify'); // unsafe is fine: no priv data leaked\n      Q.assertValidity();\n      return Q;\n    }\n\n    // Signatures should be low-s, to prevent malleability.\n    hasHighS(): boolean {\n      return isBiggerThanHalfOrder(this.s);\n    }\n\n    normalizeS() {\n      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;\n    }\n\n    // DER-encoded\n    toDERRawBytes() {\n      return ut.hexToBytes(this.toDERHex());\n    }\n    toDERHex() {\n      return DER.hexFromSig({ r: this.r, s: this.s });\n    }\n\n    // padded bytes of r, then padded bytes of s\n    toCompactRawBytes() {\n      return ut.hexToBytes(this.toCompactHex());\n    }\n    toCompactHex() {\n      return numToNByteStr(this.r) + numToNByteStr(this.s);\n    }\n  }\n  type RecoveredSignature = Signature & { recovery: number };\n\n  const utils = {\n    isValidPrivateKey(privateKey: PrivKey) {\n      try {\n        normPrivateKeyToScalar(privateKey);\n        return true;\n      } catch (error) {\n        return false;\n      }\n    },\n    normPrivateKeyToScalar: normPrivateKeyToScalar,\n\n    /**\n     * Produces cryptographically secure private key from random of size\n     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.\n     */\n    randomPrivateKey: (): Uint8Array => {\n      const length = getMinHashLength(CURVE.n);\n      return mapHashToField(CURVE.randomBytes(length), CURVE.n);\n    },\n\n    /**\n     * Creates precompute table for an arbitrary EC point. Makes point \"cached\".\n     * Allows to massively speed-up `point.multiply(scalar)`.\n     * @returns cached point\n     * @example\n     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));\n     * fast.multiply(privKey); // much faster ECDH now\n     */\n    precompute(windowSize = 8, point = Point.BASE): typeof Point.BASE {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3)); // 3 is arbitrary, just need any number here\n      return point;\n    },\n  };\n\n  /**\n   * Computes public key for a private key. Checks for validity of the private key.\n   * @param privateKey private key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns Public key, full when isCompressed=false; short when isCompressed=true\n   */\n  function getPublicKey(privateKey: PrivKey, isCompressed = true): Uint8Array {\n    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);\n  }\n\n  /**\n   * Quick and dirty check for item being public key. Does not validate hex, or being on-curve.\n   */\n  function isProbPub(item: PrivKey | PubKey): boolean {\n    const arr = ut.isBytes(item);\n    const str = typeof item === 'string';\n    const len = (arr || str) && (item as Hex).length;\n    if (arr) return len === compressedLen || len === uncompressedLen;\n    if (str) return len === 2 * compressedLen || len === 2 * uncompressedLen;\n    if (item instanceof Point) return true;\n    return false;\n  }\n\n  /**\n   * ECDH (Elliptic Curve Diffie Hellman).\n   * Computes shared public key from private key and public key.\n   * Checks: 1) private key validity 2) shared key is on-curve.\n   * Does NOT hash the result.\n   * @param privateA private key\n   * @param publicB different public key\n   * @param isCompressed whether to return compact (default), or full key\n   * @returns shared public key\n   */\n  function getSharedSecret(privateA: PrivKey, publicB: Hex, isCompressed = true): Uint8Array {\n    if (isProbPub(privateA)) throw new Error('first arg must be private key');\n    if (!isProbPub(publicB)) throw new Error('second arg must be public key');\n    const b = Point.fromHex(publicB); // check for being on-curve\n    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);\n  }\n\n  // RFC6979: ensure ECDSA msg is X bytes and < N. RFC suggests optional truncating via bits2octets.\n  // FIPS 186-4 4.6 suggests the leftmost min(nBitLen, outLen) bits, which matches bits2int.\n  // bits2int can produce res>N, we can do mod(res, N) since the bitLen is the same.\n  // int2octets can't be used; pads small msgs with 0: unacceptatble for trunc as per RFC vectors\n  const bits2int =\n    CURVE.bits2int ||\n    function (bytes: Uint8Array): bigint {\n      // Our custom check \"just in case\"\n      if (bytes.length > 8192) throw new Error('input is too large');\n      // For curves with nBitLength % 8 !== 0: bits2octets(bits2octets(m)) !== bits2octets(m)\n      // for some cases, since bytes.length * 8 is not actual bitLength.\n      const num = ut.bytesToNumberBE(bytes); // check for == u8 done here\n      const delta = bytes.length * 8 - CURVE.nBitLength; // truncate to nBitLength leftmost bits\n      return delta > 0 ? num >> BigInt(delta) : num;\n    };\n  const bits2int_modN =\n    CURVE.bits2int_modN ||\n    function (bytes: Uint8Array): bigint {\n      return modN(bits2int(bytes)); // can't use bytesToNumberBE here\n    };\n  // NOTE: pads output with zero as per spec\n  const ORDER_MASK = ut.bitMask(CURVE.nBitLength);\n  /**\n   * Converts to bytes. Checks if num in `[0..ORDER_MASK-1]` e.g.: `[0..2^256-1]`.\n   */\n  function int2octets(num: bigint): Uint8Array {\n    ut.aInRange('num < 2^' + CURVE.nBitLength, num, _0n, ORDER_MASK);\n    // works with order, can have different size than numToField!\n    return ut.numberToBytesBE(num, CURVE.nByteLength);\n  }\n\n  // Steps A, D of RFC6979 3.2\n  // Creates RFC6979 seed; converts msg/privKey to numbers.\n  // Used only in sign, not in verify.\n  // NOTE: we cannot assume here that msgHash has same amount of bytes as curve order,\n  // this will be invalid at least for P521. Also it can be bigger for P224 + SHA256\n  function prepSig(msgHash: Hex, privateKey: PrivKey, opts = defaultSigOpts) {\n    if (['recovered', 'canonical'].some((k) => k in opts))\n      throw new Error('sign() legacy options not supported');\n    const { hash, randomBytes } = CURVE;\n    let { lowS, prehash, extraEntropy: ent } = opts; // generates low-s sigs by default\n    if (lowS == null) lowS = true; // RFC6979 3.2: we skip step A, because we already provide hash\n    msgHash = ensureBytes('msgHash', msgHash);\n    validateSigVerOpts(opts);\n    if (prehash) msgHash = ensureBytes('prehashed msgHash', hash(msgHash));\n\n    // We can't later call bits2octets, since nested bits2int is broken for curves\n    // with nBitLength % 8 !== 0. Because of that, we unwrap it here as int2octets call.\n    // const bits2octets = (bits) => int2octets(bits2int_modN(bits))\n    const h1int = bits2int_modN(msgHash);\n    const d = normPrivateKeyToScalar(privateKey); // validate private key, convert to bigint\n    const seedArgs = [int2octets(d), int2octets(h1int)];\n    // extraEntropy. RFC6979 3.6: additional k' (optional).\n    if (ent != null && ent !== false) {\n      // K = HMAC_K(V || 0x00 || int2octets(x) || bits2octets(h1) || k')\n      const e = ent === true ? randomBytes(Fp.BYTES) : ent; // generate random bytes OR pass as-is\n      seedArgs.push(ensureBytes('extraEntropy', e)); // check for being bytes\n    }\n    const seed = ut.concatBytes(...seedArgs); // Step D of RFC6979 3.2\n    const m = h1int; // NOTE: no need to call bits2int second time here, it is inside truncateHash!\n    // Converts signature params into point w r/s, checks result for validity.\n    function k2sig(kBytes: Uint8Array): RecoveredSignature | undefined {\n      // RFC 6979 Section 3.2, step 3: k = bits2int(T)\n      const k = bits2int(kBytes); // Cannot use fields methods, since it is group element\n      if (!isWithinCurveOrder(k)) return; // Important: all mod() calls here must be done over N\n      const ik = invN(k); // k^-1 mod n\n      const q = Point.BASE.multiply(k).toAffine(); // q = Gk\n      const r = modN(q.x); // r = q.x mod n\n      if (r === _0n) return;\n      // Can use scalar blinding b^-1(bm + bdr) where b  [1,q1] according to\n      // https://tches.iacr.org/index.php/TCHES/article/view/7337/6509. We've decided against it:\n      // a) dependency on CSPRNG b) 15% slowdown c) doesn't really help since bigints are not CT\n      const s = modN(ik * modN(m + r * d)); // Not using blinding here\n      if (s === _0n) return;\n      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n); // recovery bit (2 or 3, when q.x > n)\n      let normS = s;\n      if (lowS && isBiggerThanHalfOrder(s)) {\n        normS = normalizeS(s); // if lowS was passed, ensure s is always\n        recovery ^= 1; // // in the bottom half of N\n      }\n      return new Signature(r, normS, recovery) as RecoveredSignature; // use normS, not s\n    }\n    return { seed, k2sig };\n  }\n  const defaultSigOpts: SignOpts = { lowS: CURVE.lowS, prehash: false };\n  const defaultVerOpts: VerOpts = { lowS: CURVE.lowS, prehash: false };\n\n  /**\n   * Signs message hash with a private key.\n   * ```\n   * sign(m, d, k) where\n   *   (x, y) = G  k\n   *   r = x mod n\n   *   s = (m + dr)/k mod n\n   * ```\n   * @param msgHash NOT message. msg needs to be hashed to `msgHash`, or use `prehash`.\n   * @param privKey private key\n   * @param opts lowS for non-malleable sigs. extraEntropy for mixing randomness into k. prehash will hash first arg.\n   * @returns signature with recovery param\n   */\n  function sign(msgHash: Hex, privKey: PrivKey, opts = defaultSigOpts): RecoveredSignature {\n    const { seed, k2sig } = prepSig(msgHash, privKey, opts); // Steps A, D of RFC6979 3.2.\n    const C = CURVE;\n    const drbg = ut.createHmacDrbg<RecoveredSignature>(C.hash.outputLen, C.nByteLength, C.hmac);\n    return drbg(seed, k2sig); // Steps B, C, D, E, F, G\n  }\n\n  // Enable precomputes. Slows down first publicKey computation by 20ms.\n  Point.BASE._setWindowSize(8);\n  // utils.precompute(8, ProjectivePoint.BASE)\n\n  /**\n   * Verifies a signature against message hash and public key.\n   * Rejects lowS signatures by default: to override,\n   * specify option `{lowS: false}`. Implements section 4.1.4 from https://www.secg.org/sec1-v2.pdf:\n   *\n   * ```\n   * verify(r, s, h, P) where\n   *   U1 = hs^-1 mod n\n   *   U2 = rs^-1 mod n\n   *   R = U1G - U2P\n   *   mod(R.x, n) == r\n   * ```\n   */\n  function verify(\n    signature: Hex | SignatureLike,\n    msgHash: Hex,\n    publicKey: Hex,\n    opts = defaultVerOpts\n  ): boolean {\n    const sg = signature;\n    msgHash = ensureBytes('msgHash', msgHash);\n    publicKey = ensureBytes('publicKey', publicKey);\n    const { lowS, prehash, format } = opts;\n\n    // Verify opts, deduce signature format\n    validateSigVerOpts(opts);\n    if ('strict' in opts) throw new Error('options.strict was renamed to lowS');\n    if (format !== undefined && format !== 'compact' && format !== 'der')\n      throw new Error('format must be compact or der');\n    const isHex = typeof sg === 'string' || ut.isBytes(sg);\n    const isObj =\n      !isHex &&\n      !format &&\n      typeof sg === 'object' &&\n      sg !== null &&\n      typeof sg.r === 'bigint' &&\n      typeof sg.s === 'bigint';\n    if (!isHex && !isObj)\n      throw new Error('invalid signature, expected Uint8Array, hex string or Signature instance');\n\n    let _sig: Signature | undefined = undefined;\n    let P: ProjPointType<bigint>;\n    try {\n      if (isObj) _sig = new Signature(sg.r, sg.s);\n      if (isHex) {\n        // Signature can be represented in 2 ways: compact (2*nByteLength) & DER (variable-length).\n        // Since DER can also be 2*nByteLength bytes, we check for it first.\n        try {\n          if (format !== 'compact') _sig = Signature.fromDER(sg);\n        } catch (derError) {\n          if (!(derError instanceof DER.Err)) throw derError;\n        }\n        if (!_sig && format !== 'der') _sig = Signature.fromCompact(sg);\n      }\n      P = Point.fromHex(publicKey);\n    } catch (error) {\n      return false;\n    }\n    if (!_sig) return false;\n    if (lowS && _sig.hasHighS()) return false;\n    if (prehash) msgHash = CURVE.hash(msgHash);\n    const { r, s } = _sig;\n    const h = bits2int_modN(msgHash); // Cannot use fields methods, since it is group element\n    const is = invN(s); // s^-1\n    const u1 = modN(h * is); // u1 = hs^-1 mod n\n    const u2 = modN(r * is); // u2 = rs^-1 mod n\n    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine(); // R = u1G + u2P\n    if (!R) return false;\n    const v = modN(R.x);\n    return v === r;\n  }\n  return {\n    CURVE,\n    getPublicKey,\n    getSharedSecret,\n    sign,\n    verify,\n    ProjectivePoint: Point,\n    Signature,\n    utils,\n  };\n}\n\n/**\n * Implementation of the Shallue and van de Woestijne method for any weierstrass curve.\n * TODO: check if there is a way to merge this with uvRatio in Edwards; move to modular.\n * b = True and y = sqrt(u / v) if (u / v) is square in F, and\n * b = False and y = sqrt(Z * (u / v)) otherwise.\n * @param Fp\n * @param Z\n * @returns\n */\nexport function SWUFpSqrtRatio<T>(\n  Fp: IField<T>,\n  Z: T\n): (u: T, v: T) => { isValid: boolean; value: T } {\n  // Generic implementation\n  const q = Fp.ORDER;\n  let l = _0n;\n  for (let o = q - _1n; o % _2n === _0n; o /= _2n) l += _1n;\n  const c1 = l; // 1. c1, the largest integer such that 2^c1 divides q - 1.\n  // We need 2n ** c1 and 2n ** (c1-1). We can't use **; but we can use <<.\n  // 2n ** c1 == 2n << (c1-1)\n  const _2n_pow_c1_1 = _2n << (c1 - _1n - _1n);\n  const _2n_pow_c1 = _2n_pow_c1_1 * _2n;\n  const c2 = (q - _1n) / _2n_pow_c1; // 2. c2 = (q - 1) / (2^c1)  # Integer arithmetic\n  const c3 = (c2 - _1n) / _2n; // 3. c3 = (c2 - 1) / 2            # Integer arithmetic\n  const c4 = _2n_pow_c1 - _1n; // 4. c4 = 2^c1 - 1                # Integer arithmetic\n  const c5 = _2n_pow_c1_1; // 5. c5 = 2^(c1 - 1)                  # Integer arithmetic\n  const c6 = Fp.pow(Z, c2); // 6. c6 = Z^c2\n  const c7 = Fp.pow(Z, (c2 + _1n) / _2n); // 7. c7 = Z^((c2 + 1) / 2)\n  let sqrtRatio = (u: T, v: T): { isValid: boolean; value: T } => {\n    let tv1 = c6; // 1. tv1 = c6\n    let tv2 = Fp.pow(v, c4); // 2. tv2 = v^c4\n    let tv3 = Fp.sqr(tv2); // 3. tv3 = tv2^2\n    tv3 = Fp.mul(tv3, v); // 4. tv3 = tv3 * v\n    let tv5 = Fp.mul(u, tv3); // 5. tv5 = u * tv3\n    tv5 = Fp.pow(tv5, c3); // 6. tv5 = tv5^c3\n    tv5 = Fp.mul(tv5, tv2); // 7. tv5 = tv5 * tv2\n    tv2 = Fp.mul(tv5, v); // 8. tv2 = tv5 * v\n    tv3 = Fp.mul(tv5, u); // 9. tv3 = tv5 * u\n    let tv4 = Fp.mul(tv3, tv2); // 10. tv4 = tv3 * tv2\n    tv5 = Fp.pow(tv4, c5); // 11. tv5 = tv4^c5\n    let isQR = Fp.eql(tv5, Fp.ONE); // 12. isQR = tv5 == 1\n    tv2 = Fp.mul(tv3, c7); // 13. tv2 = tv3 * c7\n    tv5 = Fp.mul(tv4, tv1); // 14. tv5 = tv4 * tv1\n    tv3 = Fp.cmov(tv2, tv3, isQR); // 15. tv3 = CMOV(tv2, tv3, isQR)\n    tv4 = Fp.cmov(tv5, tv4, isQR); // 16. tv4 = CMOV(tv5, tv4, isQR)\n    // 17. for i in (c1, c1 - 1, ..., 2):\n    for (let i = c1; i > _1n; i--) {\n      let tv5 = i - _2n; // 18.    tv5 = i - 2\n      tv5 = _2n << (tv5 - _1n); // 19.    tv5 = 2^tv5\n      let tvv5 = Fp.pow(tv4, tv5); // 20.    tv5 = tv4^tv5\n      const e1 = Fp.eql(tvv5, Fp.ONE); // 21.    e1 = tv5 == 1\n      tv2 = Fp.mul(tv3, tv1); // 22.    tv2 = tv3 * tv1\n      tv1 = Fp.mul(tv1, tv1); // 23.    tv1 = tv1 * tv1\n      tvv5 = Fp.mul(tv4, tv1); // 24.    tv5 = tv4 * tv1\n      tv3 = Fp.cmov(tv2, tv3, e1); // 25.    tv3 = CMOV(tv2, tv3, e1)\n      tv4 = Fp.cmov(tvv5, tv4, e1); // 26.    tv4 = CMOV(tv5, tv4, e1)\n    }\n    return { isValid: isQR, value: tv3 };\n  };\n  if (Fp.ORDER % _4n === _3n) {\n    // sqrt_ratio_3mod4(u, v)\n    const c1 = (Fp.ORDER - _3n) / _4n; // 1. c1 = (q - 3) / 4     # Integer arithmetic\n    const c2 = Fp.sqrt(Fp.neg(Z)); // 2. c2 = sqrt(-Z)\n    sqrtRatio = (u: T, v: T) => {\n      let tv1 = Fp.sqr(v); // 1. tv1 = v^2\n      const tv2 = Fp.mul(u, v); // 2. tv2 = u * v\n      tv1 = Fp.mul(tv1, tv2); // 3. tv1 = tv1 * tv2\n      let y1 = Fp.pow(tv1, c1); // 4. y1 = tv1^c1\n      y1 = Fp.mul(y1, tv2); // 5. y1 = y1 * tv2\n      const y2 = Fp.mul(y1, c2); // 6. y2 = y1 * c2\n      const tv3 = Fp.mul(Fp.sqr(y1), v); // 7. tv3 = y1^2; 8. tv3 = tv3 * v\n      const isQR = Fp.eql(tv3, u); // 9. isQR = tv3 == u\n      let y = Fp.cmov(y2, y1, isQR); // 10. y = CMOV(y2, y1, isQR)\n      return { isValid: isQR, value: y }; // 11. return (isQR, y) isQR ? y : y*c2\n    };\n  }\n  // No curves uses that\n  // if (Fp.ORDER % _8n === _5n) // sqrt_ratio_5mod8\n  return sqrtRatio;\n}\n/**\n * Simplified Shallue-van de Woestijne-Ulas Method\n * https://www.rfc-editor.org/rfc/rfc9380#section-6.6.2\n */\nexport function mapToCurveSimpleSWU<T>(\n  Fp: IField<T>,\n  opts: {\n    A: T;\n    B: T;\n    Z: T;\n  }\n): (u: T) => { x: T; y: T } {\n  validateField(Fp);\n  if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))\n    throw new Error('mapToCurveSimpleSWU: invalid opts');\n  const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);\n  if (!Fp.isOdd) throw new Error('Fp.isOdd is not implemented!');\n  // Input: u, an element of F.\n  // Output: (x, y), a point on E.\n  return (u: T): { x: T; y: T } => {\n    // prettier-ignore\n    let tv1, tv2, tv3, tv4, tv5, tv6, x, y;\n    tv1 = Fp.sqr(u); // 1.  tv1 = u^2\n    tv1 = Fp.mul(tv1, opts.Z); // 2.  tv1 = Z * tv1\n    tv2 = Fp.sqr(tv1); // 3.  tv2 = tv1^2\n    tv2 = Fp.add(tv2, tv1); // 4.  tv2 = tv2 + tv1\n    tv3 = Fp.add(tv2, Fp.ONE); // 5.  tv3 = tv2 + 1\n    tv3 = Fp.mul(tv3, opts.B); // 6.  tv3 = B * tv3\n    tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO)); // 7.  tv4 = CMOV(Z, -tv2, tv2 != 0)\n    tv4 = Fp.mul(tv4, opts.A); // 8.  tv4 = A * tv4\n    tv2 = Fp.sqr(tv3); // 9.  tv2 = tv3^2\n    tv6 = Fp.sqr(tv4); // 10. tv6 = tv4^2\n    tv5 = Fp.mul(tv6, opts.A); // 11. tv5 = A * tv6\n    tv2 = Fp.add(tv2, tv5); // 12. tv2 = tv2 + tv5\n    tv2 = Fp.mul(tv2, tv3); // 13. tv2 = tv2 * tv3\n    tv6 = Fp.mul(tv6, tv4); // 14. tv6 = tv6 * tv4\n    tv5 = Fp.mul(tv6, opts.B); // 15. tv5 = B * tv6\n    tv2 = Fp.add(tv2, tv5); // 16. tv2 = tv2 + tv5\n    x = Fp.mul(tv1, tv3); // 17.   x = tv1 * tv3\n    const { isValid, value } = sqrtRatio(tv2, tv6); // 18. (is_gx1_square, y1) = sqrt_ratio(tv2, tv6)\n    y = Fp.mul(tv1, u); // 19.   y = tv1 * u  -> Z * u^3 * y1\n    y = Fp.mul(y, value); // 20.   y = y * y1\n    x = Fp.cmov(x, tv3, isValid); // 21.   x = CMOV(x, tv3, is_gx1_square)\n    y = Fp.cmov(y, value, isValid); // 22.   y = CMOV(y, y1, is_gx1_square)\n    const e1 = Fp.isOdd!(u) === Fp.isOdd!(y); // 23.  e1 = sgn0(u) == sgn0(y)\n    y = Fp.cmov(Fp.neg(y), y, e1); // 24.   y = CMOV(-y, y, e1)\n    x = Fp.div(x, tv4); // 25.   x = x / tv4\n    return { x, y };\n  };\n}\n","/**\n * Internal webcrypto alias.\n * We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n * See utils.ts for details.\n * @module\n */\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto: any =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n","import { concat, equal, hexToBytes } from '@xrplf/isomorphic/utils'\n\nimport {\n  codec,\n  encodeSeed,\n  decodeSeed,\n  encodeAccountID,\n  decodeAccountID,\n  encodeNodePublic,\n  decodeNodePublic,\n  encodeAccountPublic,\n  decodeAccountPublic,\n  isValidClassicAddress,\n} from './xrp-codec'\n\nconst PREFIX_BYTES = {\n  // 5, 68\n  main: Uint8Array.from([0x05, 0x44]),\n  // 4, 147\n  test: Uint8Array.from([0x04, 0x93]),\n}\n\nconst MAX_32_BIT_UNSIGNED_INT = 4294967295\n\nfunction classicAddressToXAddress(\n  classicAddress: string,\n  tag: number | false,\n  test: boolean,\n): string {\n  const accountId = decodeAccountID(classicAddress)\n  return encodeXAddress(accountId, tag, test)\n}\n\nfunction encodeXAddress(\n  accountId: Uint8Array,\n  tag: number | false,\n  test: boolean,\n): string {\n  if (accountId.length !== 20) {\n    // RIPEMD160 is 160 bits = 20 bytes\n    throw new Error('Account ID must be 20 bytes')\n  }\n  if (tag !== false && tag > MAX_32_BIT_UNSIGNED_INT) {\n    throw new Error('Invalid tag')\n  }\n  const theTag = tag || 0\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition -- Passing null is a common js mistake\n  const flag = tag === false || tag == null ? 0 : 1\n  /* eslint-disable no-bitwise ---\n   * need to use bitwise operations here */\n  const bytes = concat([\n    test ? PREFIX_BYTES.test : PREFIX_BYTES.main,\n    accountId,\n    Uint8Array.from([\n      // 0x00 if no tag, 0x01 if 32-bit tag\n      flag,\n      // first byte\n      theTag & 0xff,\n      // second byte\n      (theTag >> 8) & 0xff,\n      // third byte\n      (theTag >> 16) & 0xff,\n      // fourth byte\n      (theTag >> 24) & 0xff,\n      0,\n      0,\n      0,\n      // four zero bytes (reserved for 64-bit tags)\n      0,\n    ]),\n  ])\n  /* eslint-enable no-bitwise */\n  return codec.encodeChecked(bytes)\n}\n\nfunction xAddressToClassicAddress(xAddress: string): {\n  classicAddress: string\n  tag: number | false\n  test: boolean\n} {\n  /* eslint-disable @typescript-eslint/naming-convention --\n   * TODO 'test' should be something like 'isTest', do this later\n   */\n  const { accountId, tag, test } = decodeXAddress(xAddress)\n  /* eslint-enable @typescript-eslint/naming-convention */\n  const classicAddress = encodeAccountID(accountId)\n  return {\n    classicAddress,\n    tag,\n    test,\n  }\n}\n\nfunction decodeXAddress(xAddress: string): {\n  accountId: Uint8Array\n  tag: number | false\n  test: boolean\n} {\n  const decoded = codec.decodeChecked(xAddress)\n  /* eslint-disable @typescript-eslint/naming-convention --\n   * TODO 'test' should be something like 'isTest', do this later\n   */\n  const test = isUint8ArrayForTestAddress(decoded)\n  /* eslint-enable @typescript-eslint/naming-convention */\n  const accountId = decoded.slice(2, 22)\n  const tag = tagFromUint8Array(decoded)\n  return {\n    accountId,\n    tag,\n    test,\n  }\n}\n\nfunction isUint8ArrayForTestAddress(buf: Uint8Array): boolean {\n  const decodedPrefix = buf.slice(0, 2)\n  if (equal(PREFIX_BYTES.main, decodedPrefix)) {\n    return false\n  }\n  if (equal(PREFIX_BYTES.test, decodedPrefix)) {\n    return true\n  }\n\n  throw new Error('Invalid X-address: bad prefix')\n}\n\nfunction tagFromUint8Array(buf: Uint8Array): number | false {\n  const flag = buf[22]\n  if (flag >= 2) {\n    // No support for 64-bit tags at this time\n    throw new Error('Unsupported X-address')\n  }\n  if (flag === 1) {\n    // Little-endian to big-endian\n    return buf[23] + buf[24] * 0x100 + buf[25] * 0x10000 + buf[26] * 0x1000000\n  }\n  if (flag !== 0) {\n    throw new Error('flag must be zero to indicate no tag')\n  }\n  if (!equal(hexToBytes('0000000000000000'), buf.slice(23, 23 + 8))) {\n    throw new Error('remaining bytes must be zero')\n  }\n  return false\n}\n\nfunction isValidXAddress(xAddress: string): boolean {\n  try {\n    decodeXAddress(xAddress)\n  } catch (_error) {\n    return false\n  }\n  return true\n}\n\nexport {\n  // Codec with XRP alphabet\n  codec,\n  // Encode entropy as a \"seed\"\n  encodeSeed,\n  // Decode a seed into an object with its version, type, and bytes\n  decodeSeed,\n  // Encode bytes as a classic address (r...)\n  encodeAccountID,\n  // Decode a classic address to its raw bytes\n  decodeAccountID,\n  // Encode bytes to XRP Ledger node public key format\n  encodeNodePublic,\n  // Decode an XRP Ledger node public key into its raw bytes\n  decodeNodePublic,\n  // Encode a public key, as for payment channels\n  encodeAccountPublic,\n  // Decode a public key, as for payment channels\n  decodeAccountPublic,\n  // Check whether a classic address (r...) is valid\n  isValidClassicAddress,\n  // Derive X-address from classic address, tag, and network ID\n  classicAddressToXAddress,\n  // Encode account ID, tag, and network ID to X-address\n  encodeXAddress,\n  // Decode X-address to account ID, tag, and network ID\n  xAddressToClassicAddress,\n  // Convert X-address to classic address, tag, and network ID\n  decodeXAddress,\n  // Check whether an X-address (X...) is valid\n  isValidXAddress,\n}\n","import { sha256 as nobleImpl } from '@noble/hashes/sha256'\n\nimport wrapNoble from '../internal/wrapNoble'\n\n/**\n * Wrap noble-libs's sha256 implementation in HashFn\n */\nexport const sha256 = wrapNoble(nobleImpl)\n","import {\n  decodeNodePublic,\n  decodeSeed,\n  encodeAccountID,\n  encodeSeed,\n} from 'ripple-address-codec'\nimport { ripemd160 } from '@xrplf/isomorphic/ripemd160'\nimport { sha256 } from '@xrplf/isomorphic/sha256'\nimport { hexToBytes, randomBytes } from '@xrplf/isomorphic/utils'\n\nimport { accountPublicFromPublicGenerator } from './signing-schemes/secp256k1/utils'\nimport Sha512 from './utils/Sha512'\nimport assert from './utils/assert'\nimport type { Algorithm, HexString, KeyPair, SigningScheme } from './types'\nimport {\n  getAlgorithmFromPrivateKey,\n  getAlgorithmFromPublicKey,\n} from './utils/getAlgorithmFromKey'\n\nimport secp256k1 from './signing-schemes/secp256k1'\nimport ed25519 from './signing-schemes/ed25519'\n\nfunction getSigningScheme(algorithm: Algorithm): SigningScheme {\n  const schemes = { 'ecdsa-secp256k1': secp256k1, ed25519 }\n  return schemes[algorithm]\n}\n\nfunction generateSeed(\n  options: {\n    entropy?: Uint8Array\n    algorithm?: Algorithm\n  } = {},\n): string {\n  assert.ok(\n    !options.entropy || options.entropy.length >= 16,\n    'entropy too short',\n  )\n  const entropy = options.entropy\n    ? options.entropy.slice(0, 16)\n    : randomBytes(16)\n  const type = options.algorithm === 'ed25519' ? 'ed25519' : 'secp256k1'\n  return encodeSeed(entropy, type)\n}\n\nfunction deriveKeypair(\n  seed: string,\n  options?: {\n    algorithm?: Algorithm\n    validator?: boolean\n    accountIndex?: number\n  },\n): KeyPair {\n  const decoded = decodeSeed(seed)\n  const proposedAlgorithm = options?.algorithm ?? decoded.type\n  const algorithm =\n    proposedAlgorithm === 'ed25519' ? 'ed25519' : 'ecdsa-secp256k1'\n  const scheme = getSigningScheme(algorithm)\n  const keypair = scheme.deriveKeypair(decoded.bytes, options)\n  const messageToVerify = Sha512.half('This test message should verify.')\n  const signature = scheme.sign(messageToVerify, keypair.privateKey)\n  /* istanbul ignore if */\n  if (!scheme.verify(messageToVerify, signature, keypair.publicKey)) {\n    throw new Error('derived keypair did not generate verifiable signature')\n  }\n  return keypair\n}\n\nfunction sign(messageHex: HexString, privateKey: HexString): HexString {\n  const algorithm = getAlgorithmFromPrivateKey(privateKey)\n  return getSigningScheme(algorithm).sign(hexToBytes(messageHex), privateKey)\n}\n\nfunction verify(\n  messageHex: HexString,\n  signature: HexString,\n  publicKey: HexString,\n): boolean {\n  const algorithm = getAlgorithmFromPublicKey(publicKey)\n  return getSigningScheme(algorithm).verify(\n    hexToBytes(messageHex),\n    signature,\n    publicKey,\n  )\n}\n\nfunction computePublicKeyHash(publicKeyBytes: Uint8Array): Uint8Array {\n  return ripemd160(sha256(publicKeyBytes))\n}\n\nfunction deriveAddressFromBytes(publicKeyBytes: Uint8Array): string {\n  return encodeAccountID(computePublicKeyHash(publicKeyBytes))\n}\n\nfunction deriveAddress(publicKey: string): string {\n  return deriveAddressFromBytes(hexToBytes(publicKey))\n}\n\nfunction deriveNodeAddress(publicKey: string): string {\n  const generatorBytes = decodeNodePublic(publicKey)\n  const accountPublicBytes = accountPublicFromPublicGenerator(generatorBytes)\n  return deriveAddressFromBytes(accountPublicBytes)\n}\n\nexport {\n  generateSeed,\n  deriveKeypair,\n  sign,\n  verify,\n  deriveAddress,\n  deriveNodeAddress,\n  decodeSeed,\n}\n","/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nconst _2n = /* @__PURE__ */ BigInt(2);\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\nexport function abytes(item: unknown): void {\n  if (!isBytes(item)) throw new Error('Uint8Array expected');\n}\n\nexport function abool(title: string, value: boolean): void {\n  if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);\n}\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  abytes(bytes);\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n    }\n  } else if (isBytes(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(title + ' must be hex string or Uint8Array');\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n  return res;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n// Is positive bigint\nconst isPosBig = (n: bigint) => typeof n === 'bigint' && _0n <= n;\n\nexport function inRange(n: bigint, min: bigint, max: bigint): boolean {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title: string, n: bigint, min: bigint, max: bigint): void {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max))\n    throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n: bigint): number {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number): bigint {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n: bigint, pos: number, value: boolean): bigint {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number): bigint => (_2n << BigInt(n - 1)) - _1n;\n\n// DRBG\n\nconst u8n = (data?: any) => new Uint8Array(data); // creates Uint8Array\nconst u8fr = (arr: any) => Uint8Array.from(arr); // another shortcut\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n()) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any): boolean => typeof val === 'bigint',\n  function: (val: any): boolean => typeof val === 'function',\n  boolean: (val: any): boolean => typeof val === 'boolean',\n  string: (val: any): boolean => typeof val === 'string',\n  stringOrUint8Array: (val: any): boolean => typeof val === 'string' || isBytes(val),\n  isSafeInteger: (val: any): boolean => Number.isSafeInteger(val),\n  array: (val: any): boolean => Array.isArray(val),\n  field: (val: any, object: any): any => (object as any).Fp.isValid(val),\n  hash: (val: any): boolean => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n): T {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error('invalid validator function');\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        'param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n\n/**\n * throws not implemented error\n */\nexport const notImplemented = (): never => {\n  throw new Error('not implemented');\n};\n\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized<T extends object, R, O extends any[]>(\n  fn: (arg: T, ...args: O) => R\n): (arg: T, ...args: O) => R {\n  const map = new WeakMap<T, R>();\n  return (arg: T, ...args: O): R => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}\n","import { deriveAddress, deriveKeypair, generateSeed } from 'ripple-keypairs'\n\nimport {\n  entropyToSecret,\n  parseSecretString,\n  randomSecret,\n  secretToEntropy,\n} from '../utils'\n\n/* Types ==================================================================== */\n\nexport interface Keypair {\n  publicKey: string\n  privateKey: string\n}\n\ninterface AccountData {\n  familySeed: string\n  address: string\n  keypair: Keypair\n}\n\n/* Class ==================================================================== */\n\nexport class Account {\n  private readonly _secret: string[]\n  private readonly _account: AccountData = {\n    familySeed: '',\n    address: '',\n    keypair: {\n      publicKey: '',\n      privateKey: '',\n    },\n  }\n\n  constructor(secretNumbers?: string[] | string | Uint8Array) {\n    if (typeof secretNumbers === 'string') {\n      this._secret = parseSecretString(secretNumbers)\n    } else if (Array.isArray(secretNumbers)) {\n      this._secret = secretNumbers\n    } else if (secretNumbers instanceof Uint8Array) {\n      this._secret = entropyToSecret(secretNumbers)\n    } else {\n      this._secret = randomSecret()\n    }\n\n    validateLengths(this._secret)\n    this.derive()\n  }\n\n  getSecret(): string[] {\n    return this._secret\n  }\n\n  getSecretString(): string {\n    return this._secret.join(' ')\n  }\n\n  getAddress(): string {\n    return this._account.address\n  }\n\n  getFamilySeed(): string {\n    return this._account.familySeed\n  }\n\n  getKeypair(): Keypair {\n    return this._account.keypair\n  }\n\n  toString(): string {\n    return this.getSecretString()\n  }\n\n  private derive(): void {\n    try {\n      const entropy = secretToEntropy(this._secret)\n      this._account.familySeed = generateSeed({ entropy })\n      this._account.keypair = deriveKeypair(this._account.familySeed)\n      this._account.address = deriveAddress(this._account.keypair.publicKey)\n    } catch (error) {\n      let message = 'Unknown Error'\n      if (error instanceof Error) {\n        message = error.message\n      }\n      // we'll proceed, but let's report it\n      throw new Error(message)\n    }\n  }\n}\n\nfunction validateLengths(secretNumbers: string[]): void {\n  if (secretNumbers.length !== 8) {\n    throw new Error('Secret must have 8 numbers')\n  }\n  secretNumbers.forEach((num) => {\n    if (num.length !== 6) {\n      throw new Error('Each secret number must be 6 digits')\n    }\n  })\n}\n","import { numberToBytesBE } from '@noble/curves/abstract/utils'\nimport { secp256k1 as nobleSecp256k1 } from '@noble/curves/secp256k1'\nimport { bytesToHex } from '@xrplf/isomorphic/utils'\n\nimport type {\n  DeriveKeyPairOptions,\n  HexString,\n  SigningScheme,\n} from '../../types'\n\nimport { derivePrivateKey } from './utils'\nimport assert from '../../utils/assert'\nimport Sha512 from '../../utils/Sha512'\n\nconst SECP256K1_PREFIX = '00'\n\nconst secp256k1: SigningScheme = {\n  deriveKeypair(\n    entropy: Uint8Array,\n    options?: DeriveKeyPairOptions,\n  ): {\n    privateKey: string\n    publicKey: string\n  } {\n    const derived = derivePrivateKey(entropy, options)\n    const privateKey =\n      SECP256K1_PREFIX + bytesToHex(numberToBytesBE(derived, 32))\n\n    const publicKey = bytesToHex(nobleSecp256k1.getPublicKey(derived, true))\n    return { privateKey, publicKey }\n  },\n\n  sign(message: Uint8Array, privateKey: HexString): string {\n    // Some callers pass the privateKey with the prefix, others without.\n    // @noble/curves will throw if the key is not exactly 32 bytes, so we\n    // normalize it before passing to the sign method.\n    assert.ok(\n      (privateKey.length === 66 && privateKey.startsWith(SECP256K1_PREFIX)) ||\n        privateKey.length === 64,\n    )\n    const normedPrivateKey =\n      privateKey.length === 66 ? privateKey.slice(2) : privateKey\n    return nobleSecp256k1\n      .sign(Sha512.half(message), normedPrivateKey, {\n        // \"Canonical\" signatures\n        lowS: true,\n        // Would fail tests if signatures aren't deterministic\n        extraEntropy: undefined,\n      })\n      .toDERHex(true)\n      .toUpperCase()\n  },\n\n  verify(\n    message: Uint8Array,\n    signature: HexString,\n    publicKey: HexString,\n  ): boolean {\n    const decoded = nobleSecp256k1.Signature.fromDER(signature)\n    return nobleSecp256k1.verify(decoded, Sha512.half(message), publicKey)\n  },\n}\n\nexport default secp256k1\n","/**\n * Internal assertion helpers.\n * @module\n */\n\n/** Asserts something is positive integer. */\nfunction anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Is number an Uint8Array? Copied from utils for perf. */\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is Uint8Array. */\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Hash interface. */\nexport type Hash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** Asserts something is hash */\nfunction ahash(h: Hash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.wrapConstructor');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nfunction aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nfunction aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\nexport { anumber, abytes, ahash, aexists, aoutput };\n","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Asserts something is hash */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** @deprecated */\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash interface. */\nexport type IHash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  abstract clone(): T;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\nexport const wrapConstructor: typeof createHasher = createHasher;\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","/**\n * Codec class\n */\n\nimport { base58xrp, BytesCoder } from '@scure/base'\nimport { sha256 } from '@xrplf/isomorphic/sha256'\n\nimport { arrayEqual, concatArgs, ByteArray } from './utils'\n\nclass Codec {\n  private readonly _sha256: (bytes: ByteArray) => Uint8Array\n  private readonly _codec: BytesCoder\n\n  public constructor(options: { sha256: (bytes: ByteArray) => Uint8Array }) {\n    this._sha256 = options.sha256\n    this._codec = base58xrp\n  }\n\n  /**\n   * Encoder.\n   *\n   * @param bytes - Uint8Array of data to encode.\n   * @param opts - Options object including the version bytes and the expected length of the data to encode.\n   */\n  public encode(\n    bytes: ByteArray,\n    opts: {\n      versions: number[]\n      expectedLength: number\n    },\n  ): string {\n    const versions = opts.versions\n    return this._encodeVersioned(bytes, versions, opts.expectedLength)\n  }\n\n  /**\n   * Decoder.\n   *\n   * @param base58string - Base58Check-encoded string to decode.\n   * @param opts - Options object including the version byte(s) and the expected length of the data after decoding.\n   */\n  /* eslint-disable max-lines-per-function --\n   * TODO refactor */\n  public decode(\n    base58string: string,\n    opts: {\n      versions: Array<number | number[]>\n      expectedLength?: number\n      versionTypes?: ['ed25519', 'secp256k1']\n    },\n  ): {\n    version: number[]\n    bytes: Uint8Array\n    type: 'ed25519' | 'secp256k1' | null\n  } {\n    const versions = opts.versions\n    const types = opts.versionTypes\n\n    const withoutSum = this.decodeChecked(base58string)\n\n    if (versions.length > 1 && !opts.expectedLength) {\n      throw new Error(\n        'expectedLength is required because there are >= 2 possible versions',\n      )\n    }\n    const versionLengthGuess =\n      typeof versions[0] === 'number' ? 1 : versions[0].length\n    const payloadLength =\n      opts.expectedLength ?? withoutSum.length - versionLengthGuess\n    const versionBytes = withoutSum.slice(0, -payloadLength)\n    const payload = withoutSum.slice(-payloadLength)\n\n    for (let i = 0; i < versions.length; i++) {\n      /* eslint-disable @typescript-eslint/consistent-type-assertions --\n       * TODO refactor */\n      const version: number[] = Array.isArray(versions[i])\n        ? (versions[i] as number[])\n        : [versions[i] as number]\n      if (arrayEqual(versionBytes, version)) {\n        return {\n          version,\n          bytes: payload,\n          type: types ? types[i] : null,\n        }\n      }\n      /* eslint-enable @typescript-eslint/consistent-type-assertions */\n    }\n\n    throw new Error(\n      'version_invalid: version bytes do not match any of the provided version(s)',\n    )\n  }\n\n  public encodeChecked(bytes: ByteArray): string {\n    const check = this._sha256(this._sha256(bytes)).slice(0, 4)\n    return this._encodeRaw(Uint8Array.from(concatArgs(bytes, check)))\n  }\n\n  public decodeChecked(base58string: string): Uint8Array {\n    const intArray = this._decodeRaw(base58string)\n    if (intArray.byteLength < 5) {\n      throw new Error('invalid_input_size: decoded data must have length >= 5')\n    }\n    if (!this._verifyCheckSum(intArray)) {\n      throw new Error('checksum_invalid')\n    }\n    return intArray.slice(0, -4)\n  }\n\n  private _encodeVersioned(\n    bytes: ByteArray,\n    versions: number[],\n    expectedLength: number,\n  ): string {\n    if (!checkByteLength(bytes, expectedLength)) {\n      throw new Error(\n        'unexpected_payload_length: bytes.length does not match expectedLength.' +\n          ' Ensure that the bytes are a Uint8Array.',\n      )\n    }\n    return this.encodeChecked(concatArgs(versions, bytes))\n  }\n\n  private _encodeRaw(bytes: ByteArray): string {\n    return this._codec.encode(Uint8Array.from(bytes))\n  }\n  /* eslint-enable max-lines-per-function */\n\n  private _decodeRaw(base58string: string): Uint8Array {\n    return this._codec.decode(base58string)\n  }\n\n  private _verifyCheckSum(bytes: ByteArray): boolean {\n    const computed = this._sha256(this._sha256(bytes.slice(0, -4))).slice(0, 4)\n    const checksum = bytes.slice(-4)\n    return arrayEqual(computed, checksum)\n  }\n}\n\n/**\n * XRP codec\n */\n\n// base58 encodings: https://xrpl.org/base58-encodings.html\n// Account address (20 bytes)\nconst ACCOUNT_ID = 0\n// Account public key (33 bytes)\nconst ACCOUNT_PUBLIC_KEY = 0x23\n// 33; Seed value (for secret keys) (16 bytes)\nconst FAMILY_SEED = 0x21\n// 28; Validation public key (33 bytes)\nconst NODE_PUBLIC = 0x1c\n\n// [1, 225, 75]\nconst ED25519_SEED = [0x01, 0xe1, 0x4b]\n\nconst codecOptions = {\n  sha256,\n}\n\nconst codecWithXrpAlphabet = new Codec(codecOptions)\n\nexport const codec = codecWithXrpAlphabet\n\n// entropy is a Uint8Array of size 16\n// type is 'ed25519' or 'secp256k1'\nexport function encodeSeed(\n  entropy: ByteArray,\n  type: 'ed25519' | 'secp256k1',\n): string {\n  if (!checkByteLength(entropy, 16)) {\n    throw new Error('entropy must have length 16')\n  }\n  const opts = {\n    expectedLength: 16,\n\n    // for secp256k1, use `FAMILY_SEED`\n    versions: type === 'ed25519' ? ED25519_SEED : [FAMILY_SEED],\n  }\n\n  // prefixes entropy with version bytes\n  return codecWithXrpAlphabet.encode(entropy, opts)\n}\n\nexport function decodeSeed(\n  seed: string,\n  opts: {\n    versionTypes: ['ed25519', 'secp256k1']\n    versions: Array<number | number[]>\n    expectedLength: number\n  } = {\n    versionTypes: ['ed25519', 'secp256k1'],\n    versions: [ED25519_SEED, FAMILY_SEED],\n    expectedLength: 16,\n  },\n): {\n  version: number[]\n  bytes: Uint8Array\n  type: 'ed25519' | 'secp256k1' | null\n} {\n  return codecWithXrpAlphabet.decode(seed, opts)\n}\n\nexport function encodeAccountID(bytes: ByteArray): string {\n  const opts = { versions: [ACCOUNT_ID], expectedLength: 20 }\n  return codecWithXrpAlphabet.encode(bytes, opts)\n}\n\n/* eslint-disable import/no-unused-modules ---\n * unclear why this is aliased but we should keep it in case someone else is\n * importing it with the aliased name */\nexport const encodeAddress = encodeAccountID\n/* eslint-enable import/no-unused-modules */\n\nexport function decodeAccountID(accountId: string): Uint8Array {\n  const opts = { versions: [ACCOUNT_ID], expectedLength: 20 }\n  return codecWithXrpAlphabet.decode(accountId, opts).bytes\n}\n\n/* eslint-disable import/no-unused-modules ---\n * unclear why this is aliased but we should keep it in case someone else is\n * importing it with the aliased name */\nexport const decodeAddress = decodeAccountID\n/* eslint-enable import/no-unused-modules */\n\nexport function decodeNodePublic(base58string: string): Uint8Array {\n  const opts = { versions: [NODE_PUBLIC], expectedLength: 33 }\n  return codecWithXrpAlphabet.decode(base58string, opts).bytes\n}\n\nexport function encodeNodePublic(bytes: ByteArray): string {\n  const opts = { versions: [NODE_PUBLIC], expectedLength: 33 }\n  return codecWithXrpAlphabet.encode(bytes, opts)\n}\n\nexport function encodeAccountPublic(bytes: ByteArray): string {\n  const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 }\n  return codecWithXrpAlphabet.encode(bytes, opts)\n}\n\nexport function decodeAccountPublic(base58string: string): Uint8Array {\n  const opts = { versions: [ACCOUNT_PUBLIC_KEY], expectedLength: 33 }\n  return codecWithXrpAlphabet.decode(base58string, opts).bytes\n}\n\nexport function isValidClassicAddress(address: string): boolean {\n  try {\n    decodeAccountID(address)\n  } catch (_error) {\n    return false\n  }\n  return true\n}\n\nfunction checkByteLength(bytes: ByteArray, expectedLength: number): boolean {\n  return 'byteLength' in bytes\n    ? bytes.byteLength === expectedLength\n    : bytes.length === expectedLength\n}\n","/**\n * RIPEMD-160 legacy hash function.\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160.html\n * https://homes.esat.kuleuven.be/~bosselae/ripemd160/pdf/AB-9601/AB-9601.pdf\n * @module\n * @deprecated\n */\nimport { RIPEMD160 as RIPEMD160n, ripemd160 as ripemd160n } from './legacy.ts';\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexport const RIPEMD160: typeof RIPEMD160n = RIPEMD160n;\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexport const ripemd160: typeof ripemd160n = ripemd160n;\n","import { ed25519 as nobleEd25519 } from '@noble/curves/ed25519'\nimport { bytesToHex } from '@xrplf/isomorphic/utils'\n\nimport type { HexString, SigningScheme } from '../../types'\nimport assert from '../../utils/assert'\nimport Sha512 from '../../utils/Sha512'\n\nconst ED_PREFIX = 'ED'\n\nconst ed25519: SigningScheme = {\n  deriveKeypair(entropy: Uint8Array): {\n    privateKey: string\n    publicKey: string\n  } {\n    const rawPrivateKey = Sha512.half(entropy)\n    const privateKey = ED_PREFIX + bytesToHex(rawPrivateKey)\n    const publicKey =\n      ED_PREFIX + bytesToHex(nobleEd25519.getPublicKey(rawPrivateKey))\n    return { privateKey, publicKey }\n  },\n\n  sign(message: Uint8Array, privateKey: HexString): string {\n    assert.ok(message instanceof Uint8Array, 'message must be array of octets')\n    assert.ok(\n      privateKey.length === 66,\n      'private key must be 33 bytes including prefix',\n    )\n    return bytesToHex(nobleEd25519.sign(message, privateKey.slice(2)))\n  },\n\n  verify(\n    message: Uint8Array,\n    signature: HexString,\n    publicKey: string,\n  ): boolean {\n    // Unlikely to be triggered as these are internal and guarded by getAlgorithmFromKey\n    assert.ok(\n      publicKey.length === 66,\n      'public key must be 33 bytes including prefix',\n    )\n    return nobleEd25519.verify(\n      signature,\n      message,\n      // Remove the 0xED prefix\n      publicKey.slice(2),\n      // By default, set zip215 to false for compatibility reasons.\n      // ZIP 215 is a stricter Ed25519 signature verification scheme.\n      // However, setting it to false adheres to the more commonly used\n      // RFC8032 / NIST186-5 standards, making it compatible with systems\n      // like the XRP Ledger.\n      { zip215: false },\n    )\n  },\n}\n\nexport default ed25519\n","import { concatBytes } from '@noble/hashes/utils'\n\nexport const HEX_REGEX = /^[A-F0-9]*$/iu\n\nexport function concat(views: Uint8Array[]): Uint8Array {\n  return concatBytes(...views)\n}\n\nexport function equal(buf1: Uint8Array, buf2: Uint8Array): boolean {\n  if (buf1.byteLength !== buf2.byteLength) {\n    return false\n  }\n  const dv1 = new Int8Array(buf1)\n  const dv2 = new Int8Array(buf2)\n  for (let i = 0; i !== buf1.byteLength; i++) {\n    if (dv1[i] !== dv2[i]) {\n      return false\n    }\n  }\n  return true\n}\n","/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\nexport interface Coder<F, T> {\n  encode(from: F): T;\n  decode(to: T): F;\n}\n\nexport interface BytesCoder extends Coder<Uint8Array, string> {\n  encode: (data: Uint8Array) => string;\n  decode: (str: string) => Uint8Array;\n}\n\nfunction isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n/** Asserts something is Uint8Array. */\nfunction abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\nfunction isArrayOf(isString: boolean, arr: any[]) {\n  if (!Array.isArray(arr)) return false;\n  if (arr.length === 0) return true;\n  if (isString) {\n    return arr.every((item) => typeof item === 'string');\n  } else {\n    return arr.every((item) => Number.isSafeInteger(item));\n  }\n}\n\n// no abytes: seems to have 10% slowdown. Why?!\n\nfunction afn(input: Function): input is Function {\n  if (typeof input !== 'function') throw new Error('function expected');\n  return true;\n}\n\nfunction astr(label: string, input: unknown): input is string {\n  if (typeof input !== 'string') throw new Error(`${label}: string expected`);\n  return true;\n}\n\nfunction anumber(n: number): void {\n  if (!Number.isSafeInteger(n)) throw new Error(`invalid integer: ${n}`);\n}\n\nfunction aArr(input: any[]) {\n  if (!Array.isArray(input)) throw new Error('array expected');\n}\nfunction astrArr(label: string, input: string[]) {\n  if (!isArrayOf(true, input)) throw new Error(`${label}: array of strings expected`);\n}\nfunction anumArr(label: string, input: number[]) {\n  if (!isArrayOf(false, input)) throw new Error(`${label}: array of numbers expected`);\n}\n\n// TODO: some recusive type inference so it would check correct order of input/output inside rest?\n// like <string, number>, <number, bytes>, <bytes, float>\ntype Chain = [Coder<any, any>, ...Coder<any, any>[]];\n// Extract info from Coder type\ntype Input<F> = F extends Coder<infer T, any> ? T : never;\ntype Output<F> = F extends Coder<any, infer T> ? T : never;\n// Generic function for arrays\ntype First<T> = T extends [infer U, ...any[]] ? U : never;\ntype Last<T> = T extends [...any[], infer U] ? U : never;\ntype Tail<T> = T extends [any, ...infer U] ? U : never;\n\ntype AsChain<C extends Chain, Rest = Tail<C>> = {\n  // C[K] = Coder<Input<C[K]>, Input<Rest[k]>>\n  [K in keyof C]: Coder<Input<C[K]>, Input<K extends keyof Rest ? Rest[K] : any>>;\n};\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction chain<T extends Chain & AsChain<T>>(...args: T): Coder<Input<First<T>>, Output<Last<T>>> {\n  const id = (a: any) => a;\n  // Wrap call in closure so JIT can inline calls\n  const wrap = (a: any, b: any) => (c: any) => a(b(c));\n  // Construct chain of args[-1].encode(args[-2].encode([...]))\n  const encode = args.map((x) => x.encode).reduceRight(wrap, id);\n  // Construct chain of args[0].decode(args[1].decode(...))\n  const decode = args.map((x) => x.decode).reduce(wrap, id);\n  return { encode, decode };\n}\n\n/**\n * Encodes integer radix representation to array of strings using alphabet and back.\n * Could also be array of strings.\n * @__NO_SIDE_EFFECTS__\n */\nfunction alphabet(letters: string | string[]): Coder<number[], string[]> {\n  // mapping 1 to \"b\"\n  const lettersA = typeof letters === 'string' ? letters.split('') : letters;\n  const len = lettersA.length;\n  astrArr('alphabet', lettersA);\n\n  // mapping \"b\" to 1\n  const indexes = new Map(lettersA.map((l, i) => [l, i]));\n  return {\n    encode: (digits: number[]) => {\n      aArr(digits);\n      return digits.map((i) => {\n        if (!Number.isSafeInteger(i) || i < 0 || i >= len)\n          throw new Error(\n            `alphabet.encode: digit index outside alphabet \"${i}\". Allowed: ${letters}`\n          );\n        return lettersA[i]!;\n      });\n    },\n    decode: (input: string[]): number[] => {\n      aArr(input);\n      return input.map((letter) => {\n        astr('alphabet.decode', letter);\n        const i = indexes.get(letter);\n        if (i === undefined) throw new Error(`Unknown letter: \"${letter}\". Allowed: ${letters}`);\n        return i;\n      });\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction join(separator = ''): Coder<string[], string> {\n  astr('join', separator);\n  return {\n    encode: (from) => {\n      astrArr('join.decode', from);\n      return from.join(separator);\n    },\n    decode: (to) => {\n      astr('join.decode', to);\n      return to.split(separator);\n    },\n  };\n}\n\n/**\n * Pad strings array so it has integer number of bits\n * @__NO_SIDE_EFFECTS__\n */\nfunction padding(bits: number, chr = '='): Coder<string[], string[]> {\n  anumber(bits);\n  astr('padding', chr);\n  return {\n    encode(data: string[]): string[] {\n      astrArr('padding.encode', data);\n      while ((data.length * bits) % 8) data.push(chr);\n      return data;\n    },\n    decode(input: string[]): string[] {\n      astrArr('padding.decode', input);\n      let end = input.length;\n      if ((end * bits) % 8)\n        throw new Error('padding: invalid, string should have whole number of bytes');\n      for (; end > 0 && input[end - 1] === chr; end--) {\n        const last = end - 1;\n        const byte = last * bits;\n        if (byte % 8 === 0) throw new Error('padding: invalid, string has too much padding');\n      }\n      return input.slice(0, end);\n    },\n  };\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction normalize<T>(fn: (val: T) => T): Coder<T, T> {\n  afn(fn);\n  return { encode: (from: T) => from, decode: (to: T) => fn(to) };\n}\n\n/**\n * Slow: O(n^2) time complexity\n */\nfunction convertRadix(data: number[], from: number, to: number): number[] {\n  // base 1 is impossible\n  if (from < 2) throw new Error(`convertRadix: invalid from=${from}, base cannot be less than 2`);\n  if (to < 2) throw new Error(`convertRadix: invalid to=${to}, base cannot be less than 2`);\n  aArr(data);\n  if (!data.length) return [];\n  let pos = 0;\n  const res = [];\n  const digits = Array.from(data, (d) => {\n    anumber(d);\n    if (d < 0 || d >= from) throw new Error(`invalid integer: ${d}`);\n    return d;\n  });\n  const dlen = digits.length;\n  while (true) {\n    let carry = 0;\n    let done = true;\n    for (let i = pos; i < dlen; i++) {\n      const digit = digits[i]!;\n      const fromCarry = from * carry;\n      const digitBase = fromCarry + digit;\n      if (\n        !Number.isSafeInteger(digitBase) ||\n        fromCarry / from !== carry ||\n        digitBase - digit !== fromCarry\n      ) {\n        throw new Error('convertRadix: carry overflow');\n      }\n      const div = digitBase / to;\n      carry = digitBase % to;\n      const rounded = Math.floor(div);\n      digits[i] = rounded;\n      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)\n        throw new Error('convertRadix: carry overflow');\n      if (!done) continue;\n      else if (!rounded) pos = i;\n      else done = false;\n    }\n    res.push(carry);\n    if (done) break;\n  }\n  for (let i = 0; i < data.length - 1 && data[i] === 0; i++) res.push(0);\n  return res.reverse();\n}\n\nconst gcd = (a: number, b: number): number => (b === 0 ? a : gcd(b, a % b));\nconst radix2carry = /* @__NO_SIDE_EFFECTS__ */ (from: number, to: number) =>\n  from + (to - gcd(from, to));\nconst powers: number[] = /* @__PURE__ */ (() => {\n  let res = [];\n  for (let i = 0; i < 40; i++) res.push(2 ** i);\n  return res;\n})();\n/**\n * Implemented with numbers, because BigInt is 5x slower\n */\nfunction convertRadix2(data: number[], from: number, to: number, padding: boolean): number[] {\n  aArr(data);\n  if (from <= 0 || from > 32) throw new Error(`convertRadix2: wrong from=${from}`);\n  if (to <= 0 || to > 32) throw new Error(`convertRadix2: wrong to=${to}`);\n  if (radix2carry(from, to) > 32) {\n    throw new Error(\n      `convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`\n    );\n  }\n  let carry = 0;\n  let pos = 0; // bitwise position in current element\n  const max = powers[from]!;\n  const mask = powers[to]! - 1;\n  const res: number[] = [];\n  for (const n of data) {\n    anumber(n);\n    if (n >= max) throw new Error(`convertRadix2: invalid data word=${n} from=${from}`);\n    carry = (carry << from) | n;\n    if (pos + from > 32) throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);\n    pos += from;\n    for (; pos >= to; pos -= to) res.push(((carry >> (pos - to)) & mask) >>> 0);\n    const pow = powers[pos];\n    if (pow === undefined) throw new Error('invalid carry');\n    carry &= pow - 1; // clean carry, otherwise it will cause overflow\n  }\n  carry = (carry << (to - pos)) & mask;\n  if (!padding && pos >= from) throw new Error('Excess padding');\n  if (!padding && carry > 0) throw new Error(`Non-zero padding: ${carry}`);\n  if (padding && pos > 0) res.push(carry >>> 0);\n  return res;\n}\n\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix(num: number): Coder<Uint8Array, number[]> {\n  anumber(num);\n  const _256 = 2 ** 8;\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix.encode input should be Uint8Array');\n      return convertRadix(Array.from(bytes), _256, num);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix.decode', digits);\n      return Uint8Array.from(convertRadix(digits, num, _256));\n    },\n  };\n}\n\n/**\n * If both bases are power of same number (like `2**8 <-> 2**64`),\n * there is a linear algorithm. For now we have implementation for power-of-two bases only.\n * @__NO_SIDE_EFFECTS__\n */\nfunction radix2(bits: number, revPadding = false): Coder<Uint8Array, number[]> {\n  anumber(bits);\n  if (bits <= 0 || bits > 32) throw new Error('radix2: bits should be in (0..32]');\n  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)\n    throw new Error('radix2: carry overflow');\n  return {\n    encode: (bytes: Uint8Array) => {\n      if (!isBytes(bytes)) throw new Error('radix2.encode input should be Uint8Array');\n      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);\n    },\n    decode: (digits: number[]) => {\n      anumArr('radix2.decode', digits);\n      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));\n    },\n  };\n}\n\ntype ArgumentTypes<F extends Function> = F extends (...args: infer A) => any ? A : never;\nfunction unsafeWrapper<T extends (...args: any) => any>(fn: T) {\n  afn(fn);\n  return function (...args: ArgumentTypes<T>): ReturnType<T> | void {\n    try {\n      return fn.apply(null, args);\n    } catch (e) {}\n  };\n}\n\nfunction checksum(\n  len: number,\n  fn: (data: Uint8Array) => Uint8Array\n): Coder<Uint8Array, Uint8Array> {\n  anumber(len);\n  afn(fn);\n  return {\n    encode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.encode: input should be Uint8Array');\n      const sum = fn(data).slice(0, len);\n      const res = new Uint8Array(data.length + len);\n      res.set(data);\n      res.set(sum, data.length);\n      return res;\n    },\n    decode(data: Uint8Array) {\n      if (!isBytes(data)) throw new Error('checksum.decode: input should be Uint8Array');\n      const payload = data.slice(0, -len);\n      const oldChecksum = data.slice(-len);\n      const newChecksum = fn(payload).slice(0, len);\n      for (let i = 0; i < len; i++)\n        if (newChecksum[i] !== oldChecksum[i]) throw new Error('Invalid checksum');\n      return payload;\n    },\n  };\n}\n\n// prettier-ignore\nexport const utils: { alphabet: typeof alphabet; chain: typeof chain; checksum: typeof checksum; convertRadix: typeof convertRadix; convertRadix2: typeof convertRadix2; radix: typeof radix; radix2: typeof radix2; join: typeof join; padding: typeof padding; } = {\n  alphabet, chain, checksum, convertRadix, convertRadix2, radix, radix2, join, padding,\n};\n\n// RFC 4648 aka RFC 3548\n// ---------------------\n\n/**\n * base16 encoding from RFC 4648.\n * @example\n * ```js\n * base16.encode(Uint8Array.from([0x12, 0xab]));\n * // => '12AB'\n * ```\n */\nexport const base16: BytesCoder = chain(radix2(4), alphabet('0123456789ABCDEF'), join(''));\n\n/**\n * base32 encoding from RFC 4648. Has padding.\n * Use `base32nopad` for unpadded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ===='\n * base32.decode('CKVQ====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding.\n * Use `base32` for padded version.\n * Also check out `base32hex`, `base32hexnopad`, `base32crockford`.\n * @example\n * ```js\n * base32nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'CKVQ'\n * base32nopad.decode('CKVQ');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32nopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZ234567'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Padded. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hexnopad` for unpadded version.\n * @example\n * ```js\n * base32hex.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG===='\n * base32hex.decode('2ALG====');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hex: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  padding(5),\n  join('')\n);\n\n/**\n * base32 encoding from RFC 4648. No padding. Compared to ordinary `base32`, slightly different alphabet.\n * Use `base32hex` for padded version.\n * @example\n * ```js\n * base32hexnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ALG'\n * base32hexnopad.decode('2ALG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32hexnopad: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHIJKLMNOPQRSTUV'),\n  join('')\n);\n/**\n * base32 encoding from RFC 4648. Doug Crockford's version.\n * https://www.crockford.com/base32.html\n * @example\n * ```js\n * base32crockford.encode(Uint8Array.from([0x12, 0xab]));\n * // => '2ANG'\n * base32crockford.decode('2ANG');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base32crockford: BytesCoder = chain(\n  radix2(5),\n  alphabet('0123456789ABCDEFGHJKMNPQRSTVWXYZ'),\n  join(''),\n  normalize((s: string) => s.toUpperCase().replace(/O/g, '0').replace(/[IL]/g, '1'))\n);\n\n// Built-in base64 conversion https://caniuse.com/mdn-javascript_builtins_uint8array_frombase64\n// prettier-ignore\nconst hasBase64Builtin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toBase64 === 'function' &&\n  typeof (Uint8Array as any).fromBase64 === 'function')();\n\nconst decodeBase64Builtin = (s: string, isUrl: boolean) => {\n  astr('base64', s);\n  const re = isUrl ? /^[A-Za-z0-9=_-]+$/ : /^[A-Za-z0-9=+/]+$/;\n  const alphabet = isUrl ? 'base64url' : 'base64';\n  if (s.length > 0 && !re.test(s)) throw new Error('invalid base64');\n  return (Uint8Array as any).fromBase64(s, { alphabet, lastChunkHandling: 'strict' });\n};\n\n/**\n * base64 from RFC 4648. Padded.\n * Use `base64nopad` for unpadded version.\n * Also check out `base64url`, `base64urlnopad`.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64(); },\n  decode(s) { return decodeBase64Builtin(s, false); },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  padding(6),\n  join('')\n);\n/**\n * base64 from RFC 4648. No padding.\n * Use `base64` for padded version.\n * @example\n * ```js\n * base64nopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64nopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64nopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. Padded.\n * Use `base64urlnopad` for unpadded version.\n * Falls back to built-in function, when available.\n * @example\n * ```js\n * base64url.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs='\n * base64url.decode('Eqs=');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\n// prettier-ignore\nexport const base64url: BytesCoder = hasBase64Builtin ? {\n  encode(b) { abytes(b); return (b as any).toBase64({ alphabet: 'base64url' }); },\n  decode(s) { return decodeBase64Builtin(s, true); },\n} : chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  padding(6),\n  join('')\n);\n\n/**\n * base64 from RFC 4648, using URL-safe alphabet. No padding.\n * Use `base64url` for padded version.\n * @example\n * ```js\n * base64urlnopad.encode(Uint8Array.from([0x12, 0xab]));\n * // => 'Eqs'\n * base64urlnopad.decode('Eqs');\n * // => Uint8Array.from([0x12, 0xab])\n * ```\n */\nexport const base64urlnopad: BytesCoder = chain(\n  radix2(6),\n  alphabet('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'),\n  join('')\n);\n\n// base58 code\n// -----------\nconst genBase58 = /* @__NO_SIDE_EFFECTS__ */ (abc: string) =>\n  chain(radix(58), alphabet(abc), join(''));\n\n/**\n * base58: base64 without ambigous characters +, /, 0, O, I, l.\n * Quadratic (O(n^2)) - so, can't be used on large inputs.\n * @example\n * ```js\n * base58.decode('01abcdef');\n * // => '3UhJW'\n * ```\n */\nexport const base58: BytesCoder = genBase58(\n  '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n);\n/**\n * base58: flickr version. Check out `base58`.\n */\nexport const base58flickr: BytesCoder = genBase58(\n  '123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'\n);\n/**\n * base58: XRP version. Check out `base58`.\n */\nexport const base58xrp: BytesCoder = genBase58(\n  'rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz'\n);\n\n// Data len (index) -> encoded block len\nconst XMR_BLOCK_LEN = [0, 2, 3, 5, 6, 7, 9, 10, 11];\n\n/**\n * base58: XMR version. Check out `base58`.\n * Done in 8-byte blocks (which equals 11 chars in decoding). Last (non-full) block padded with '1' to size in XMR_BLOCK_LEN.\n * Block encoding significantly reduces quadratic complexity of base58.\n */\nexport const base58xmr: BytesCoder = {\n  encode(data: Uint8Array) {\n    let res = '';\n    for (let i = 0; i < data.length; i += 8) {\n      const block = data.subarray(i, i + 8);\n      res += base58.encode(block).padStart(XMR_BLOCK_LEN[block.length]!, '1');\n    }\n    return res;\n  },\n  decode(str: string) {\n    let res: number[] = [];\n    for (let i = 0; i < str.length; i += 11) {\n      const slice = str.slice(i, i + 11);\n      const blockLen = XMR_BLOCK_LEN.indexOf(slice.length);\n      const block = base58.decode(slice);\n      for (let j = 0; j < block.length - blockLen; j++) {\n        if (block[j] !== 0) throw new Error('base58xmr: wrong padding');\n      }\n      res = res.concat(Array.from(block.slice(block.length - blockLen)));\n    }\n    return Uint8Array.from(res);\n  },\n};\n\n/**\n * Method, which creates base58check encoder.\n * Requires function, calculating sha256.\n */\nexport const createBase58check = (sha256: (data: Uint8Array) => Uint8Array): BytesCoder =>\n  chain(\n    checksum(4, (data) => sha256(sha256(data))),\n    base58\n  );\n\n/**\n * Use `createBase58check` instead.\n * @deprecated\n */\nexport const base58check: (sha256: (data: Uint8Array) => Uint8Array) => BytesCoder =\n  createBase58check;\n\n// Bech32 code\n// -----------\nexport interface Bech32Decoded<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n}\nexport interface Bech32DecodedWithArray<Prefix extends string = string> {\n  prefix: Prefix;\n  words: number[];\n  bytes: Uint8Array;\n}\n\nconst BECH_ALPHABET: Coder<number[], string> = chain(\n  alphabet('qpzry9x8gf2tvdw0s3jn54khce6mua7l'),\n  join('')\n);\n\nconst POLYMOD_GENERATORS = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\nfunction bech32Polymod(pre: number): number {\n  const b = pre >> 25;\n  let chk = (pre & 0x1ffffff) << 5;\n  for (let i = 0; i < POLYMOD_GENERATORS.length; i++) {\n    if (((b >> i) & 1) === 1) chk ^= POLYMOD_GENERATORS[i]!;\n  }\n  return chk;\n}\n\nfunction bechChecksum(prefix: string, words: number[], encodingConst = 1): string {\n  const len = prefix.length;\n  let chk = 1;\n  for (let i = 0; i < len; i++) {\n    const c = prefix.charCodeAt(i);\n    if (c < 33 || c > 126) throw new Error(`Invalid prefix (${prefix})`);\n    chk = bech32Polymod(chk) ^ (c >> 5);\n  }\n  chk = bech32Polymod(chk);\n  for (let i = 0; i < len; i++) chk = bech32Polymod(chk) ^ (prefix.charCodeAt(i) & 0x1f);\n  for (let v of words) chk = bech32Polymod(chk) ^ v;\n  for (let i = 0; i < 6; i++) chk = bech32Polymod(chk);\n  chk ^= encodingConst;\n  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]!], 30, 5, false));\n}\n\nexport interface Bech32 {\n  encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit?: number | false\n  ): `${Lowercase<Prefix>}1${string}`;\n  decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  encodeFromBytes(prefix: string, bytes: Uint8Array): string;\n  decodeToBytes(str: string): Bech32DecodedWithArray;\n  decodeUnsafe(str: string, limit?: number | false): void | Bech32Decoded<string>;\n  fromWords(to: number[]): Uint8Array;\n  fromWordsUnsafe(to: number[]): void | Uint8Array;\n  toWords(from: Uint8Array): number[];\n}\n/**\n * @__NO_SIDE_EFFECTS__\n */\nfunction genBech32(encoding: 'bech32' | 'bech32m'): Bech32 {\n  const ENCODING_CONST = encoding === 'bech32' ? 1 : 0x2bc830a3;\n  const _words = radix2(5);\n  const fromWords = _words.decode;\n  const toWords = _words.encode;\n  const fromWordsUnsafe = unsafeWrapper(fromWords);\n\n  function encode<Prefix extends string>(\n    prefix: Prefix,\n    words: number[] | Uint8Array,\n    limit: number | false = 90\n  ): `${Lowercase<Prefix>}1${string}` {\n    astr('bech32.encode prefix', prefix);\n    if (isBytes(words)) words = Array.from(words);\n    anumArr('bech32.encode', words);\n    const plen = prefix.length;\n    if (plen === 0) throw new TypeError(`Invalid prefix length ${plen}`);\n    const actualLength = plen + 7 + words.length;\n    if (limit !== false && actualLength > limit)\n      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);\n    const lowered = prefix.toLowerCase();\n    const sum = bechChecksum(lowered, words, ENCODING_CONST);\n    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}` as `${Lowercase<Prefix>}1${string}`;\n  }\n\n  function decode<Prefix extends string>(\n    str: `${Prefix}1${string}`,\n    limit?: number | false\n  ): Bech32Decoded<Prefix>;\n  function decode(str: string, limit?: number | false): Bech32Decoded;\n  function decode(str: string, limit: number | false = 90): Bech32Decoded {\n    astr('bech32.decode input', str);\n    const slen = str.length;\n    if (slen < 8 || (limit !== false && slen > limit))\n      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);\n    // don't allow mixed case\n    const lowered = str.toLowerCase();\n    if (str !== lowered && str !== str.toUpperCase())\n      throw new Error(`String must be lowercase or uppercase`);\n    const sepIndex = lowered.lastIndexOf('1');\n    if (sepIndex === 0 || sepIndex === -1)\n      throw new Error(`Letter \"1\" must be present between prefix and data only`);\n    const prefix = lowered.slice(0, sepIndex);\n    const data = lowered.slice(sepIndex + 1);\n    if (data.length < 6) throw new Error('Data must be at least 6 characters long');\n    const words = BECH_ALPHABET.decode(data).slice(0, -6);\n    const sum = bechChecksum(prefix, words, ENCODING_CONST);\n    if (!data.endsWith(sum)) throw new Error(`Invalid checksum in ${str}: expected \"${sum}\"`);\n    return { prefix, words };\n  }\n\n  const decodeUnsafe = unsafeWrapper(decode);\n\n  function decodeToBytes(str: string): Bech32DecodedWithArray {\n    const { prefix, words } = decode(str, false);\n    return { prefix, words, bytes: fromWords(words) };\n  }\n\n  function encodeFromBytes(prefix: string, bytes: Uint8Array) {\n    return encode(prefix, toWords(bytes));\n  }\n\n  return {\n    encode,\n    decode,\n    encodeFromBytes,\n    decodeToBytes,\n    decodeUnsafe,\n    fromWords,\n    fromWordsUnsafe,\n    toWords,\n  };\n}\n\n/**\n * bech32 from BIP 173. Operates on words.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32: Bech32 = genBech32('bech32');\n\n/**\n * bech32m from BIP 350. Operates on words.\n * It was to mitigate `bech32` weaknesses.\n * For high-level, check out scure-btc-signer:\n * https://github.com/paulmillr/scure-btc-signer.\n */\nexport const bech32m: Bech32 = genBech32('bech32m');\n\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * UTF-8-to-byte decoder. Uses built-in TextDecoder / TextEncoder.\n * @example\n * ```js\n * const b = utf8.decode(\"hey\"); // => new Uint8Array([ 104, 101, 121 ])\n * const str = utf8.encode(b); // \"hey\"\n * ```\n */\nexport const utf8: BytesCoder = {\n  encode: (data) => new TextDecoder().decode(data),\n  decode: (str) => new TextEncoder().encode(str),\n};\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\n// prettier-ignore\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  typeof (Uint8Array as any).from([]).toHex === 'function' &&\n  typeof (Uint8Array as any).fromHex === 'function')();\n// prettier-ignore\nconst hexBuiltin: BytesCoder = {\n  encode(data) { abytes(data); return (data as any).toHex(); },\n  decode(s) { astr('hex', s); return (Uint8Array as any).fromHex(s); },\n};\n/**\n * hex string decoder. Uses built-in function, when available.\n * @example\n * ```js\n * const b = hex.decode(\"0102ff\"); // => new Uint8Array([ 1, 2, 255 ])\n * const str = hex.encode(b); // \"0102ff\"\n * ```\n */\nexport const hex: BytesCoder = hasHexBuiltin\n  ? hexBuiltin\n  : chain(\n      radix2(4),\n      alphabet('0123456789abcdef'),\n      join(''),\n      normalize((s: string) => {\n        if (typeof s !== 'string' || s.length % 2 !== 0)\n          throw new TypeError(\n            `hex.decode: expected string, got ${typeof s} with length ${s.length}`\n          );\n        return s.toLowerCase();\n      })\n    );\n\nexport type SomeCoders = {\n  utf8: BytesCoder;\n  hex: BytesCoder;\n  base16: BytesCoder;\n  base32: BytesCoder;\n  base64: BytesCoder;\n  base64url: BytesCoder;\n  base58: BytesCoder;\n  base58xmr: BytesCoder;\n};\n// prettier-ignore\nconst CODERS: SomeCoders = {\n  utf8, hex, base16, base32, base64, base64url, base58, base58xmr\n};\ntype CoderType = keyof SomeCoders;\nconst coderTypeError =\n  'Invalid encoding type. Available types: utf8, hex, base16, base32, base64, base64url, base58, base58xmr';\n\n/** @deprecated */\nexport const bytesToString = (type: CoderType, bytes: Uint8Array): string => {\n  if (typeof type !== 'string' || !CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (!isBytes(bytes)) throw new TypeError('bytesToString() expects Uint8Array');\n  return CODERS[type].encode(bytes);\n};\n\n/** @deprecated */\nexport const str: (type: CoderType, bytes: Uint8Array) => string = bytesToString; // as in python, but for bytes only\n\n/** @deprecated */\nexport const stringToBytes = (type: CoderType, str: string): Uint8Array => {\n  if (!CODERS.hasOwnProperty(type)) throw new TypeError(coderTypeError);\n  if (typeof str !== 'string') throw new TypeError('stringToBytes() expects string');\n  return CODERS[type].decode(str);\n};\n/** @deprecated */\nexport const bytes: (type: CoderType, str: string) => Uint8Array = stringToBytes;\n","/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { aexists, aoutput } from './_assert.js';\nimport { type Input, Hash, createView, toBytes } from './utils.js';\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(\n    readonly blockLen: number,\n    public outputLen: number,\n    readonly padOffset: number,\n    readonly isLE: boolean\n  ) {\n    super();\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    this.buffer.subarray(pos).fill(0);\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n}\n","import {\n  bytesToHex as nobleBytesToHex,\n  randomBytes as nobleRandomBytes,\n} from '@noble/hashes/utils'\nimport type {\n  BytesToHexFn,\n  HexToBytesFn,\n  HexToStringFn,\n  RandomBytesFn,\n  StringToHexFn,\n} from './types'\nimport { HEX_REGEX } from './shared'\n\n/* eslint-disable func-style -- Typed to ensure uniformity between node and browser implementations and docs */\nexport const bytesToHex: typeof BytesToHexFn = (bytes) => {\n  const hex = nobleBytesToHex(\n    bytes instanceof Uint8Array ? bytes : Uint8Array.from(bytes),\n  )\n  return hex.toUpperCase()\n}\n\n// A clone of hexToBytes from @noble/hashes without the length checks. This allows us to do our own checks.\nexport const hexToBytes: typeof HexToBytesFn = (hex): Uint8Array => {\n  const len = hex.length\n  const array = new Uint8Array(len / 2)\n  if (!HEX_REGEX.test(hex)) {\n    throw new Error('Invalid hex string')\n  }\n  for (let i = 0; i < array.length; i++) {\n    const j = i * 2\n    const hexByte = hex.slice(j, j + 2)\n    const byte = Number.parseInt(hexByte, 16)\n    if (Number.isNaN(byte) || byte < 0) {\n      throw new Error('Invalid byte sequence')\n    }\n    array[i] = byte\n  }\n  return array\n}\n\nexport const hexToString: typeof HexToStringFn = (\n  hex: string,\n  encoding = 'utf8',\n): string => {\n  return new TextDecoder(encoding).decode(hexToBytes(hex))\n}\n\nexport const stringToHex: typeof StringToHexFn = (string: string): string => {\n  return bytesToHex(new TextEncoder().encode(string))\n}\n/* eslint-enable func-style */\n\nexport const randomBytes: typeof RandomBytesFn = nobleRandomBytes\nexport * from './shared'\n","import { CHash } from '@noble/hashes/utils'\nimport { Hash, HashFn, Input } from './types'\nimport normalizeInput from './normalizeInput'\n\n/**\n * Wrap a CHash object from @noble/hashes to provide a interface that is isomorphic\n *\n * @param chash - {CHash} hash function to wrap\n */\nexport default function wrapNoble(chash: CHash): HashFn {\n  function wrapped(input: Input): Uint8Array {\n    return chash(normalizeInput(input))\n  }\n\n  wrapped.create = (): Hash => {\n    const hash = chash.create()\n    return {\n      update(input: Input): Hash {\n        hash.update(normalizeInput(input))\n        return this\n      },\n      digest(): Uint8Array {\n        return hash.digest()\n      },\n    }\n  }\n  return wrapped\n}\n","/**\n * Utilities for short weierstrass curves, combined with noble-hashes.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { hmac } from '@noble/hashes/hmac';\nimport { concatBytes, randomBytes } from '@noble/hashes/utils';\nimport type { CHash } from './abstract/utils.js';\nimport { type CurveFn, type CurveType, weierstrass } from './abstract/weierstrass.js';\n\n/** connects noble-curves to noble-hashes */\nexport function getHash(hash: CHash): {\n  hash: CHash;\n  hmac: (key: Uint8Array, ...msgs: Uint8Array[]) => Uint8Array;\n  randomBytes: typeof randomBytes;\n} {\n  return {\n    hash,\n    hmac: (key: Uint8Array, ...msgs: Uint8Array[]) => hmac(hash, key, concatBytes(...msgs)),\n    randomBytes,\n  };\n}\n/** Same API as @noble/hashes, with ability to create curve with custom hash */\nexport type CurveDef = Readonly<Omit<CurveType, 'hash' | 'hmac' | 'randomBytes'>>;\nexport type CurveFnWithCreate = CurveFn & { create: (hash: CHash) => CurveFn };\n\nexport function createCurve(curveDef: CurveDef, defHash: CHash): CurveFnWithCreate {\n  const create = (hash: CHash): CurveFn => weierstrass({ ...curveDef, ...getHash(hash) });\n  return { ...create(defHash), create };\n}\n","import { ripemd160 as nobleImpl } from '@noble/hashes/ripemd160'\n\nimport wrapNoble from '../internal/wrapNoble'\n\n/**\n * Wrap noble-libs's ripemd160 implementation in HashFn\n */\nexport const ripemd160 = wrapNoble(nobleImpl)\n","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","export * from './schema/Account'\nexport * from './utils'\n","import {\n  bytesToHex,\n  concat,\n  hexToBytes,\n  randomBytes,\n} from '@xrplf/isomorphic/utils'\n\nfunction randomEntropy(): Uint8Array {\n  return randomBytes(16)\n}\n\nfunction calculateChecksum(position: number, value: number): number {\n  return (value * (position * 2 + 1)) % 9\n}\n\nfunction checkChecksum(\n  position: number,\n  value: number | string,\n  checksum?: number,\n): boolean {\n  let normalizedChecksum: number\n  let normalizedValue: number\n\n  if (typeof value === 'string') {\n    if (value.length !== 6) {\n      throw new Error('value must have a length of 6')\n    }\n    normalizedChecksum = parseInt(value.slice(5), 10)\n    normalizedValue = parseInt(value.slice(0, 5), 10)\n  } else {\n    if (typeof checksum !== 'number') {\n      throw new Error('checksum must be a number when value is a number')\n    }\n    normalizedChecksum = checksum\n    normalizedValue = value\n  }\n  return (normalizedValue * (position * 2 + 1)) % 9 === normalizedChecksum\n}\n\nfunction entropyToSecret(entropy: Uint8Array): string[] {\n  const len = new Array(Math.ceil(entropy.length / 2))\n  const chunks = Array.from(len, (_a, chunk) => {\n    const buffChunk = entropy.slice(chunk * 2, (chunk + 1) * 2)\n    const no = parseInt(bytesToHex(buffChunk), 16)\n    const fill = '0'.repeat(5 - String(no).length)\n    return fill + String(no) + String(calculateChecksum(chunk, no))\n  })\n  if (chunks.length !== 8) {\n    throw new Error('Chucks must have 8 digits')\n  }\n  return chunks\n}\n\nfunction randomSecret(): string[] {\n  return entropyToSecret(randomEntropy())\n}\n\nfunction secretToEntropy(secret: string[]): Uint8Array {\n  return concat(\n    secret.map((chunk, i) => {\n      const no = Number(chunk.slice(0, 5))\n      const checksum = Number(chunk.slice(5))\n      if (chunk.length !== 6) {\n        throw new Error('Invalid secret: number invalid')\n      }\n      if (!checkChecksum(i, no, checksum)) {\n        throw new Error('Invalid secret part: checksum invalid')\n      }\n      const hex = `0000${no.toString(16)}`.slice(-4)\n      return hexToBytes(hex)\n    }),\n  )\n}\n\nfunction parseSecretString(secret: string): string[] {\n  const normalizedSecret = secret.replace(/[^0-9]/gu, '')\n  if (normalizedSecret.length !== 48) {\n    throw new Error(\n      'Invalid secret string (should contain 8 blocks of 6 digits',\n    )\n  }\n  return Array.from(new Array(8), (_a, index) => {\n    return normalizedSecret.slice(index * 6, (index + 1) * 6)\n  })\n}\n\nexport {\n  randomEntropy,\n  randomSecret,\n  entropyToSecret,\n  secretToEntropy,\n  calculateChecksum,\n  checkChecksum,\n  parseSecretString,\n}\n","/**\n * SHA2-512 a.k.a. sha512 and sha384. It is slower than sha256 in js because u64 operations are slow.\n *\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [the paper on truncated SHA512/256](https://eprint.iacr.org/2010/548.pdf).\n * @module\n */\nimport { HashMD } from './_md.js';\nimport u64 from './_u64.js';\nimport { type CHash, wrapConstructor } from './utils.js';\n\n// Round contants (first 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409):\n// prettier-ignore\nconst [SHA512_Kh, SHA512_Kl] = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\n\n// Temporary buffer, not used to store anything between runs\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\nexport class SHA512 extends HashMD<SHA512> {\n  // We cannot use array here since array allows indexing by variable which means optimizer/compiler cannot use registers.\n  // Also looks cleaner and easier to verify with spec.\n  // Initial state (first 32 bits of the fractional parts of the square roots of the first 8 primes 2..19):\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = 0x6a09e667 | 0;\n  protected Al: number = 0xf3bcc908 | 0;\n  protected Bh: number = 0xbb67ae85 | 0;\n  protected Bl: number = 0x84caa73b | 0;\n  protected Ch: number = 0x3c6ef372 | 0;\n  protected Cl: number = 0xfe94f82b | 0;\n  protected Dh: number = 0xa54ff53a | 0;\n  protected Dl: number = 0x5f1d36f1 | 0;\n  protected Eh: number = 0x510e527f | 0;\n  protected El: number = 0xade682d1 | 0;\n  protected Fh: number = 0x9b05688c | 0;\n  protected Fl: number = 0x2b3e6c1f | 0;\n  protected Gh: number = 0x1f83d9ab | 0;\n  protected Gl: number = 0xfb41bd6b | 0;\n  protected Hh: number = 0x5be0cd19 | 0;\n  protected Hl: number = 0x137e2179 | 0;\n\n  constructor() {\n    super(128, 64, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ): void {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean(): void {\n    SHA512_W_H.fill(0);\n    SHA512_W_L.fill(0);\n  }\n  destroy(): void {\n    this.buffer.fill(0);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nexport class SHA512_224 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = 0x8c3d37c8 | 0;\n  protected Al: number = 0x19544da2 | 0;\n  protected Bh: number = 0x73e19966 | 0;\n  protected Bl: number = 0x89dcd4d6 | 0;\n  protected Ch: number = 0x1dfab7ae | 0;\n  protected Cl: number = 0x32ff9c82 | 0;\n  protected Dh: number = 0x679dd514 | 0;\n  protected Dl: number = 0x582f9fcf | 0;\n  protected Eh: number = 0x0f6d2b69 | 0;\n  protected El: number = 0x7bd44da8 | 0;\n  protected Fh: number = 0x77e36f73 | 0;\n  protected Fl: number = 0x04c48942 | 0;\n  protected Gh: number = 0x3f9d85a8 | 0;\n  protected Gl: number = 0x6a1d36c8 | 0;\n  protected Hh: number = 0x1112e6ad | 0;\n  protected Hl: number = 0x91d692a1 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\nexport class SHA512_256 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = 0x22312194 | 0;\n  protected Al: number = 0xfc2bf72c | 0;\n  protected Bh: number = 0x9f555fa3 | 0;\n  protected Bl: number = 0xc84c64c2 | 0;\n  protected Ch: number = 0x2393b86b | 0;\n  protected Cl: number = 0x6f53b151 | 0;\n  protected Dh: number = 0x96387719 | 0;\n  protected Dl: number = 0x5940eabd | 0;\n  protected Eh: number = 0x96283ee2 | 0;\n  protected El: number = 0xa88effe3 | 0;\n  protected Fh: number = 0xbe5e1e25 | 0;\n  protected Fl: number = 0x53863992 | 0;\n  protected Gh: number = 0x2b0199fc | 0;\n  protected Gl: number = 0x2c85b8aa | 0;\n  protected Hh: number = 0x0eb72ddc | 0;\n  protected Hl: number = 0x81c52ca2 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 32;\n  }\n}\n\nexport class SHA384 extends SHA512 {\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = 0xcbbb9d5d | 0;\n  protected Al: number = 0xc1059ed8 | 0;\n  protected Bh: number = 0x629a292a | 0;\n  protected Bl: number = 0x367cd507 | 0;\n  protected Ch: number = 0x9159015a | 0;\n  protected Cl: number = 0x3070dd17 | 0;\n  protected Dh: number = 0x152fecd8 | 0;\n  protected Dl: number = 0xf70e5939 | 0;\n  protected Eh: number = 0x67332667 | 0;\n  protected El: number = 0xffc00b31 | 0;\n  protected Fh: number = 0x8eb44a87 | 0;\n  protected Fl: number = 0x68581511 | 0;\n  protected Gh: number = 0xdb0c2e0d | 0;\n  protected Gl: number = 0x64f98fa7 | 0;\n  protected Hh: number = 0x47b5481d | 0;\n  protected Hl: number = 0xbefa4fa4 | 0;\n\n  constructor() {\n    super();\n    this.outputLen = 48;\n  }\n}\n\n/** SHA2-512 hash function. */\nexport const sha512: CHash = /* @__PURE__ */ wrapConstructor(() => new SHA512());\n/** SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks. */\nexport const sha512_224: CHash = /* @__PURE__ */ wrapConstructor(() => new SHA512_224());\n/** SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks. */\nexport const sha512_256: CHash = /* @__PURE__ */ wrapConstructor(() => new SHA512_256());\n/** SHA2-384 hash function. */\nexport const sha384: CHash = /* @__PURE__ */ wrapConstructor(() => new SHA384());\n","/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { mod, pow } from './modular.js';\nimport {\n  aInRange,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesLE,\n  validateObject,\n} from './utils.js';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\ntype Hex = string | Uint8Array;\n\nexport type CurveType = {\n  P: bigint; // finite field prime\n  nByteLength: number;\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array;\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array;\n  a: bigint;\n  montgomeryBits: number;\n  powPminus2?: (x: bigint) => bigint;\n  xyToU?: (x: bigint, y: bigint) => bigint;\n  Gu: bigint;\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n};\n\nexport type CurveFn = {\n  scalarMult: (scalar: Hex, u: Hex) => Uint8Array;\n  scalarMultBase: (scalar: Hex) => Uint8Array;\n  getSharedSecret: (privateKeyA: Hex, publicKeyB: Hex) => Uint8Array;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  utils: { randomPrivateKey: () => Uint8Array };\n  GuBytes: Uint8Array;\n};\n\nfunction validateOpts(curve: CurveType) {\n  validateObject(\n    curve,\n    {\n      a: 'bigint',\n    },\n    {\n      montgomeryBits: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n      adjustScalarBytes: 'function',\n      domain: 'function',\n      powPminus2: 'function',\n      Gu: 'bigint',\n    }\n  );\n  // Set defaults\n  return Object.freeze({ ...curve } as const);\n}\n\n// Uses only one coordinate instead of two\nexport function montgomery(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef);\n  const { P } = CURVE;\n  const modP = (n: bigint) => mod(n, P);\n  const montgomeryBits = CURVE.montgomeryBits;\n  const montgomeryBytes = Math.ceil(montgomeryBits / 8);\n  const fieldLen = CURVE.nByteLength;\n  const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes: Uint8Array) => bytes);\n  const powPminus2 = CURVE.powPminus2 || ((x: bigint) => pow(x, P - BigInt(2), P));\n\n  // cswap from RFC7748. But it is not from RFC7748!\n  /*\n    cswap(swap, x_2, x_3):\n         dummy = mask(swap) AND (x_2 XOR x_3)\n         x_2 = x_2 XOR dummy\n         x_3 = x_3 XOR dummy\n         Return (x_2, x_3)\n  Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n   and x_3, computed, e.g., as mask(swap) = 0 - swap.\n  */\n  function cswap(swap: bigint, x_2: bigint, x_3: bigint): [bigint, bigint] {\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy);\n    x_3 = modP(x_3 + dummy);\n    return [x_2, x_3];\n  }\n\n  // x25519 from 4\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519\n  const a24 = (CURVE.a - BigInt(2)) / BigInt(4);\n  /**\n   *\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(u: bigint, scalar: bigint): bigint {\n    aInRange('u', u, _0n, P);\n    aInRange('scalar', scalar, _0n, P);\n    // Section 5: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.\n    const k = scalar;\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    let sw: [bigint, bigint];\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      const k_t = (k >> t) & _1n;\n      swap ^= k_t;\n      sw = cswap(swap, x_2, x_3);\n      x_2 = sw[0];\n      x_3 = sw[1];\n      sw = cswap(swap, z_2, z_3);\n      z_2 = sw[0];\n      z_3 = sw[1];\n      swap = k_t;\n\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    // (x_2, x_3) = cswap(swap, x_2, x_3)\n    sw = cswap(swap, x_2, x_3);\n    x_2 = sw[0];\n    x_3 = sw[1];\n    // (z_2, z_3) = cswap(swap, z_2, z_3)\n    sw = cswap(swap, z_2, z_3);\n    z_2 = sw[0];\n    z_3 = sw[1];\n    // z_2^(p - 2)\n    const z2 = powPminus2(z_2);\n    // Return x_2 * (z_2^(p - 2))\n    return modP(x_2 * z2);\n  }\n\n  function encodeUCoordinate(u: bigint): Uint8Array {\n    return numberToBytesLE(modP(u), montgomeryBytes);\n  }\n\n  function decodeUCoordinate(uEnc: Hex): bigint {\n    // Section 5: When receiving such an array, implementations of X25519\n    // MUST mask the most significant bit in the final byte.\n    const u = ensureBytes('u coordinate', uEnc, montgomeryBytes);\n    if (fieldLen === 32) u[31] &= 127; // 0b0111_1111\n    return bytesToNumberLE(u);\n  }\n  function decodeScalar(n: Hex): bigint {\n    const bytes = ensureBytes('scalar', n);\n    const len = bytes.length;\n    if (len !== montgomeryBytes && len !== fieldLen) {\n      let valid = '' + montgomeryBytes + ' or ' + fieldLen;\n      throw new Error('invalid scalar, expected ' + valid + ' bytes, got ' + len);\n    }\n    return bytesToNumberLE(adjustScalarBytes(bytes));\n  }\n  function scalarMult(scalar: Hex, u: Hex): Uint8Array {\n    const pointU = decodeUCoordinate(u);\n    const _scalar = decodeScalar(scalar);\n    const pu = montgomeryLadder(pointU, _scalar);\n    // The result was not contributory\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('invalid private or public key received');\n    return encodeUCoordinate(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  const GuBytes = encodeUCoordinate(CURVE.Gu);\n  function scalarMultBase(scalar: Hex): Uint8Array {\n    return scalarMult(scalar, GuBytes);\n  }\n\n  return {\n    scalarMult,\n    scalarMultBase,\n    getSharedSecret: (privateKey: Hex, publicKey: Hex) => scalarMult(privateKey, publicKey),\n    getPublicKey: (privateKey: Hex): Uint8Array => scalarMultBase(privateKey),\n    utils: { randomPrivateKey: () => CURVE.randomBytes!(CURVE.nByteLength) },\n    GuBytes: GuBytes,\n  };\n}\n","import type { Algorithm, HexString, KeyType } from '../types'\n\nenum Prefix {\n  NONE = -1,\n  ED25519 = 0xed,\n  SECP256K1_PUB_X = 0x02,\n  SECP256K1_PUB_X_ODD_Y = 0x03,\n  SECP256K1_PUB_XY = 0x04,\n  SECP256K1_PRIVATE = 0x00,\n}\n\ntype CompositeKey = `${KeyType}_${Prefix}_${number}`\n\n/**\n * | Curve     | Type        | Prefix | Length | Description                                           | Algorithm       |\n * |-----------|-------------|:------:|:------:|-------------------------------------------------------|----------------:|\n * | ed25519   | Private     |  0xED  |   33   | prefix + Uint256LE (0 < n < order )                   |         ed25519 |\n * | ed25519   | Public      |  0xED  |   33   | prefix + 32 y-bytes                                   |         ed25519 |\n * | secp256k1 | Public (1)  |  0x02  |   33   | prefix + 32 x-bytes                                   | ecdsa-secp256k1 |\n * | secp256k1 | Public (2)  |  0x03  |   33   | prefix + 32 x-bytes (y is odd)                        | ecdsa-secp256k1 |\n * | secp256k1 | Public (3)  |  0x04  |   65   | prefix + 32 x-bytes + 32 y-bytes                      | ecdsa-secp256k1 |\n * | secp256k1 | Private (1) |  None  |   32   | Uint256BE (0 < n < order)                             | ecdsa-secp256k1 |\n * | secp256k1 | Private (2) |  0x00  |   33   | prefix + Uint256BE (0 < n < order)                    | ecdsa-secp256k1 |\n *\n * Note: The 0x00 prefix for secpk256k1 Private (2) essentially 0 pads the number\n *       and the interpreted number is the same as 32 bytes.\n */\nconst KEY_TYPES: Record<CompositeKey, Algorithm> = {\n  [`private_${Prefix.NONE}_32`]: 'ecdsa-secp256k1',\n  [`private_${Prefix.SECP256K1_PRIVATE}_33`]: 'ecdsa-secp256k1',\n  [`private_${Prefix.ED25519}_33`]: 'ed25519',\n  [`public_${Prefix.ED25519}_33`]: 'ed25519',\n  [`public_${Prefix.SECP256K1_PUB_X}_33`]: 'ecdsa-secp256k1',\n  [`public_${Prefix.SECP256K1_PUB_X_ODD_Y}_33`]: 'ecdsa-secp256k1',\n  [`public_${Prefix.SECP256K1_PUB_XY}_65`]: 'ecdsa-secp256k1',\n}\n\nfunction getKeyInfo(key: HexString) {\n  return {\n    prefix: key.length < 2 ? Prefix.NONE : parseInt(key.slice(0, 2), 16),\n    len: key.length / 2,\n  }\n}\n\nfunction prefixRepr(prefix: Prefix): string {\n  return prefix === Prefix.NONE\n    ? 'None'\n    : `0x${prefix.toString(16).padStart(2, '0')}`\n}\n\nfunction getValidFormatsTable(type: KeyType) {\n  // No need overkill with renderTable method\n  const padding = 2\n  const colWidth = {\n    algorithm: 'ecdsa-secp256k1'.length + padding,\n    prefix: '0x00'.length + padding,\n  }\n\n  return Object.entries(KEY_TYPES)\n    .filter(([key]) => key.startsWith(type))\n    .map(([key, algorithm]) => {\n      const [, prefix, length] = key.split('_')\n      const paddedAlgo = algorithm.padEnd(colWidth.algorithm)\n      const paddedPrefix = prefixRepr(Number(prefix)).padEnd(colWidth.prefix)\n      return `${paddedAlgo} - Prefix: ${paddedPrefix} Length: ${length} bytes`\n    })\n    .join('\\n')\n}\n\nfunction keyError({\n  key,\n  type,\n  prefix,\n  len,\n}: {\n  key: string\n  type: KeyType\n  prefix: number\n  len: number\n}) {\n  const validFormats = getValidFormatsTable(type)\n\n  return `invalid_key:\n\nType: ${type}\nKey: ${key}\nPrefix: ${prefixRepr(prefix)} \nLength: ${len} bytes\n\nAcceptable ${type} formats are:\n${validFormats}\n`\n}\n\n/**\n * Determines the algorithm associated with a given key (public/private).\n *\n * @param key - hexadecimal string representation of the key.\n * @param type - whether expected key is public or private\n * @returns Algorithm algorithm for signing/verifying\n * @throws Error when key is invalid\n */\nexport function getAlgorithmFromKey(key: HexString, type: KeyType): Algorithm {\n  const { prefix, len } = getKeyInfo(key)\n  // Special case back compat support for no prefix\n  const usedPrefix = type === 'private' && len === 32 ? Prefix.NONE : prefix\n  const algorithm = KEY_TYPES[`${type}_${usedPrefix}_${len}`]\n\n  if (!algorithm) {\n    throw new Error(keyError({ key, type, len, prefix: usedPrefix }))\n  }\n  return algorithm\n}\n\nexport function getAlgorithmFromPublicKey(key: HexString): Algorithm {\n  return getAlgorithmFromKey(key, 'public')\n}\n\nexport function getAlgorithmFromPrivateKey(key: HexString): Algorithm {\n  return getAlgorithmFromKey(key, 'private')\n}\n","/**\n * HMAC: RFC2104 message authentication code.\n * @module\n */\nimport { abytes, aexists, ahash } from './_assert.js';\nimport { Hash, toBytes, type CHash, type Input } from './utils.js';\n\nexport class HMAC<T extends Hash<T>> extends Hash<HMAC<T>> {\n  oHash: T;\n  iHash: T;\n  blockLen: number;\n  outputLen: number;\n  private finished = false;\n  private destroyed = false;\n\n  constructor(hash: CHash, _key: Input) {\n    super();\n    ahash(hash);\n    const key = toBytes(_key);\n    this.iHash = hash.create() as T;\n    if (typeof this.iHash.update !== 'function')\n      throw new Error('Expected instance of class which extends utils.Hash');\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    // blockLen can be bigger than outputLen\n    pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36;\n    this.iHash.update(pad);\n    // By doing update (processing of first block) of outer hash here we can re-use it between multiple calls via clone\n    this.oHash = hash.create() as T;\n    // Undo internal XOR && apply outer XOR\n    for (let i = 0; i < pad.length; i++) pad[i] ^= 0x36 ^ 0x5c;\n    this.oHash.update(pad);\n    pad.fill(0);\n  }\n  update(buf: Input): this {\n    aexists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    abytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest(): Uint8Array {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to?: HMAC<T>): HMAC<T> {\n    // Create new instance without calling constructor since key already in state and we don't know it.\n    to ||= Object.create(Object.getPrototypeOf(this), {});\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to as this;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  destroy(): void {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n}\n\n/**\n * HMAC: RFC2104 message authentication code.\n * @param hash - function that would be used e.g. sha256\n * @param key - message key\n * @param message - message data\n * @example\n * import { hmac } from '@noble/hashes/hmac';\n * import { sha256 } from '@noble/hashes/sha2';\n * const mac1 = hmac(sha256, 'key', 'message');\n */\nexport const hmac: {\n  (hash: CHash, key: Input, message: Input): Uint8Array;\n  create(hash: CHash, key: Input): HMAC<any>;\n} = (hash: CHash, key: Input, message: Input): Uint8Array =>\n  new HMAC<any>(hash, key).update(message).digest();\nhmac.create = (hash: CHash, key: Input) => new HMAC<any>(hash, key);\n","/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  bitMask,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesBE,\n  numberToBytesLE,\n  validateObject,\n} from './utils.js';\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// prettier-ignore\nconst _9n =/* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @todo use field version && remove\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (modulo <= _0n) throw new Error('invalid modulus');\n  if (modulo === _1n) return _0n;\n  let res = _1n;\n  while (power > _0n) {\n    if (power & _1n) res = (res * num) % modulo;\n    num = (num * num) % modulo;\n    power >>= _1n;\n  }\n  return res;\n}\n\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n) throw new Error('invert: expected non-zero number');\n  if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // Legendre constant: used to calculate Legendre symbol (a | p),\n  // which denotes the value of a^((p-1)/2) (mod p).\n  // (a | p)  1    if a is a square (mod p)\n  // (a | p)  -1   if a is not a square (mod p)\n  // (a | p)  0    if a  0 (mod p)\n  const legendreC = (P - _1n) / _2n;\n\n  let Q: bigint, S: number, Z: bigint;\n  // Step 1: By factoring out powers of 2 from p - 1,\n  // find q and s such that p - 1 = q*(2^s) with q odd\n  for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n\n  // Step 2: Select a non-square z such that (z | p)  -1 and set c  zq\n  for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++) {\n    // Crash instead of infinity loop, we cannot reasonable count until P.\n    if (Z > 1000) throw new Error('Cannot find square root: likely non-prime P');\n  }\n\n  // Fast-path\n  if (S === 1) {\n    const p1div4 = (P + _1n) / _4n;\n    return function tonelliFast<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Slow-path\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    // Step 0: Check that n is indeed a square: (n | p) should not be  -1\n    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');\n    let r = S;\n    // TODO: will fail at Fp2/etc\n    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n    let x = Fp.pow(n, Q1div2); // first guess at the square root\n    let b = Fp.pow(n, Q); // first guess at the fudge factor\n\n    while (!Fp.eql(b, Fp.ONE)) {\n      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n      // Find m such b^(2^m)==1\n      let m = 1;\n      for (let t2 = Fp.sqr(b); m < r; m++) {\n        if (Fp.eql(t2, Fp.ONE)) break;\n        t2 = Fp.sqr(t2); // t2 *= t2\n      }\n      // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n      const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n      g = Fp.sqr(ge); // g = ge * ge\n      x = Fp.mul(x, ge); // x *= ge\n      b = Fp.mul(b, g); // b *= g\n      r = m;\n    }\n    return x;\n  };\n}\n\n/**\n * Square root for a finite field. It will try to check if optimizations are applicable and fall back to 4:\n *\n * 1. P  3 (mod 4)\n * 2. P  5 (mod 8)\n * 3. P  9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // P  3 (mod 4)\n  // n = n^((P+1)/4)\n  if (P % _4n === _3n) {\n    // Not all roots possible!\n    // const ORDER =\n    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    // const NUM = 72057594037927816n;\n    const p1div4 = (P + _1n) / _4n;\n    return function sqrt3mod4<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      // Throw if root**2 != n\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Atkin algorithm for q  5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n  if (P % _8n === _5n) {\n    const c1 = (P - _5n) / _8n;\n    return function sqrt5mod8<T>(Fp: IField<T>, n: T) {\n      const n2 = Fp.mul(n, _2n);\n      const v = Fp.pow(n2, c1);\n      const nv = Fp.mul(n, v);\n      const i = Fp.mul(Fp.mul(nv, _2n), v);\n      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // P  9 (mod 16)\n  if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n  }\n  // Other cases: Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint): boolean =>\n  (mod(num, modulo) & _1n) === _1n;\n\n/** Field is not always over prime: for example, Fp2 has ORDER(q)=p^m. */\nexport interface IField<T> {\n  ORDER: bigint;\n  isLE: boolean;\n  BYTES: number;\n  BITS: number;\n  MASK: bigint;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  // legendre?(num: T): T;\n  pow(lhs: T, power: bigint): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>): IField<T> {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'isSafeInteger',\n    BITS: 'isSafeInteger',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  return validateObject(field, opts);\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(f: IField<T>, num: T, power: bigint): T {\n  // Should have same speed as pow for bigints\n  // TODO: benchmark!\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (power === _0n) return f.ONE;\n  if (power === _1n) return num;\n  let p = f.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = f.mul(p, d);\n    d = f.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch<T>(f: IField<T>, nums: T[]): T[] {\n  const tmp = new Array(nums.length);\n  // Walk from first to last, multiply them by each other MOD p\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = acc;\n    return f.mul(acc, num);\n  }, f.ONE);\n  // Invert last element\n  const inverted = f.inv(lastMultiplied);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = f.mul(acc, tmp[i]);\n    return f.mul(acc, num);\n  }, inverted);\n  return tmp;\n}\n\nexport function FpDiv<T>(f: IField<T>, lhs: T, rhs: T | bigint): T {\n  return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n\n/**\n * Legendre symbol.\n * * (a | p)  1    if a is a square (mod p), quadratic residue\n * * (a | p)  -1   if a is not a square (mod p), quadratic non residue\n * * (a | p)  0    if a  0 (mod p)\n */\nexport function FpLegendre(order: bigint): <T>(f: IField<T>, x: T) => T {\n  const legendreConst = (order - _1n) / _2n; // Integer arithmetic\n  return <T>(f: IField<T>, x: T): T => f.pow(x, legendreConst);\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(f: IField<T>): (x: T) => boolean {\n  const legendre = FpLegendre(f.ORDER);\n  return (x: T): boolean => {\n    const p = legendre(f, x);\n    return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n  };\n}\n\n// CURVE.n lengths\nexport function nLength(\n  n: bigint,\n  nBitLength?: number\n): {\n  nBitLength: number;\n  nByteLength: number;\n} {\n  // Bit size, byte size of CURVE.n\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(\n  ORDER: bigint,\n  bitLen?: number,\n  isLE = false,\n  redef: Partial<IField<bigint>> = {}\n): Readonly<FpField> {\n  if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n  if (BYTES > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n  let sqrtP: ReturnType<typeof FpSqrt>; // cached sqrtP\n  const f: Readonly<FpField> = Object.freeze({\n    ORDER,\n    isLE,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    create: (num) => mod(num, ORDER),\n    isValid: (num) => {\n      if (typeof num !== 'bigint')\n        throw new Error('invalid field element: expected bigint, got ' + typeof num);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: (num) => num === _0n,\n    isOdd: (num) => (num & _1n) === _1n,\n    neg: (num) => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n\n    sqr: (num) => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\n    // Same as above, but doesn't normalize\n    sqrN: (num) => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n\n    inv: (num) => invert(num, ORDER),\n    sqrt:\n      redef.sqrt ||\n      ((n) => {\n        if (!sqrtP) sqrtP = FpSqrt(ORDER);\n        return sqrtP(f, n);\n      }),\n    invertBatch: (lst) => FpInvertBatch(f, lst),\n    // TODO: do we really need constant cmov?\n    // We don't have const-time bigints anyway, so probably will be not very useful\n    cmov: (a, b, c) => (c ? b : a),\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n    fromBytes: (bytes) => {\n      if (bytes.length !== BYTES)\n        throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    },\n  } as FpField);\n  return Object.freeze(f);\n}\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nexport function hashToPrivateScalar(\n  hash: string | Uint8Array,\n  groupOrder: bigint,\n  isLE = false\n): bigint {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n    throw new Error(\n      'hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen\n    );\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n  const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n","/**\n * Twisted Edwards curve. The formula is: ax + y = 1 + dxy.\n * For design rationale of types / exports, see weierstrass module documentation.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  type AffinePoint,\n  type BasicCurve,\n  type Group,\n  type GroupConstructor,\n  pippenger,\n  validateBasic,\n  wNAF,\n} from './curve.js';\nimport { Field, mod } from './modular.js';\nimport * as ut from './utils.js';\nimport { abool, ensureBytes, type FHash, type Hex, memoized } from './utils.js';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\n/** Edwards curves must declare params a & d. */\nexport type CurveType = BasicCurve<bigint> & {\n  a: bigint; // curve param a\n  d: bigint; // curve param d\n  hash: FHash; // Hashing\n  randomBytes: (bytesLength?: number) => Uint8Array; // CSPRNG\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array; // clears bits to get valid field elemtn\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array; // Used for hashing\n  uvRatio?: (u: bigint, v: bigint) => { isValid: boolean; value: bigint }; // Ratio (u/v)\n  prehash?: FHash; // RFC 8032 pre-hashing of messages to sign() / verify()\n  mapToCurve?: (scalar: bigint[]) => AffinePoint<bigint>; // for hash-to-curve standard\n};\n\nexport type CurveTypeWithLength = Readonly<CurveType & { nByteLength: number; nBitLength: number }>;\n\n// verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\nconst VERIFY_DEFAULT = { zip215: true };\n\nfunction validateOpts(curve: CurveType): CurveTypeWithLength {\n  const opts = validateBasic(curve);\n  ut.validateObject(\n    curve,\n    {\n      hash: 'function',\n      a: 'bigint',\n      d: 'bigint',\n      randomBytes: 'function',\n    },\n    {\n      adjustScalarBytes: 'function',\n      domain: 'function',\n      uvRatio: 'function',\n      mapToCurve: 'function',\n    }\n  );\n  // Set defaults\n  return Object.freeze({ ...opts } as const);\n}\n\n/** Instance of Extended Point with coordinates in X, Y, Z, T. */\nexport interface ExtPointType extends Group<ExtPointType> {\n  readonly ex: bigint;\n  readonly ey: bigint;\n  readonly ez: bigint;\n  readonly et: bigint;\n  get x(): bigint;\n  get y(): bigint;\n  assertValidity(): void;\n  multiply(scalar: bigint): ExtPointType;\n  multiplyUnsafe(scalar: bigint): ExtPointType;\n  isSmallOrder(): boolean;\n  isTorsionFree(): boolean;\n  clearCofactor(): ExtPointType;\n  toAffine(iz?: bigint): AffinePoint<bigint>;\n  toRawBytes(isCompressed?: boolean): Uint8Array;\n  toHex(isCompressed?: boolean): string;\n  _setWindowSize(windowSize: number): void;\n}\n/** Static methods of Extended Point with coordinates in X, Y, Z, T. */\nexport interface ExtPointConstructor extends GroupConstructor<ExtPointType> {\n  new (x: bigint, y: bigint, z: bigint, t: bigint): ExtPointType;\n  fromAffine(p: AffinePoint<bigint>): ExtPointType;\n  fromHex(hex: Hex): ExtPointType;\n  fromPrivateKey(privateKey: Hex): ExtPointType;\n  msm(points: ExtPointType[], scalars: bigint[]): ExtPointType;\n}\n\n/**\n * Edwards Curve interface.\n * Main methods: `getPublicKey(priv)`, `sign(msg, priv)`, `verify(sig, msg, pub)`.\n */\nexport type CurveFn = {\n  CURVE: ReturnType<typeof validateOpts>;\n  getPublicKey: (privateKey: Hex) => Uint8Array;\n  sign: (message: Hex, privateKey: Hex, options?: { context?: Hex }) => Uint8Array;\n  verify: (\n    sig: Hex,\n    message: Hex,\n    publicKey: Hex,\n    options?: { context?: Hex; zip215: boolean }\n  ) => boolean;\n  ExtendedPoint: ExtPointConstructor;\n  utils: {\n    randomPrivateKey: () => Uint8Array;\n    getExtendedPublicKey: (key: Hex) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: ExtPointType;\n      pointBytes: Uint8Array;\n    };\n    precompute: (windowSize?: number, point?: ExtPointType) => ExtPointType;\n  };\n};\n\n/**\n * Creates Twisted Edwards curve with EdDSA signatures.\n * @example\n * import { Field } from '@noble/curves/abstract/modular';\n * // Before that, define BigInt-s: a, d, p, n, Gx, Gy, h\n * const curve = twistedEdwards({ a, d, Fp: Field(p), n, Gx, Gy, h })\n */\nexport function twistedEdwards(curveDef: CurveType): CurveFn {\n  const CURVE = validateOpts(curveDef) as ReturnType<typeof validateOpts>;\n  const {\n    Fp,\n    n: CURVE_ORDER,\n    prehash: prehash,\n    hash: cHash,\n    randomBytes,\n    nByteLength,\n    h: cofactor,\n  } = CURVE;\n  // Important:\n  // There are some places where Fp.BYTES is used instead of nByteLength.\n  // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n  // TODO: test and find curves which behave otherwise.\n  const MASK = _2n << (BigInt(nByteLength * 8) - _1n);\n  const modP = Fp.create; // Function overrides\n  const Fn = Field(CURVE.n, CURVE.nBitLength);\n\n  // sqrt(u/v)\n  const uvRatio =\n    CURVE.uvRatio ||\n    ((u: bigint, v: bigint) => {\n      try {\n        return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n };\n      }\n    });\n  const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes: Uint8Array) => bytes); // NOOP\n  const domain =\n    CURVE.domain ||\n    ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => {\n      abool('phflag', phflag);\n      if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n      return data;\n    }); // NOOP\n  // 0 <= n < MASK\n  // Coordinates larger than Fp.ORDER are allowed for zip215\n  function aCoordinate(title: string, n: bigint) {\n    ut.aInRange('coordinate ' + title, n, _0n, MASK);\n  }\n\n  function assertPoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Converts Extended point to default (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  const toAffineMemo = memoized((p: Point, iz?: bigint): AffinePoint<bigint> => {\n    const { ex: x, ey: y, ez: z } = p;\n    const is0 = p.is0();\n    if (iz == null) iz = is0 ? _8n : (Fp.inv(z) as bigint); // 8 was chosen arbitrarily\n    const ax = modP(x * iz);\n    const ay = modP(y * iz);\n    const zz = modP(z * iz);\n    if (is0) return { x: _0n, y: _1n };\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return { x: ax, y: ay };\n  });\n  const assertValidMemo = memoized((p: Point) => {\n    const { a, d } = CURVE;\n    if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n    // Equation in affine coordinates: ax + y = 1 + dxy\n    // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY\n    const { ex: X, ey: Y, ez: Z, et: T } = p;\n    const X2 = modP(X * X); // X\n    const Y2 = modP(Y * Y); // Y\n    const Z2 = modP(Z * Z); // Z\n    const Z4 = modP(Z2 * Z2); // Z\n    const aX2 = modP(X2 * a); // aX\n    const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z\n    const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY\n    if (left !== right) throw new Error('bad point: equation left != right (1)');\n    // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    return true;\n  });\n\n  // Extended Point works in extended coordinates: (x, y, z, t)  (x=x/z, y=y/z, t=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point implements ExtPointType {\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    static readonly ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n\n    constructor(\n      readonly ex: bigint,\n      readonly ey: bigint,\n      readonly ez: bigint,\n      readonly et: bigint\n    ) {\n      aCoordinate('x', ex);\n      aCoordinate('y', ey);\n      aCoordinate('z', ez);\n      aCoordinate('t', et);\n      Object.freeze(this);\n    }\n\n    get x(): bigint {\n      return this.toAffine().x;\n    }\n    get y(): bigint {\n      return this.toAffine().y;\n    }\n\n    static fromAffine(p: AffinePoint<bigint>): Point {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const { x, y } = p || {};\n      aCoordinate('x', x);\n      aCoordinate('y', y);\n      return new Point(x, y, _1n, modP(x * y));\n    }\n    static normalizeZ(points: Point[]): Point[] {\n      const toInv = Fp.invertBatch(points.map((p) => p.ez));\n      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);\n    }\n    // Multiscalar Multiplication\n    static msm(points: Point[], scalars: bigint[]): Point {\n      return pippenger(Point, Fn, points, scalars);\n    }\n\n    // \"Private method\", don't use it directly\n    _setWindowSize(windowSize: number) {\n      wnaf.setWindowSize(this, windowSize);\n    }\n    // Not required for fromHex(), which always creates valid points.\n    // Could be useful for fromAffine().\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    // Compare one point to another.\n    equals(other: Point): boolean {\n      assertPoint(other);\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    negate(): Point {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));\n    }\n\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double(): Point {\n      const { a } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1 } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other: Point) {\n      assertPoint(other);\n      const { a, d } = CURVE;\n      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;\n      const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;\n      // Faster algo for adding 2 Extended Points when curve's a=-1.\n      // http://hyperelliptic.org/EFD/g1p/auto-twisted-extended-1.html#addition-add-2008-hwcd-4\n      // Cost: 8M + 8add + 2*2.\n      // Note: It does not check whether the `other` point is valid.\n      if (a === BigInt(-1)) {\n        const A = modP((Y1 - X1) * (Y2 + X2));\n        const B = modP((Y1 + X1) * (Y2 - X2));\n        const F = modP(B - A);\n        if (F === _0n) return this.double(); // Same point. Tests say it doesn't affect timing\n        const C = modP(Z1 * _2n * T2);\n        const D = modP(T1 * _2n * Z2);\n        const E = D + C;\n        const G = B + A;\n        const H = D - C;\n        const X3 = modP(E * F);\n        const Y3 = modP(G * H);\n        const T3 = modP(E * H);\n        const Z3 = modP(F * G);\n        return new Point(X3, Y3, Z3, T3);\n      }\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    subtract(other: Point): Point {\n      return this.add(other.negate());\n    }\n\n    private wNAF(n: bigint): { p: Point; f: Point } {\n      return wnaf.wNAFCached(this, n, Point.normalizeZ);\n    }\n\n    // Constant-time multiplication.\n    multiply(scalar: bigint): Point {\n      const n = scalar;\n      ut.aInRange('scalar', n, _1n, CURVE_ORDER); // 1 <= scalar < L\n      const { p, f } = this.wNAF(n);\n      return Point.normalizeZ([p, f])[0];\n    }\n\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(scalar: bigint, acc = Point.ZERO): Point {\n      const n = scalar;\n      ut.aInRange('scalar', n, _0n, CURVE_ORDER); // 0 <= scalar < L\n      if (n === _0n) return I;\n      if (this.is0() || n === _1n) return this;\n      return wnaf.wNAFCachedUnsafe(this, n, Point.normalizeZ, acc);\n    }\n\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder(): boolean {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree(): boolean {\n      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();\n    }\n\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(iz?: bigint): AffinePoint<bigint> {\n      return toAffineMemo(this, iz);\n    }\n\n    clearCofactor(): Point {\n      const { h: cofactor } = CURVE;\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    // Converts hash string or Uint8Array to Point.\n    // Uses algo from RFC8032 5.1.3.\n    static fromHex(hex: Hex, zip215 = false): Point {\n      const { d, a } = CURVE;\n      const len = Fp.BYTES;\n      hex = ensureBytes('pointHex', hex, len); // copy hex to a new array\n      abool('zip215', zip215);\n      const normed = hex.slice(); // copy again, we'll manipulate it\n      const lastByte = hex[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = ut.bytesToNumberLE(normed);\n\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // RFC8032 prohibits >= p, but ZIP215 doesn't\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      const max = zip215 ? MASK : Fp.ORDER;\n      ut.aInRange('pointHex.y', y, _0n, max);\n\n      // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:\n      // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y - 1\n      const v = modP(d * y2 - a); // v = d y + 1.\n      let { isValid, value: x } = uvRatio(u, v); // (u/v)\n      if (!isValid) throw new Error('Point.fromHex: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('Point.fromHex: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({ x, y });\n    }\n    static fromPrivateKey(privKey: Hex) {\n      return getExtendedPublicKey(privKey).point;\n    }\n    toRawBytes(): Uint8Array {\n      const { x, y } = this.toAffine();\n      const bytes = ut.numberToBytesLE(y, Fp.BYTES); // each y has 2 x values (x, -y)\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0; // when compressing, it's enough to store y\n      return bytes; // and use the last byte to encode sign of x\n    }\n    toHex(): string {\n      return ut.bytesToHex(this.toRawBytes()); // Same as toRawBytes, but returns string.\n    }\n  }\n  const { BASE: G, ZERO: I } = Point;\n  const wnaf = wNAF(Point, nByteLength * 8);\n\n  function modN(a: bigint) {\n    return mod(a, CURVE_ORDER);\n  }\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash: Uint8Array): bigint {\n    return modN(ut.bytesToNumberLE(hash));\n  }\n\n  /** Convenience method that creates public key and other stuff. RFC8032 5.1.5 */\n  function getExtendedPublicKey(key: Hex) {\n    const len = Fp.BYTES;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    const point = G.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toRawBytes(); // Uint8Array representation\n    return { head, prefix, scalar, point, pointBytes };\n  }\n\n  // Calculates EdDSA pub key. RFC8032 5.1.5. Privkey is hashed. Use first half with 3 bits cleared\n  function getPublicKey(privKey: Hex): Uint8Array {\n    return getExtendedPublicKey(privKey).pointBytes;\n  }\n\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context: Hex = new Uint8Array(), ...msgs: Uint8Array[]) {\n    const msg = ut.concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg: Hex, privKey: Hex, options: { context?: Hex } = {}): Uint8Array {\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = G.multiply(r).toRawBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = modN(r + k * scalar); // S = (r + k * s) mod L\n    ut.aInRange('signature.s', s, _0n, CURVE_ORDER); // 0 <= s < l\n    const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));\n    return ensureBytes('result', res, Fp.BYTES * 2); // 64-byte signature\n  }\n\n  const verifyOpts: { context?: Hex; zip215?: boolean } = VERIFY_DEFAULT;\n\n  /**\n   * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n   * An extended group equation is checked.\n   */\n  function verify(sig: Hex, msg: Hex, publicKey: Hex, options = verifyOpts): boolean {\n    const { context, zip215 } = options;\n    const len = Fp.BYTES; // Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n    sig = ensureBytes('signature', sig, 2 * len); // An extended group equation is checked.\n    msg = ensureBytes('message', msg);\n    publicKey = ensureBytes('publicKey', publicKey, len);\n    if (zip215 !== undefined) abool('zip215', zip215);\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n\n    const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));\n    let A, R, SB;\n    try {\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      A = Point.fromHex(publicKey, zip215);\n      R = Point.fromHex(sig.slice(0, len), zip215);\n      SB = G.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false;\n\n    const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // Extended group equation\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);\n  }\n\n  G._setWindowSize(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n\n  const utils = {\n    getExtendedPublicKey,\n    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.\n    randomPrivateKey: (): Uint8Array => randomBytes(Fp.BYTES),\n\n    /**\n     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT\n     * values. This slows down first getPublicKey() by milliseconds (see Speed section),\n     * but allows to speed-up subsequent getPublicKey() calls up to 20x.\n     * @param windowSize 2, 4, 8, 16\n     */\n    precompute(windowSize = 8, point: ExtPointType = Point.BASE): ExtPointType {\n      point._setWindowSize(windowSize);\n      point.multiply(BigInt(3));\n      return point;\n    },\n  };\n\n  return {\n    CURVE,\n    getPublicKey,\n    sign,\n    verify,\n    ExtendedPoint: Point,\n    utils,\n  };\n}\n","export type ByteArray = number[] | Uint8Array\n\n/**\n * Check whether two sequences (e.g. Arrays of numbers) are equal.\n *\n * @param arr1 - One of the arrays to compare.\n * @param arr2 - The other array to compare.\n */\nexport function arrayEqual(arr1: ByteArray, arr2: ByteArray): boolean {\n  if (arr1.length !== arr2.length) {\n    return false\n  }\n  return arr1.every((value, index) => value === arr2[index])\n}\n\n/**\n * Check whether a value is a scalar\n *\n * @param val - The value to check.\n */\nfunction isScalar(val: ByteArray | number): val is number {\n  return typeof val === 'number'\n}\n\n/**\n * Concatenate all `arguments` into a single array. Each argument can be either\n * a single element or a sequence, which has a `length` property and supports\n * element retrieval via sequence[ix].\n *\n * > concatArgs(1, [2, 3], Uint8Array.from([4,5]), new Uint8Array([6, 7]));\n * [1,2,3,4,5,6,7]\n *\n * @param args - Concatenate of these args into a single array.\n * @returns Array of concatenated arguments\n */\n\nexport function concatArgs(...args: Array<number | ByteArray>): number[] {\n  return args.flatMap((arg) => {\n    return isScalar(arg) ? [arg] : Array.from(arg)\n  })\n}\n","/**\n * Internal webcrypto alias.\n * We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n * See utils.ts for details.\n * @module\n */\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto: any =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n","import { Input } from './types'\n\n/**\n * Normalize a string, number array, or Uint8Array to a string or Uint8Array.\n * Both node and noble lib functions accept these types.\n *\n * @param input - value to normalize\n */\nexport default function normalizeInput(input: Input): string | Uint8Array {\n  return Array.isArray(input) ? new Uint8Array(input) : input\n}\n","import { sha512 } from '@xrplf/isomorphic/sha512'\nimport { bytesToNumberBE } from '@noble/curves/abstract/utils'\n\ntype Input = Uint8Array | number[] | string\n\nexport default class Sha512 {\n  // instantiate empty sha512 hash\n  hash = sha512.create()\n\n  static half(input: Input): Uint8Array {\n    return new Sha512().add(input).first256()\n  }\n\n  add(bytes: Input): this {\n    this.hash.update(bytes)\n    return this\n  }\n\n  addU32(i: number): this {\n    const buffer = new Uint8Array(4)\n    new DataView(buffer.buffer).setUint32(0, i)\n    return this.add(buffer)\n  }\n\n  finish(): Uint8Array {\n    return this.hash.digest()\n  }\n\n  first256(): Uint8Array {\n    return this.finish().slice(0, 32)\n  }\n\n  first256BigInt(): bigint {\n    return bytesToNumberBE(this.first256())\n  }\n}\n","import { sha512 as nobleImpl } from '@noble/hashes/sha512'\n\nimport wrapNoble from '../internal/wrapNoble'\n\n/**\n * Wrap noble-libs's sha512 implementation in HashFn\n */\nexport const sha512 = wrapNoble(nobleImpl)\n","/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { type Input, Hash, abytes, aexists, aoutput, clean, createView, toBytes } from './utils.ts';\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n","/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  let Ah = new Uint32Array(lst.length);\n  let Al = new Uint32Array(lst.length);\n  for (let i = 0; i < lst.length; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n","/**\n * SHA2-512 a.k.a. sha512 and sha384. It is slower than sha256 in js because u64 operations are slow.\n *\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [the paper on truncated SHA512/256](https://eprint.iacr.org/2010/548.pdf).\n * @module\n * @deprecated\n */\nimport {\n  SHA384 as SHA384n,\n  sha384 as sha384n,\n  sha512_224 as sha512_224n,\n  SHA512_224 as SHA512_224n,\n  sha512_256 as sha512_256n,\n  SHA512_256 as SHA512_256n,\n  SHA512 as SHA512n,\n  sha512 as sha512n,\n} from './sha2.ts';\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA512: typeof SHA512n = SHA512n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha512: typeof sha512n = sha512n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA384: typeof SHA384n = SHA384n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha384: typeof sha384n = sha384n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA512_224: typeof SHA512_224n = SHA512_224n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha512_224: typeof sha512_224n = sha512_224n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA512_256: typeof SHA512_256n = SHA512_256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha512_256: typeof sha512_256n = sha512_256n;\n","/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj } from './_md.js';\nimport { type CHash, rotr, wrapConstructor } from './utils.js';\n\n/** Round constants: first 32 bits of fractional parts of the cube roots of the first 64 primes 2..311). */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ new Uint32Array([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Initial state: first 32 bits of fractional parts of the square roots of the first 8 primes 2..19. */\n// prettier-ignore\nconst SHA256_IV = /* @__PURE__ */ new Uint32Array([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19\n]);\n\n/**\n * Temporary buffer, not used to store anything between runs.\n * Named this way because it matches specification.\n */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n\n  constructor() {\n    super(64, 32, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    SHA256_W.fill(0);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n}\n\n/**\n * Constants taken from https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf.\n */\nclass SHA224 extends SHA256 {\n  protected A = 0xc1059ed8 | 0;\n  protected B = 0x367cd507 | 0;\n  protected C = 0x3070dd17 | 0;\n  protected D = 0xf70e5939 | 0;\n  protected E = 0xffc00b31 | 0;\n  protected F = 0x68581511 | 0;\n  protected G = 0x64f98fa7 | 0;\n  protected H = 0xbefa4fa4 | 0;\n  constructor() {\n    super();\n    this.outputLen = 28;\n  }\n}\n\n/** SHA2-256 hash function */\nexport const sha256: CHash = /* @__PURE__ */ wrapConstructor(() => new SHA256());\n/** SHA2-224 hash function */\nexport const sha224: CHash = /* @__PURE__ */ wrapConstructor(() => new SHA224());\n","import { secp256k1 } from '@noble/curves/secp256k1'\n\nimport Sha512 from '../../utils/Sha512'\n\nconst ZERO = BigInt(0)\n\nfunction deriveScalar(bytes: Uint8Array, discrim?: number): bigint {\n  const order = secp256k1.CURVE.n\n  for (let i = 0; i <= 0xffff_ffff; i++) {\n    // We hash the bytes to find a 256-bit number, looping until we are sure it\n    // is less than the order of the curve.\n    const hasher = new Sha512().add(bytes)\n    // If the optional discriminator index was passed in, update the hash.\n    if (discrim !== undefined) {\n      hasher.addU32(discrim)\n    }\n    hasher.addU32(i)\n    const key = hasher.first256BigInt()\n    /* istanbul ignore else */\n    if (key > ZERO && key < order) {\n      return key\n    }\n  }\n  // This error is practically impossible to reach.\n  // The order of the curve describes the (finite) amount of points on the curve\n  // https://github.com/indutny/elliptic/blob/master/lib/elliptic/curves.js#L182\n  // How often will an (essentially) random number generated by Sha512 be larger than that?\n  // There's 2^32 chances (the for loop) to get a number smaller than the order,\n  // and it's rare that you'll even get past the first loop iteration.\n  // Note that in TypeScript we actually need the throw, otherwise the function signature would be bigint | undefined\n  //\n  /* istanbul ignore next */\n  throw new Error('impossible unicorn ;)')\n}\n\n/**\n * @param seed - Bytes.\n * @param [opts] - Object.\n * @param [opts.accountIndex=0] - The account number to generate.\n * @param [opts.validator=false] - Generate root key-pair,\n *                                              as used by validators.\n * @returns {bigint} 256 bit scalar value.\n *\n */\nexport function derivePrivateKey(\n  seed: Uint8Array,\n  opts: {\n    validator?: boolean\n    accountIndex?: number\n  } = {},\n): bigint {\n  const root = opts.validator\n  const order = secp256k1.CURVE.n\n\n  // This private generator represents the `root` private key, and is what's\n  // used by validators for signing when a keypair is generated from a seed.\n  const privateGen = deriveScalar(seed)\n  if (root) {\n    // As returned by validation_create for a given seed\n    return privateGen\n  }\n  const publicGen =\n    secp256k1.ProjectivePoint.BASE.multiply(privateGen).toRawBytes(true)\n  // A seed can generate many keypairs as a function of the seed and a uint32.\n  // Almost everyone just uses the first account, `0`.\n  const accountIndex = opts.accountIndex || 0\n  return (deriveScalar(publicGen, accountIndex) + privateGen) % order\n}\n\nexport function accountPublicFromPublicGenerator(publicGenBytes: Uint8Array) {\n  const rootPubPoint = secp256k1.ProjectivePoint.fromHex(publicGenBytes)\n  const scalar = deriveScalar(publicGenBytes, 0)\n  const point = secp256k1.ProjectivePoint.BASE.multiply(scalar)\n  const offset = rootPubPoint.add(point)\n  return offset.toRawBytes(true)\n}\n","/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\nimport { abytes } from './_assert.js';\n// export { isBytes } from './_assert.js';\n// We can't reuse isBytes from _assert, because somehow this causes huge perf issues\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n// Cast array to different type\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n// Cast array to view\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n// The byte swap operation for uint32\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const byteSwapIfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): void {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n}\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n/**\n * Convert byte array to hex string.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * Convert JS string to byte array.\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('utf8ToBytes expected string, got ' + typeof str);\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = Uint8Array | string;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('Options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash function */\nexport type CHash = ReturnType<typeof wrapConstructor>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof wrapConstructorWithOpts>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof wrapXOFConstructorWithOpts>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function wrapConstructor<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function wrapConstructorWithOpts<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function wrapXOFConstructorWithOpts<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts: T) => hashCons(opts);\n  return hashC;\n}\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return crypto.randomBytes(bytesLength);\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n","/**\n * SHA2-256 a.k.a. sha256. In JS, it is the fastest hash, even faster than Blake3.\n *\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n *\n * Check out [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n * @deprecated\n */\nimport {\n  SHA224 as SHA224n,\n  sha224 as sha224n,\n  SHA256 as SHA256n,\n  sha256 as sha256n,\n} from './sha2.ts';\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA256: typeof SHA256n = SHA256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha256: typeof sha256n = sha256n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const SHA224: typeof SHA224n = SHA224n;\n/** @deprecated Use import from `noble/hashes/sha2` module */\nexport const sha224: typeof sha224n = sha224n;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(676);\n"],"names":["secp256k1P","BigInt","secp256k1N","_1n","_2n","divNearest","a","b","sqrtMod","y","P","_3n","_6n","_11n","_22n","_23n","_44n","_88n","b2","b3","b6","pow2","b9","b11","b22","b44","b88","b176","b220","b223","t1","t2","root","Fpk1","eql","sqr","Error","Field","undefined","sqrt","secp256k1","createCurve","Fp","n","Gx","Gy","h","lowS","endo","beta","splitScalar","k","a1","b1","a2","POW_2_128","c1","c2","k1","mod","k2","k1neg","k2neg","sha256","_0n","TAGGED_HASH_PREFIXES","taggedHash","tag","messages","tagP","tagH","Uint8Array","from","c","charCodeAt","concatBytes","pointToBytes","point","toRawBytes","slice","numTo32b","numberToBytesBE","modP","x","modN","Point","ProjectivePoint","schnorrGetExtPubKey","priv","d_","utils","normPrivateKeyToScalar","p","fromPrivateKey","scalar","hasEvenY","bytes","lift_x","aInRange","xx","assertValidity","num","bytesToNumberBE","challenge","args","schnorrVerify","signature","message","publicKey","sig","ensureBytes","m","pub","r","subarray","inRange","s","e","R","Q","BASE","multiplyAndAddUnsafe","toAffine","error","schnorr","getPublicKey","privateKey","sign","auxRand","randomBytes","px","d","t","rand","k_","rx","set","verify","randomPrivateKey","isoMap","isogenyMap","map","i","j","mapSWU","mapToCurveSimpleSWU","A","B","Z","create","htf","createHasher","scalars","DST","encodeDST","ORDER","expand","hash","hashToCurve","encodeToCurve","SHA1_IV","Uint32Array","SHA1_W","SHA1","HashMD","constructor","super","C","D","E","get","this","process","view","offset","getUint32","rotl","F","K","Chi","Maj","T","roundClean","clean","destroy","buffer","sha1","p32","Math","pow","Array","length","_","floor","abs","sin","MD5_IV","MD5_W","MD5","g","md5","Rho160","Id160","fill","Pi160","idxLR","res","push","idxL","idxR","shifts160","shiftsL160","idx","shiftsR160","Kl160","Kr160","ripemd_f","group","z","BUF_160","RIPEMD160","h0","h1","h2","h3","h4","al","ar","bl","br","cl","cr","dl","dr","el","er","rGroup","hbl","hbr","rl","rr","sl","sr","tl","tr","destroyed","ripemd160","field","COEFF","reverse","xNum","xDen","yNum","yDen","val","reduce","acc","add","mul","div","mapToCurve","def","msg","options","u","hash_to_field","u0","fromAffine","u1","clearCofactor","isArray","os2ip","i2osp","value","anum","strxor","arr","item","Number","isSafeInteger","expand_message_xmd","lenInBytes","H","abytes","utf8ToBytes","outputLen","b_in_bytes","blockLen","r_in_bytes","ell","ceil","DST_prime","Z_pad","l_i_b_str","b_0","expand_message_xof","dkLen","update","digest","count","validateObject","_DST","log2p","toString","L","len_in_bytes","prb","elm_offset","tv","bits","constTimeNegate","hasPrecomputes","elm","getW","unsafeLadder","ZERO","double","precomputeWindow","W","windows","windowSize","calcWOpts","points","base","window","wNAF","precomputes","f","mask","maxNumber","shiftBy","wbits","offset1","offset2","cond1","cond2","wNAFUnsafe","curr","negate","getPrecomputes","transform","comp","pointPrecomputes","wNAFCached","wNAFCachedUnsafe","prev","setWindowSize","validateW","pointWindowSizes","delete","fieldN","validateMSMPoints","validateMSMScalars","zero","bitLen","MASK","buckets","sum","BITS","resI","sumI","tableSize","chunks","tables","curve","validateField","nBitLength","nByteLength","Object","freeze","nLength","condition","neg","forEach","isValid","WeakMap","edwardsPriv","hashed","ed25519Defaults","adjustScalarBytes","ED25519_P","ED25519_SQRT_M1","_5n","_8n","ed25519_pow_2_252_3","_10n","_20n","_40n","_80n","b4","b5","b10","b20","b40","b80","b160","b240","b250","pow_p_5_8","uvRatio","v","v3","vx2","root1","root2","useRoot1","useRoot2","noRoot","isNegativeLE","ED25519_TORSION_SUBGROUP","sha512","ed25519_domain","data","ctx","phflag","edwardsToMontgomeryPub","edwardsPub","ed25519","ExtendedPoint","fromHex","toBytes","inv","twistedEdwards","ed25519ctx","domain","ed25519ph","assign","prehash","x25519","montgomery","montgomeryBits","Gu","powPminus2","edwardsToMontgomery","ELL2_C1","ELL2_C2","ELL2_C3","ONE","ELL2_C1_EDWARDS","FpSqrtEven","xMn","xMd","yMn","yMd","ELL2_C4","ELL2_J","tv1","xd","x1n","tv2","gxd","gx1","tv3","y11","y12","e1","y1","cmov","x2n","y21","y22","gx2","e2","y2","e3","xn","e4","isOdd","map_to_curve_elligator2_curve25519","yn","sub","yd","invertBatch","map_to_curve_elligator2_edwards25519","assertRstPoint","other","RistPoint","SQRT_M1","SQRT_AD_MINUS_ONE","INVSQRT_A_MINUS_D","ONE_MINUS_D_SQ","D_MINUS_ONE_SQ","invertSqrt","number","MAX_255B","bytes255ToNumberLE","CURVE","bytesToNumberLE","calcElligatorRistrettoMap","r0","Ns","Ns_D_is_sq","s_","Nt","s2","W0","W1","W2","W3","ep","ap","hex","R1","R2","emsg","equalBytes","numberToBytesLE","u2","u1_2","u2_2","I","Dx","Dy","msm","Fn","pippenger","ex","ey","ez","et","u2sq","invsqrt","D1","D2","zInv","_x","_y","toHex","bytesToHex","equals","X1","Y1","X2","Y2","one","two","subtract","multiply","multiplyUnsafe","RistrettoPoint","hashToRistretto255","uniform_bytes","hash_to_ristretto255","assertHelper","ok","cond","SHA256_K","SHA256_W","SHA256","SHA256_IV","G","W15","s0","rotr","s1","T1","T2","SHA224","SHA224_IV","K512","u64","split","SHA512_Kh","SHA512_Kl","SHA512_W_H","SHA512_W_L","SHA512","Ah","SHA512_IV","Al","Bh","Bl","Ch","Cl","Dh","Dl","Eh","El","Fh","Fl","Gh","Gl","Hh","Hl","W15h","W15l","s0h","rotrSH","shrSH","s0l","rotrSL","shrSL","W2h","W2l","s1h","rotrBH","s1l","rotrBL","SUMl","add4L","SUMh","add4H","sigma1h","sigma1l","CHIh","CHIl","T1ll","add5L","T1h","add5H","T1l","sigma0h","sigma0l","MAJh","MAJl","l","All","add3L","add3H","SHA384","SHA384_IV","T224_IV","T256_IV","SHA512_224","SHA512_256","sha224","sha384","sha512_256","sha512_224","curveDef","opts","validateBasic","ut","hmac","bits2int","bits2int_modN","validateOpts","CURVE_ORDER","compressedLen","BYTES","uncompressedLen","invN","invert","weierstrassEquation","isWithinCurveOrder","weierstrassPoints","_c","isCompressed","cat","abool","fromBytes","len","head","tail","sqrtError","suffix","numToNByteStr","isBiggerThanHalfOrder","slcNum","to","Signature","recovery","fromCompact","fromDER","DER","toSig","addRecoveryBit","recoverPublicKey","msgHash","rec","includes","radj","prefix","ir","hasHighS","normalizeS","toDERRawBytes","hexToBytes","toDERHex","hexFromSig","toCompactRawBytes","toCompactHex","isValidPrivateKey","getMinHashLength","mapHashToField","precompute","_setWindowSize","isProbPub","isBytes","str","delta","ORDER_MASK","bitMask","int2octets","defaultSigOpts","defaultVerOpts","getSharedSecret","privateA","publicB","privKey","seed","k2sig","some","extraEntropy","ent","validateSigVerOpts","h1int","seedArgs","kBytes","ik","q","normS","prepSig","createHmacDrbg","drbg","sg","format","isHex","isObj","_sig","derError","Err","is","sqrtRatio","SWUFpSqrtRatio","tv4","tv5","tv6","b2n","h2b","DERErr","_tlv","encode","dataLen","numberToHexUnpadded","lenLen","decode","pos","first","lengthBytes","_int","parseInt","int","tlv","seqBytes","seqLeftBytes","rBytes","rLeftBytes","sBytes","sLeftBytes","seq","_4n","allowedPrivateKeyLengths","wrapPrivateKey","isTorsionFree","allowInfinityPoint","validatePointOpts","_isCompressed","x2","x3","key","lengths","N","padStart","assertPrjPoint","toAffineMemo","memoized","iz","py","pz","is0","ax","ay","zz","assertValidMemo","left","right","normalizeZ","toInv","wnaf","Z1","Z2","U1","U2","X3","Y3","Z3","t0","t3","t4","t5","sc","k1p","k2p","fake","f2p","f1p","cofactor","_bits","o","_2n_pow_c1_1","_2n_pow_c1","c3","c4","c5","c6","c7","isQR","tvv5","crypto","globalThis","codec","encodeSeed","decodeSeed","encodeAccountID","decodeAccountID","encodeNodePublic","decodeNodePublic","encodeAccountPublic","decodeAccountPublic","isValidClassicAddress","PREFIX_BYTES","main","test","encodeXAddress","accountId","theTag","flag","concat","encodeChecked","decodeXAddress","xAddress","decoded","decodeChecked","buf","decodedPrefix","equal","isUint8ArrayForTestAddress","tagFromUint8Array","classicAddressToXAddress","classicAddress","xAddressToClassicAddress","isValidXAddress","_error","getSigningScheme","algorithm","deriveAddressFromBytes","publicKeyBytes","computePublicKeyHash","generateSeed","entropy","type","deriveKeypair","scheme","keypair","messageToVerify","half","messageHex","getAlgorithmFromPrivateKey","getAlgorithmFromPublicKey","deriveAddress","deriveNodeAddress","generatorBytes","accountPublicFromPublicGenerator","title","hexToNumber","expectedLength","diff","TextEncoder","min","max","hashLen","qByteLen","hmacFn","u8n","reset","reseed","u8fr","gen","out","pred","object","validators","optValidators","checkField","fieldName","isOptional","checkVal","validatorFns","String","entries","fn","arg","computed","ArrayBuffer","isView","name","hexes","asciis","_0","_9","asciiToBase16","ch","hl","array","ai","hi","n1","n2","char","arrays","pad","isPosBig","bigint","function","boolean","string","stringOrUint8Array","notImplemented","secretNumbers","_account","familySeed","address","_secret","parseSecretString","entropyToSecret","randomSecret","validateLengths","derive","getSecret","getSecretString","join","getAddress","getFamilySeed","getKeypair","secretToEntropy","derived","derivePrivateKey","startsWith","normedPrivateKey","toUpperCase","anumber","ahash","aexists","instance","checkFinished","finished","aoutput","byteOffset","byteLength","DataView","word","shift","hasHexBuiltin","async","iters","tick","cb","ts","Date","now","nextTick","TextDecoder","defaults","call","bytesLength","getRandomValues","byteSwap","byteSwap32","isLE","swap8IfBE","byteSwapIfBE","swap32IfBE","hashCons","hashC","tmp","createOptHasher","createXOFer","wrapConstructor","wrapConstructorWithOpts","wrapXOFConstructorWithOpts","ED25519_SEED","codecOptions","codecWithXrpAlphabet","_sha256","_codec","base58xrp","versions","_encodeVersioned","base58string","types","versionTypes","withoutSum","versionLengthGuess","payloadLength","versionBytes","payload","version","arrayEqual","check","_encodeRaw","concatArgs","intArray","_decodeRaw","_verifyCheckSum","checkByteLength","checksum","encodeAddress","decodeAddress","rawPrivateKey","zip215","HEX_REGEX","views","buf1","buf2","dv1","Int8Array","dv2","isArrayOf","isString","every","afn","input","astr","label","aArr","astrArr","anumArr","chain","id","wrap","reduceRight","alphabet","letters","lettersA","indexes","Map","digits","letter","separator","padding","chr","end","normalize","convertRadix","dlen","carry","done","digit","fromCarry","digitBase","rounded","gcd","radix2carry","powers","convertRadix2","radix","radix2","revPadding","unsafeWrapper","apply","oldChecksum","newChecksum","base16","base32","base32nopad","base32hex","base32hexnopad","base32crockford","replace","hasBase64Builtin","toBase64","fromBase64","decodeBase64Builtin","isUrl","re","lastChunkHandling","base64","base64nopad","base64url","base64urlnopad","genBase58","abc","base58","base58flickr","XMR_BLOCK_LEN","base58xmr","block","indexOf","createBase58check","base58check","BECH_ALPHABET","POLYMOD_GENERATORS","bech32Polymod","pre","chk","bechChecksum","words","encodingConst","genBech32","encoding","ENCODING_CONST","_words","fromWords","toWords","fromWordsUnsafe","limit","plen","TypeError","actualLength","lowered","toLowerCase","slen","sepIndex","lastIndexOf","endsWith","encodeFromBytes","decodeToBytes","decodeUnsafe","bech32","bech32m","utf8","hexBuiltin","CODERS","coderTypeError","bytesToString","hasOwnProperty","stringToBytes","setBigUint64","_32n","_u32_max","wh","wl","setUint32","Hash","padOffset","createView","take","dataView","digestInto","oview","outLen","state","_cloneInto","hexByte","byte","isNaN","hexToString","stringToHex","chash","wrapped","defHash","weierstrass","getHash","msgs","fromBig","U32_MASK64","le","lst","toBig","_l","rotr32H","_h","rotr32L","rotlSH","rotlSL","rotlBH","rotlBL","low","randomEntropy","calculateChecksum","position","checkChecksum","normalizedChecksum","normalizedValue","_a","chunk","buffChunk","no","repeat","secret","normalizedSecret","index","montgomeryBytes","fieldLen","cswap","swap","x_2","x_3","dummy","a24","encodeUCoordinate","scalarMult","pointU","uEnc","decodeUCoordinate","pu","x_1","sw","z_2","z_3","k_t","AA","BB","DA","CB","dacb","da_cb","z2","montgomeryLadder","decodeScalar","GuBytes","scalarMultBase","Prefix","KEY_TYPES","NONE","SECP256K1_PRIVATE","ED25519","SECP256K1_PUB_X","SECP256K1_PUB_X_ODD_Y","SECP256K1_PUB_XY","prefixRepr","getAlgorithmFromKey","getKeyInfo","usedPrefix","validFormats","colWidth","filter","padEnd","getValidFormatsTable","keyError","HMAC","_key","iHash","oHash","getPrototypeOf","power","modulo","FIELD_FIELDS","lhs","rhs","legendre","FpLegendre","redef","sqrtP","FpPow","sqrN","addN","subN","mulN","FpSqrt","FpInvertBatch","groupOrder","minLen","fieldOrder","getFieldBytesLength","reduced","result","tonelliShanks","legendreC","S","p1div4","Q1div2","ge","nv","nums","lastMultiplied","inverted","order","legendreConst","_nBitLength","bitLength","cHash","aCoordinate","assertPoint","X","Y","Z4","aX2","X1Z2","X2Z1","Y1Z2","Y2Z1","x1y1","T3","isSmallOrder","normed","lastByte","isXOdd","isLastByteOdd","getExtendedPublicKey","modN_LE","pointBytes","hashDomainToScalar","context","verifyOpts","VERIFY_DEFAULT","SB","arr1","arr2","flatMap","Sha512","first256","addU32","finish","first256BigInt","clone","deriveScalar","discrim","hasher","validator","privateGen","accountIndex","publicGenBytes","rootPubPoint","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__"],"sourceRoot":""}